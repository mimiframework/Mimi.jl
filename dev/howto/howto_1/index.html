<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>1 Construct + Run a Model · Mimi.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Mimi.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/tutorial_main/">Tutorials Intro</a></li><li><a class="tocitem" href="../../tutorials/tutorial_1/">1 Install Mimi</a></li><li><a class="tocitem" href="../../tutorials/tutorial_2/">2 Run an Existing Model</a></li><li><a class="tocitem" href="../../tutorials/tutorial_3/">3 Modify an Existing Model</a></li><li><a class="tocitem" href="../../tutorials/tutorial_4/">4 Create a Model</a></li><li><a class="tocitem" href="../../tutorials/tutorial_5/">5 Monte Carlo + Sensitivity Analysis</a></li><li><a class="tocitem" href="../../tutorials/tutorial_6/">6 Create a Model with Composite Components</a></li></ul></li><li><span class="tocitem">How-to Guides</span><ul><li><a class="tocitem" href="../howto_main/">How-to Guides Intro</a></li><li class="is-active"><a class="tocitem" href>1 Construct + Run a Model</a><ul class="internal"><li><a class="tocitem" href="#Defining-Components-1"><span>Defining Components</span></a></li><li><a class="tocitem" href="#Constructing-a-Model-1"><span>Constructing a Model</span></a></li><li><a class="tocitem" href="#Running-a-Model-1"><span>Running a Model</span></a></li><li><a class="tocitem" href="#Long-Example-1"><span>Long Example</span></a></li></ul></li><li><a class="tocitem" href="../howto_2/">2 Explore Results</a></li><li><a class="tocitem" href="../howto_3/">3 Monte Carlo + SA</a></li><li><a class="tocitem" href="../howto_4/">4 Timesteps</a></li><li><a class="tocitem" href="../howto_5/">5 Parameters + Variables</a></li><li><a class="tocitem" href="../howto_6/">6 Update Time Dimension</a></li><li><a class="tocitem" href="../howto_7/">7 Port to v0.5.0</a></li><li><a class="tocitem" href="../howto_8/">8 Port to v1.0.0</a></li><li><a class="tocitem" href="../howto_9/">9 Port to New Param API</a></li></ul></li><li><span class="tocitem">Advanced How-to Guides</span><ul><li><a class="tocitem" href="../../howto_advanced/howto_adv_main/">Advanced How-to Guides Intro</a></li><li><a class="tocitem" href="../../howto_advanced/howto_adv_buildinit/">Build and Init Functions</a></li><li><a class="tocitem" href="../../howto_advanced/howto_adv_datumrefs/">Using Datum References</a></li></ul></li><li><span class="tocitem">Reference Guides</span><ul><li><a class="tocitem" href="../../ref/ref_main/">Reference Guides Intro</a></li><li><a class="tocitem" href="../../ref/ref_API/">Mimi API</a></li><li><a class="tocitem" href="../../ref/ref_structures_classes_types/">Structures: Classes.jl and Types</a></li><li><a class="tocitem" href="../../ref/ref_structures_definitions/">Structures: Definitions</a></li><li><a class="tocitem" href="../../ref/ref_structures_instances/">Structures: Instances</a></li></ul></li><li><span class="tocitem">Explanations</span><ul><li><a class="tocitem" href="../../explanations/exp_main/">Explanations Intro</a></li><li><a class="tocitem" href="../../explanations/exp_pkgs/">Models as Packages</a></li></ul></li><li><a class="tocitem" href="../../faq/">FAQ</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">How-to Guides</a></li><li class="is-active"><a href>1 Construct + Run a Model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>1 Construct + Run a Model</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mimiframework/Mimi.jl/blob/master/docs/src/howto/howto_1.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="How-to-Guide-1:-Construct-and-Run-a-Model-1"><a class="docs-heading-anchor" href="#How-to-Guide-1:-Construct-and-Run-a-Model-1">How-to Guide 1: Construct and Run a Model</a><a class="docs-heading-anchor-permalink" href="#How-to-Guide-1:-Construct-and-Run-a-Model-1" title="Permalink"></a></h1><p>This how-to guide pairs nicely with <a href="../../tutorials/tutorial_4/#Tutorial-4:-Create-a-Model-1">Tutorial 4: Create a Model</a> and <a href="../../tutorials/tutorial_6/#Tutorial-6:-Create-a-Model-Including-Composite-Components-1">Tutorial 6: Create a Model Including Composite Components</a>, and serves as a higher-level version and refresher for those with some experience with Mimi.  If this is your first time constructing and running a Mimi model, we recommend you start with Tutorial 4 (and Tutorial 6 if you are interested in composite components), which will give you more detailed step-by step instructions.</p><h2 id="Defining-Components-1"><a class="docs-heading-anchor" href="#Defining-Components-1">Defining Components</a><a class="docs-heading-anchor-permalink" href="#Defining-Components-1" title="Permalink"></a></h2><p>Any Mimi model is made up of at least one component, so before you construct a model, you need to create your components. </p><p>Mimi provides two types of components, leaf components and composite components, which generally match intuitively with the classic computer science tree data structure. Note that many existing models are &quot;flat models&quot; with one layer of components, and thus only contain leaf components.</p><h3 id="Leaf-Components-1"><a class="docs-heading-anchor" href="#Leaf-Components-1">Leaf Components</a><a class="docs-heading-anchor-permalink" href="#Leaf-Components-1" title="Permalink"></a></h3><p>A leaf component can have any number of parameters and variables. Parameters are data values that will be provided to the component as input, and variables are values that the component will calculate in the <code>run_timestep</code> function when the model is run. The index of a parameter or variable determines the number of dimensions that parameter or variable has. They can be scalar values and have no index, such as parameter &#39;c&#39; in the example below. They can be one-dimensional, such as the variable &#39;A&#39; and the parameters &#39;d&#39; and &#39;f&#39; below. They can be two dimensional such as variable &#39;B&#39; and parameter &#39;e&#39; below. Note that any index other than &#39;time&#39; must be declared at the top of the component, as shown by <code>regions = Index()</code> below.</p><p>The user must define a <code>run_timestep</code> function for each component. </p><p>We define a leaf component in the following way:</p><pre><code class="language-julia">using Mimi

@defcomp MyComponentName begin
  regions = Index()

  A = Variable(index = [time])
  B = Variable(index = [time, regions])

  c = Parameter()
  d = Parameter(index = [time])
  e = Parameter(index = [time, regions])
  f = Parameter(index = [regions])

  function run_timestep(p, v, d, t)
    v.A[t] = p.c + p.d[t]
    for r in d.regions
      v.B[t, r] = p.f[r] * p.e[t, r]
    end
  end
end</code></pre><p>The <code>run_timestep</code> function is responsible for calculating values for each variable in that component.  Note that the component state (defined by the first three arguments) has fields for the Parameters, Variables, and Dimensions of the component you defined. You can access each parameter, variable, or dimension using dot notation as shown above.  The fourth argument is an <code>AbstractTimestep</code>, i.e., either a <code>FixedTimestep</code> or a <code>VariableTimestep</code>, which represents which timestep the model is at.</p><p>The API for using the fourth argument, represented as <code>t</code> in this explanation, is described in a following how-to guide How-to Guide 4: Work with Timesteps, Parameters, and Variables. </p><p>To access the data in a parameter or to assign a value to a variable, you must use the appropriate index or indices (in this example, either the Timestep or region or both).</p><p>By default, all parameters and variables defined in the <a href="../../ref/ref_API/#Mimi.@defcomp"><code>@defcomp</code></a> will be allocated storage as scalars or Arrays of type <code>Float64.</code> For a description of other data type options, see How-to Guide 5: Work with Parameters and Variables </p><h3 id="Composite-Components-1"><a class="docs-heading-anchor" href="#Composite-Components-1">Composite Components</a><a class="docs-heading-anchor-permalink" href="#Composite-Components-1" title="Permalink"></a></h3><p>Composite components can contain any number of subcomponents, <strong>which can be either leaf components or more composite components</strong>. To the degree possible, composite components are designed to operate in the same way as leaf components, although there are a few necessary differences:</p><ul><li><p>Leaf components are defined using the macro <a href="../../ref/ref_API/#Mimi.@defcomp"><code>@defcomp</code></a>, while Composite components are defined using <a href="../../ref/ref_API/#Mimi.@defcomposite"><code>@defcomposite</code></a>. Each macro supports syntax and semantics specific to the type of component.</p></li><li><p>Leaf components support user-defined <code>run_timestep()</code> functions, whereas composites have a built-in <code>run_timestep()</code> function that iterates over its subcomponents and calls their <code>run_timestep()</code> function.</p></li></ul><p>A composite component can have any number of parameters and variables, which point to one or more parameters or variables in the composite&#39;s subcomponents.  Data all eventually flows through to the leaf components, where calculations are made at runtime and then data is bubbled up into composite components as necessary.</p><p>Note that it is not imperative that you explicitly define parameters or variables in a composite component.  It may be desireable for specific use cases, such as ease of access for future connections, future model modification, connecting multiple subcomponent parameters or variables to one higher level component parameter or variable, or parameter conflict resolution (explained below). </p><p>We define a composite component in the following way:</p><p>First we will need to have defined some leaf components:</p><pre><code class="language-julia">@defcomp Leaf1 begin
    par_1_1 = Parameter(index=[time])      
    var_1_1 = Variable(index=[time])       
    foo = Parameter()

    function run_timestep(p, v, d, t)
        v.var_1_1[t] = p.par_1_1[t]
    end
end

@defcomp Leaf2 begin
    par_2_1 = Parameter(index=[time])      
    par_2_2 = Parameter(index=[time])      
    var_2_1 = Variable(index=[time])      
    foo = Parameter()

    function run_timestep(p, v, d, t)
        v.var_2_1[t] = p.par_2_1[t] + p.foo * p.par_2_2[t]
    end
end</code></pre><p>Now we construct a composite component <code>MyCompositeComponent</code> which holds the two subcomponents, <code>Leaf1</code> and <code>Leaf2</code>:</p><pre><code class="language-julia">@defcomposite MyCompositeComponent begin
    Component(Leaf1)
    Component(Leaf2)

    foo1 = Parameter(Leaf1.foo)
    foo2 = Parameter(Leaf2.foo)

    var_2_1 = Variable(Leaf2.var_2_1)

    connect(Leaf2.par_2_1, Leaf1.var_1_1)
    connect(Leaf2.par_2_2, Leaf1.var_1_1)
end</code></pre><p>The <code>connect</code> calls are responsible for making internal connections between any two components held by a composite component, similar to <a href="../../ref/ref_API/#Mimi.connect_param!"><code>connect_param!</code></a> described in the Model section below. </p><p>As mentioned above, conflict resolution refers to cases where two subcomponents have identically named parameters, and thus the user needs to explicitly demonstrate that they are aware of this and create a new shared model parameter that will point to all subcomponent parameters with that name.  For example, given leaf components <code>A</code> and <code>B</code>: </p><pre><code class="language-julia">@defcomp Leaf1 begin
    p1 = Parameter()
    v1 = Variable(index=[time])
end

@defcomp Leaf2 begin
    p1 = Parameter()
end</code></pre><p>The following will fail because you need to resolve the namespace collision of the <code>p1</code>&#39;s:</p><pre><code class="language-julia">@defcomposite MyCompositeComponent begin
    Component(Leaf1)
    Component(Leaf2)
end</code></pre><p>Fix it with a call to <code>Parameter</code> as follows:</p><pre><code class="language-julia">@defcomposite MyCompositeComponent begin
    Component(Leaf1)
    Component(Leaf2)
        
    p1 = Parameter(Leaf1.p1, Leaf2.p1)
end</code></pre><h2 id="Constructing-a-Model-1"><a class="docs-heading-anchor" href="#Constructing-a-Model-1">Constructing a Model</a><a class="docs-heading-anchor-permalink" href="#Constructing-a-Model-1" title="Permalink"></a></h2><p>Continuing the analogy of a tree data structure, one may consider the Model to be the root, orchestrating the running of all components it contains.</p><p>The first step in constructing a model is to set the values for each index of the model. Below is an example for setting the &#39;time&#39; and &#39;regions&#39; indexes. The time index expects either a numerical range or an array of numbers.  If a single value is provided, say &#39;100&#39;, then that index will be set from 1 to 100. Other indexes can have values of any type.</p><pre><code class="language-julia">using Mimi

m = Model()
set_dimension!(m, :time, 1850:2200)
set_dimension!(m, :regions, [&quot;USA&quot;, &quot;EU&quot;, &quot;LATAM&quot;])</code></pre><p><em>A Note on Time Indexes:</em> It is important to note that the values used for the time index are the <em>start times</em> of the timesteps.  If the range or array of time values has a uniform timestep length, the model will run <em>through</em> the last year of the range with a last timestep period length consistent with the other timesteps.  If the time values are provided as an array with non-uniform timestep lengths, the model will run <em>through</em> the last year in the array with a last timestep period length <em>assumed to be one</em>. </p><p>The next step is to add components to the model. This is done by the following syntax:</p><pre><code class="language-julia">add_comp!(m, ComponentA)
add_comp!(m, ComponentA, :GDP)</code></pre><p>The first argument to <a href="../../ref/ref_API/#Mimi.add_comp!"><code>add_comp!</code></a> is the model, the second is the name of the ComponentId defined by <a href="../../ref/ref_API/#Mimi.@defcomp"><code>@defcomp</code></a>. If an optional third symbol is provided (as in the second line above), this will be used as the name of the component in this model. This allows you to add multiple versions of the same component to a model, with different names.</p><p>The <a href="../../ref/ref_API/#Mimi.add_comp!"><code>add_comp!</code></a> function has two more optional keyword arguments, <code>first</code> and <code>last</code>, which can be used to indicate a fixed start and/or end time (year in this case) that the component should run for (within the bounds of the model&#39;s time dimension).  For example, the following indicates that <code>ComponentA</code> should only run from 1900 to 2000.</p><pre><code class="language-julia">add_comp!(m, ComponentA; first = 1900, last = 2000)</code></pre><p>The next step is to set the values for all the parameters in the components. Parameters can either have their values assigned from external data, or they can internally connect to the values from variables in other components of the model. When assigned from external data, parameters are externally connected to a model parameter, which can be a shared model parameter with its own name and connected to more than one component-parameter pair, or an unshared model parameter accessible only through the component-parameter pair names and connected solely to that parameter.</p><p>To make an external connection to an unshared model parameter, the syntax is as follows:</p><pre><code class="language-julia">update_param!(m, :ComponentName, :ParameterName1, 0.8) # a scalar parameter
update_param!(m, :ComponentName, :ParameterName2, rand(351, 3)) # a two-dimensional parameter</code></pre><p>To make an external connection to a shared model parameter, the syntax is as follows:</p><pre><code class="language-julia">add_shared_param!(m, :ModelParameterName, 1.0) # add a shared model parameter to the model
connect_param!(m, :ComponentName, :ParameterName3, :ModelParameterName) # connect component parameter
connect_param!(m, :ComponentName, :ParameterName4, :ModelParameterName)</code></pre><p>To make an internal connection, the syntax is as follows.  </p><pre><code class="language-julia">connect_param!(m, :TargetComponent, :ParameterName, :SourceComponent, :VariableName)
connect_param!(m, :TargetComponent, :ParameterName, :SourceComponent, :VariableName)</code></pre><p>or</p><pre><code class="language-julia">connect_param!(m, :TargetComponent=&gt;:ParameterName, :SourceComponent=&gt;:VariableName)
connect_param!(m, :TargetComponent=&gt;:ParameterName, :SourceComponent=&gt;:VariableName)</code></pre><p>If you wish to delete a component that has already been added, do the following:</p><pre><code class="language-julia">delete!(m, :ComponentName)</code></pre><p>This will delete the component from the model and remove any existing connections it had. Thus if a different component was previously connected to this component, you will need to connect its parameter(s) to something else.</p><h2 id="Running-a-Model-1"><a class="docs-heading-anchor" href="#Running-a-Model-1">Running a Model</a><a class="docs-heading-anchor-permalink" href="#Running-a-Model-1" title="Permalink"></a></h2><p>After all components have been added to your model and all parameters have been connected to either external values or internally to another component, then the model is ready to be run. Note: at each timestep, the model will run the components in the order you added them. So if one component is going to rely on the value of another component, then the user must add them to the model in the appropriate order.</p><pre><code class="language-julia">run(m)</code></pre><h2 id="Long-Example-1"><a class="docs-heading-anchor" href="#Long-Example-1">Long Example</a><a class="docs-heading-anchor-permalink" href="#Long-Example-1" title="Permalink"></a></h2><p>As a final, lengthier example, below we use the syntax in this tutorial to create and run a toy model with the following structure:</p><pre><code class="language-none">      top
    /     \
   A       B
 /  \     /  \
1    2   3    4</code></pre><pre><code class="language-julia">@defcomp Comp1 begin
    par_1_1 = Parameter(index=[time])      # external input
    var_1_1 = Variable(index=[time])       # computed
    foo = Parameter()
    function run_timestep(p, v, d, t)
        v.var_1_1[t] = p.par_1_1[t]
    end
end

@defcomp Comp2 begin
    par_2_1 = Parameter(index=[time])      # connected to Comp1.var_1_1
    par_2_2 = Parameter(index=[time])      # external input
    var_2_1 = Variable(index=[time])       # computed
    foo = Parameter()
    function run_timestep(p, v, d, t)
        v.var_2_1[t] = p.par_2_1[t] + p.foo * p.par_2_2[t]
    end
end

@defcomp Comp3 begin
    par_3_1 = Parameter(index=[time])      # connected to Comp2.var_2_1
    var_3_1 = Variable(index=[time])       # external output
    foo = Parameter(default=30)

    function run_timestep(p, v, d, t)
        # @info &quot;Comp3 run_timestep&quot;
        v.var_3_1[t] = p.par_3_1[t] * 2
    end
end

@defcomp Comp4 begin
    par_4_1 = Parameter(index=[time])      # connected to Comp2.var_2_1
    var_4_1 = Variable(index=[time])        # external output
    foo = Parameter(default=300)

    function run_timestep(p, v, d, t)
        # @info &quot;Comp4 run_timestep&quot;
        v.var_4_1[t] = p.par_4_1[t] * 2
    end
end

@defcomposite A begin
    Component(Comp1)
    Component(Comp2)

    foo1 = Parameter(Comp1.foo)
    foo2 = Parameter(Comp2.foo)

    var_2_1 = Variable(Comp2.var_2_1)

    connect(Comp2.par_2_1, Comp1.var_1_1)
    connect(Comp2.par_2_2, Comp1.var_1_1)
end

@defcomposite B begin
    Component(Comp3)
    Component(Comp4)

    foo3 = Parameter(Comp3.foo)
    foo4 = Parameter(Comp4.foo)

    var_3_1 = Variable(Comp3.var_3_1)
end

@defcomposite top begin
    Component(A)

    fooA1 = Parameter(A.foo1)
    fooA2 = Parameter(A.foo2)

    # TBD: component B isn&#39;t getting added to mi
    Component(B)
    foo3 = Parameter(B.foo3)
    foo4 = Parameter(B.foo4)

    var_3_1 = Variable(B.var_3_1)

    connect(B.par_3_1, A.var_2_1)
    connect(B.par_4_1, B.var_3_1)
end

m = Model()
set_dimension!(m, :time, 2005:2020)
add_comp!(m, top, nameof(top))
update_param!(m, :top, :fooA1, 1)
update_param!(m, :top, :fooA2, 2)
update_param!(m, :top, :foo3, 10)
update_param!(m, :top, :foo4, 20)
update_param!(m, :top, :par_1_1, collect(1:length(2005:2020)))
run(m)</code></pre><p>Take a look at what you&#39;ve created now using <code>explore(m)</code>, a peek into what you can learn in How To Guide 2!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../howto_main/">« How-to Guides Intro</a><a class="docs-footer-nextpage" href="../howto_2/">2 Explore Results »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 28 November 2024 17:48">Thursday 28 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
