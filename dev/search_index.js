var documenterSearchIndex = {"docs":
[{"location":"installation/#Installation-Guide-1","page":"Installation Guide","title":"Installation Guide","text":"","category":"section"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"This guide will briefly explain how to install julia and Mimi.","category":"page"},{"location":"installation/#Installing-julia-1","page":"Installation Guide","title":"Installing julia","text":"","category":"section"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"Mimi requires the programming language julia to run. You can download the current release from the julia download page. You should download and install the command line version from that page.","category":"page"},{"location":"installation/#Installing-Mimi-1","page":"Installation Guide","title":"Installing Mimi","text":"","category":"section"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"Once julia is installed, start julia and you should see a julia command prompt. To install the Mimi package, issue the following command from the Pkg REPL mode, which is entered by typing ] and exited with a single backspace:","category":"page"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"pkg> add Mimi","category":"page"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"You only have to run this command once on your machine.","category":"page"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"As Mimi gets improved we will release new versions of the package. To make sure you always have the latest version of Mimi installed, you can run the following command at the julia Pkg REPL:","category":"page"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"pkg> update","category":"page"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"This will update all installed packages to their latest version (not just the Mimi package).","category":"page"},{"location":"installation/#Using-Mimi-1","page":"Installation Guide","title":"Using Mimi","text":"","category":"section"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"When you start a new julia command prompt, Mimi is not yet loaded into that julia session. To load Mimi, issue the following command:","category":"page"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"julia> using Mimi","category":"page"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"You will have to run this command every time you want to use Mimi in julia. You would typically also add using Mimi to the top of any julia code file that for example defines Mimi components.","category":"page"},{"location":"installation/#Editor-support-1","page":"Installation Guide","title":"Editor support","text":"","category":"section"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"There are various editors around that have julia support:","category":"page"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"IJulia adds julia support to the jupyter (formerly IPython) notebook system.\nJuno adds julia specific features to the Atom editor. It currently is the closest to a fully featured julia IDE.\nSublime, VS Code, Emacs and many other editors all have julia extensions that add various levels of support for the julia language.","category":"page"},{"location":"installation/#Getting-started-1","page":"Installation Guide","title":"Getting started","text":"","category":"section"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"The best way to get started with Mimi is to work through the Tutorials. ","category":"page"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"The Mimi github repository also has links to various models that are based on Mimi, and looking through their code can be instructive.","category":"page"},{"location":"installation/#","page":"Installation Guide","title":"Installation Guide","text":"Finally, when in doubt, ask your question in the Mimi Framework forum or post an Issue to the Github repository if you have a specific request for the development team.   Don't be shy about either option, we would much prefer to be inundated with lots of questions and help people out than people give up on Mimi!","category":"page"},{"location":"internals/proposals/#Not-Implemented-(Yet)-1","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"This section describes proposed API and file formats that haven't been developed yet.","category":"page"},{"location":"internals/proposals/#ModelRunner-1","page":"Not Implemented (Yet)","title":"ModelRunner","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"There are several types of analyses that require an ensemble of model runs performed over a set of parameter values. These include traditional Monte Carlo simulation, in which random values are drawn from distributions and applied to model parameters, as well as global sensitivity analyses that use prescribed methods for defining trial data (e.g., Sobol sampling), and Markov Chain Monte Carlo, which computes new trial data based on prior model results.","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"The abstract type ModelRunner will be used to define a generic API for model runners, including support for parallelization of analyses on multiprocessors and cluster computing systems. The specific sampling and analysis methods required for each subtype of ModelRunner will be defined in the concrete subtype, e.g., SimulationRunner.","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"The generic process will look something like this:","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"m = ModelDef(...)\nr = SimRunner(m)\n\n# Optionally redefine random variables, overriding defaults\nsetrv!(r, :rvname1, Normal(10, 3))\n\n# Optionally assign an alternative RV or distribution to a model parameter\nsetparam!(r, :comp1, :param1, :rvname1)\nsetparam!(r, :comp1, :param2, Uniform(0, 3))\n\n# Adjust what should be saved per model run\n@add_results(r, param10, param11[US])\n@drop_results(r, param1, param1)\n\n# Run trials 1-5000. Also can specify as a range (e.g., 5001:10000) \n# or vector of trial numbers.\nrun!(r, 5000)\n\n# Save results to the indicated directory\nwrite(r, dirname)","category":"page"},{"location":"internals/proposals/#Saving-ensemble-results-1","page":"Not Implemented (Yet)","title":"Saving ensemble results","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"Ensemble results will be stored in an object of type EnsembleResult, which is used by all subtypes of ModelRunner. By default, only model outputs tagged for output will be saved in the EnsembleResult instance. Parameters can be identified as \"output\" parameters in @defsim, and/or directly in a concrete subtype of ModelRunner, in which case default values set in @defsim can be overridden.","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"The method write(r::ModelRunner, dirname::String) will save model results to set of CSV files in the named directory. Initially, we will store the data in tidy format in which variables are in columns and each row represents an observation. This format is verbose but flexible and commonly used by consumers of data such as plotting packages. Other formats can be generated if the need arises.","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"In the initial implementation, results will be saved as follows:","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"Scalar model results will be written to \"$dirname/scalars.csv\". The file will have a column holding the trial number, and one column labeled with each parameter name. Each row in the file will contain all scalar parameter values data for a single  model run. \nExample:\ntrialnum foo bar baz ...\n1 1.6 0.4 110 ...\nAlternatively, we could flatten to 3 columns: \ntrialnum paramname value\n1 foo 1.6\n1 bar 0.4\n1 baz 110\nAll model results with a single time dimension will be written to \"$dirname/timeseries.csv\", with columns:\ntrialnum year foo bar baz ...\n1 2010 100.6 41.6 9.1 ...\n1 2015 101.7 44.5 10.2 ...\n1 2020 102.8 50.1 12.4 ...\n... ... ... ... ... ...\n2 2010 101.6 43.7 10.4 ...\n2 2015 102.4 60.1 21.3 ...\n2 2020 105.7 55.3 14.2 ...\n... ... ... ... ... ...\nAs with scalar results, this might be flattened further to:\ntrialnum paramname year value\n1 foo 2010 100.6\n1 foo 2015 101.7\n1 foo 2020 102.8\n... ... ... ...\n2 foo 2010 101.6\n2 foo 2015 102.4\n2 foo 2020 105.7\n... ... ... ...\nAnother alternative would be to store each timeseries result to its own CSV file, in which case the second (flattened) format would be used, minus the \"paramname\" column, which would be implicit from the filename. This would be more consistent with the matrix format below, since a timeseries result is just a matrix result with only one dimension.\nMatrix results will be saved to individual files named \"$dirname/$paramname.csv\". Matrices will be flattened so that each dimension appears as a column. For example, a matrix with dimensions \"time\" and \"region\" will have columns \"trialnum\", \ntrialnum region year value\n1 US 2010 1.1\n1 US 2015 1.9\n...   \n1 CHI 2010 0.2\n1 CHI 2015 0.8\n...   \nAnother option for saving ensemble outputs might include writing to any \"sink\" type that accepts named tuples.","category":"page"},{"location":"internals/proposals/#Model-result-file-format-1","page":"Not Implemented (Yet)","title":"Model result file format","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"To facilitate post-processing, model results will be saved to files in either JSON formats, as detailed below. To save results, the following methods can be used.","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"For individual model runs, results can be saved to a single file, or added to an existing file. For SA simulations, a single JSON file will hold the subset  of results specified by the user, for each trial. This may become unwieldy, but we support gzipped JSON, which helps a bit: if a filename ends in  .gz, it will automatically be zipped on writing and gzipped on reading.","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"saveresults(m::Model, pathname::String)\n\nsaveresults(m::Model, pathname::String, append=true)\n\nsaveresults(sim:Simulation, pathname::String)","category":"page"},{"location":"internals/proposals/#JSON-file-format-1","page":"Not Implemented (Yet)","title":"JSON file format","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"The JSON file format is basically a set of nested dictionaries, with a few lists at the innermost levels. We assign names to these levels for clarity of exposition in this documentation, but these names do not exist in the actual files.","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"We specify dicttype=DataStructures.OrderedDict when reading and writing JSON files to ensure that insertion order is maintained.","category":"page"},{"location":"internals/proposals/#Scenario-dict-1","page":"Not Implemented (Yet)","title":"Scenario dict","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"The top level of the JSON file is a dictionary keyed by scenario name (for non-SA results) or trial number (basically a numeric scenario name) for SA results.","category":"page"},{"location":"internals/proposals/#Index-Variable-Parameter-(IVP)-dict-1","page":"Not Implemented (Yet)","title":"Index-Variable-Parameter (IVP) dict","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"The value of the top-level dictionary is a dictionary whose keys are types of model inputs and results, which is currently one of \"Index\", \"Variable\", or \"Parameter\" of these dictionaries vary by the type of object stored, as shown below.","category":"page"},{"location":"internals/proposals/#Index-dict-1","page":"Not Implemented (Yet)","title":"Index dict","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"An index dict is keyed by index name (e.g., \"time\", \"region\") with values being lists of index values. For example the \"time\" index might look like this:","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"\"time\" : [2010, 2011, 2012, 2013, ..., 2099, 2100]","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"These are converted to Index objects upon reading.","category":"page"},{"location":"internals/proposals/#Variable-dict-1","page":"Not Implemented (Yet)","title":"Variable dict","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"Variable dicts are keyed by a string of the form \"$component_name:$variable_name\" (tuple keys are not supported in JSON). Values are single numerical values for scalar parameters, or for vector and matrix values, a list of lists of the form [[dimensions...], [values...]] where dimensions. Examples:","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"{\n # Scalar\n \"foo\" : 42,\n\n # one dimension\n \"bar\" : [[\"region\"], [4.1, 7.2, 3.6, 9.4, 5.5, 7.6, ...],\n\n # two dimensions are stored as arrays of arrays\n \"baz\" : [\n   [\"time\", \"region\"], \n   [[4.1, 7.2, 3.6, ...], # values by region for first timestep\n    [3.5, 6.3, 5.6, ...], # values by region for 2nd timestep\n    ...]\n  ]\n}","category":"page"},{"location":"internals/proposals/#Parameter-dict-1","page":"Not Implemented (Yet)","title":"Parameter dict","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"Parameter dicts are keyed by \"external\" names (symbols), with values represented in the same format as shown above for Variable dicts.","category":"page"},{"location":"internals/montecarlo/#Sensitivity-Analysis-support-1","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"","category":"section"},{"location":"internals/montecarlo/#Overview-1","page":"Sensitivity Analysis support","title":"Overview","text":"","category":"section"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"Sensitivity Analysis support consists of the following primary user-facing elements:","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"The @defsim macro, which defines random variables (RVs) which are assigned distributions and associated with model parameters, and override the default (random) sampling method.\nThe run function, which runs a simulation instance, setting the model(s) on which a simulation definition can be run with set_models!, generates all trial data with generate_trials!, and has several with optional parameters and optional callback functions to customize simulation behavior. ","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"These are described further below. We will refer separately to two types, SimulationDef and SimulationInstance.  They are referred to as sim_def and sim_inst respectively as function arguments, and sd and si respectively as local variables.","category":"page"},{"location":"internals/montecarlo/#The-@defsim-macro-1","page":"Sensitivity Analysis support","title":"The @defsim macro","text":"","category":"section"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"Sensitivity Analysis SimulationDefs are defined using the macro @defsim, which does the following:","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"Defines random variables (RV) by assigning names to distributions, which can be any object that supports the following function:\nrand(dist, count::Int=1)\nwhich produces a single value when count == 1, else a Vector of values.\nIf using Latin Hypercube Sampling (LHS) is used, the following function must also be defined:\nquantile(dist, quantiles::Vector{Float64})\nwhich returns values for the given quantiles of the distribution.\nIn addition to the distributions available in the Distributions package, Mimi provides:\nEmpiricalDistribution, which takes a vector of values and (optional) vector of probabilities and produces samples from these values using the given probabilities, if provided, or equal probability otherwise.\nSampleStore{T}, which stores a vector of samples that are produced in order by the rand function. This allows the user to to store a predefined set of values (useful for regression testing) and it is used by the LHS method, which draws all required samples at once at equal probability intervals and then shuffles the values. It is also used when rank correlations are specified, since this requires re-ordering draws from random variables.\nReshapedDistribution, which supports use of vector-valued distributions, i.e., those that generate   vectors of values for each single draw. An example (that motivated this addition) is the Dirichlet distribution, which produces a vector of values that sum to 1. To use this in @defsim, you might do:\n  rd = ReshapedDistribution([5, 5], Dirichlet(25,1))\nThis code creates a pseudo-distribution that, for each draw, produces a 5x5 matrix of values that sum to 1.\nDefines how to apply the values generated by each RV to model parameters based on a pseudo-assignment operator:\nparam = RV replaces the values in the parameter with the value of the RV for the current trial.\nparam += RV replaces the values in the parameter with the sum of the original value and the value of the RV for the current trial.\nparam *= RV replaces the values in the parameter with the product of the original value and the value of the RV for the current trial.\nDefines desired rank correlations between pairs of random variables. Approximate rank correlation is achieved by re-ordering vectors of random draws as per Iman and Conover (1982).","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"The @defsim macro returns a SimulationDef{T} instance, which contains all the definition information in a form that can be applied at run-time. The T in SimulationDef{T} is any type that your application would like to live inside the SimulationDef struct. We have implemented three types for T <: AbstractSimulationData:","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"Simple random-sampling Monte Carlo Simulation (MCSData),\nLatin Hypercube Sampling (LHSData), and\nSobol sampling and analysis (SobolData)","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"We also define type constants with friendlier names for these parameterized types:","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"const MonteCarloSimulationDef = SimulationDef{MCSData}\nconst MonteCarloSimulationInstance = SimulationInstance{MCSData}\n\nconst LatinHypercubeSimulationDef = SimulationDef{LHSData}\nconst LatinHypercubeSimulationInstance = SimulationInstance{LHSData}\n\nconst SobolSimulationDef = SimulationDef{SobolData}\nconst SobolSimulationInstance = SimulationInstance{SobolData}\n","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"Latin Hypercube sampling divides the distribution into equally-spaced quantiles, obtains values at those quantiles, and then shuffles the values. The result is better representation of the tails of the distribution with fewer samples than would be required for purely random sampling. Note that in the current implementation, rank correlation between parameters is supported only for LatinHypercubeSimulationDef.","category":"page"},{"location":"internals/montecarlo/#Assigning-distributions-1","page":"Sensitivity Analysis support","title":"Assigning distributions","text":"","category":"section"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"In @defsim, you can apply distributions to specific slices of array parameters, and you can \"bulk assign\" distributions to elements of a vector or matrix using a more condensed syntax.","category":"page"},{"location":"internals/montecarlo/#Assigning-to-array-slices-1","page":"Sensitivity Analysis support","title":"Assigning to array slices","text":"","category":"section"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"Options for applying distributions to array slices is accomplished using array access syntax on the left-hand side of an assignment. The assignment may use any of these assignment operators: =, *=, or +=, as described above. Slices can be indicated using a variety of specifications. Assume we define two parameters in @defcomp as","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"  foo = Parameter(index=[regions])\n  bar = Parameter(index=[time, regions])","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"with regions defined as [:USA, :CAN, :MEX, :ROW]","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"We can assign distributions to the elements of foo several ways:","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"Using a symbol or string or tuple of symbols or strings. Note that values specified without a \":\" prefix or double quotes are treated as symbols. To specify strings, quote them the usual way.\nfoo[USA] = Uniform(0, 1) would assign the RV to foo[:USA] only.\nfoo[(USA, CAN, MEX)] = Uniform(0, 1) would assign the same RV to 3 elements of foo.  That is, a single value is drawn from the RV with distribution Uniform(0, 1) and this value is assigned to all three elements of foo.\nA :, indicating all elements for this dimension\nfoo[:] = Normal(10.0 3.0) would use a draw from the Normal RV for all elements of foo.\nA : range, with or without a step, or a tuple of integers\nbar[2050:10:2080, :] = Uniform(2, 3) would assign a single Uniform RV to all regions for  time steps with labels 2050, 2060, 2070, and 2080.\nbar[(2050, 2060, 2070, 2080), :] = Uniform(2, 3) does the same thing using a tuple of values.","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"If regions were defined using strings, as in [\"USA\", \"CAN\", \"MEX\", \"ROW\"], the examples above would be written as foo[\"USA\"] = Uniform(0, 1) and so on.","category":"page"},{"location":"internals/montecarlo/#Assigning-a-vector-of-distributions-1","page":"Sensitivity Analysis support","title":"Assigning a vector of distributions","text":"","category":"section"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"In some cases, it's more convenient to assign a vector of distributions (e.g., with different functional forms or parameters) to a single parameter. For example we can use the following syntax:","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"  foo = [USA => Uniform(0, 1),\n         (CAN, MEX) => Uniform(1, 2),\n         ROW => Normal(10, 3)]","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"which is equivalent to:","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"  foo[USA] = Uniform(0, 1),\n  foo[(CAN, MEX)] = Uniform(1, 2),\n  foo[ROW] = Normal(10, 3)]","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"To assign to parameters with more than one dimension, use square brackets around the dimensions on the left-hand side of each => operator, e.g.,","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"  bar = [[2050, USA] => Uniform(0, 1),\n         [:, (CAN, MEX)] => Uniform(1, 2),\n         [2010:10:2080, ROW] => Normal(10, 3)]","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"Currently, the more condensed syntax (using the pair operator =>) supports only direct assignment  of RV value, i.e., you cannot combine this with the *= or += operators.","category":"page"},{"location":"internals/montecarlo/#The-run-function-1","page":"Sensitivity Analysis support","title":"The run function","text":"","category":"section"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"In it's simplest use, the run function generates and iterates over generated trial data, perturbing a chosen subset of Mimi's \"external parameters\", based on the defined distributions, and then runs the given Mimi model(s). The function retuns an instance of SimulationInstance, holding a copy of the original SimulationDef with additional trial information as well as a list of references ot the models and the results. Optionally, trial values and/or model results are saved to CSV files.","category":"page"},{"location":"internals/montecarlo/#Function-signature-1","page":"Sensitivity Analysis support","title":"Function signature","text":"","category":"section"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"The full signature for the run is:","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"function Base.run(sim_def::SimulationDef{T}, models::Union{Vector{Model}, Model}, samplesize::Int;\n                 ntimesteps::Int=typemax(Int), \n                 trials_output_filename::Union{Nothing, AbstractString}=nothing, \n                 results_output_dir::Union{Nothing, AbstractString}=nothing, \n                 pre_trial_func::Union{Nothing, Function}=nothing, \n                 post_trial_func::Union{Nothing, Function}=nothing,\n                 scenario_func::Union{Nothing, Function}=nothing,\n                 scenario_placement::ScenarioLoopPlacement=OUTER,\n                 scenario_args=nothing,\n                 results_in_memory::Bool=true) where T <: AbstractSimulationData","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"Run the simulation definition sim_def for the models using samplesize samples.","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"Optionally run the models for ntimesteps, if specified,  else to the maximum defined time period. Note that trial data are applied to all the  associated models even when running only a portion of them.   ","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"If provided, the generated trials and results will be saved in the indicated  trials_output_filename and results_output_dir respectively. If results_in_memory is set to false, then results will be cleared from memory and only stored in the results_output_dir. After run, the results of a SimulationInstance can be accessed using the getdataframe function with the following signature, which returns a DataFrame. ","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"getdataframe(sim_inst::SimulationInstance, comp_name::Symbol, datum_name::Symbol; model::Int = 1)","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"If pre_trial_func or post_trial_func are defined, the designated functions are called  just before or after (respectively) running a trial. The functions must have the signature:","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"fn(sim_inst::SimulationInstance, trialnum::Int, ntimesteps::Int, tup::Tuple)","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"where tup is a tuple of scenario arguments representing one element in the cross-product of all scenario value vectors. In situations in which you want the simulation loop to run only some of the models, the remainder of the runs can be handled using a pre_trial_func or post_trial_func.","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"If provided, scenario_args must be a Vector{Pair}, where each Pair is a symbol and a  Vector of arbitrary values that will be meaningful to scenario_func, which must have the signature:","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"scenario_func(sim_inst::SimulationInstance, tup::Tuple)","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"By default, the scenario loop encloses the simulation loop, but the scenario loop can be placed inside the simulation loop by specifying scenario_placement=INNER. When INNER  is specified, the scenario_func is called after any pre_trial_func but before the model is run.","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"Returns the type SimulationInstance that contains a copy of the original SimulationDef in addition to trials information (trials, current_trial, and current_data), the model list models, and results information in results.","category":"page"},{"location":"internals/montecarlo/#The-set_models!-function-1","page":"Sensitivity Analysis support","title":"The set_models! function","text":"","category":"section"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"The run function sets the model or models to run using set_models! function and saving references to these in the SimulationInstance instance.  The set_models! function has several methods for associating the model(s) to run with the SimulationDef:","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"set_models!(sim_inst::SimulationInstance, models::Vector{Model})\nset_models!(sim_inst::SimulationInstance, m::Model)\nset_models!(sim_inst::SimulationInstance, mm::MarginalModel)","category":"page"},{"location":"internals/montecarlo/#The-generate_trials!-function-1","page":"Sensitivity Analysis support","title":"The generate_trials! function","text":"","category":"section"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"The generate_trials! function is used to pre-generate data using the given samplesize and save all random variable values in the file filename. Its calling signature is:","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"  generate_trials!(sim_def::SimulationDefinition, samplesize::Int; filename::Union{String, Nothing}=nothing)","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"If the sim_def parameter has multiple scenarios and the scenario_loop placement is set to OUTER, this function must be called if the user wants to ensure the same trial data be used in each scenario. If this function is not called, new trial data will be generated for each scenario. ","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"Also note that if the filename argument is used, all random variable draws are saved to the given filename. Internally, any Distribution instance is converted to a SampleStore and the values are subsequently returned in the order generated when rand! is called.","category":"page"},{"location":"internals/montecarlo/#Non-stochastic-Scenarios-1","page":"Sensitivity Analysis support","title":"Non-stochastic Scenarios","text":"","category":"section"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"In many cases, scenarios (which we define as a choice of values from a discrete set for one or more parameters) need to be considered in addition to the stochastic parameter variation. To support scenarios, run also offers iteration over discrete scenario values, which are passed to run via the keyword parameter scenario_args::Dict{Symbol, Vector}. For example, to iterate over scenario values \"a\", and \"b\", as well as, say, discount rates 0.025, 0.05, 0.07, you could provide the argument:","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"scenario_args=Dict([:name => [\"a\", \"b\"], :rate => [0.025, 0.05, 0.07]])","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"Of course, the SA subsystem does not know what you want to do with these values, so the user must also provide a callback function in the scenario_func argument. This function must be defined with the signature:","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"function any_name_you_like(sim_inst::SimulationInstance, tup)","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"where tup is an element of the set of tuples produced by calling Itertools.product() on all the scenario arguments. In the example above, this would produce the following vector of tuples:","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"[(\"a\", 0.025), (\"b\", 0.025), (\"a\", 0.03), (\"b\", 0.03), (\"a\", 0.05), (\"b\", 0.05)].","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"This approach allows all scenario combinations to be iterated over using a single loop. A final keyword argument, scenario_placement::ScenarioLoopPlacement indicates whether the scenario loop should occur inside or outside the loop over stochastic trial values. The type ScenarioLoopPlacement is an enum with values INNER and OUTER, the latter being the default placement.","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"In approximate pseudo-julia, these options produce the following behavior:","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"scenario_placement=OUTER","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"for tup in scenario_tuples\n  scenario_func(tup)\n\n  # for each scenario, run all SA trials\n  for trial in trials\n    trial_data = get_trial_data(trial)\n    apply_trial_data()\n\n    pre_trial_func()\n    run(model)\n    post_trial_func()\n  end\nend","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"scenario_placement=INNER","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"for trial in trials\n  trial_data = get_trial_data(trial)\n  apply_trial_data()\n\n  # for each SA trial, run all scenarios\n  for tup in scenario_tuples\n    scenario_func(tup)\n\n    pre_trial_func()\n    run(model)\n    post_trial_func()\n  end\nend","category":"page"},{"location":"internals/montecarlo/#Running-Multiple-Models-1","page":"Sensitivity Analysis support","title":"Running Multiple Models","text":"","category":"section"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"In some simulations, a baseline model needs to be compared to one or more models that are perturbed parametrically or structurally (i.e., with different components or equations.) To support this, the SimulationInstance type holds a vector of Model instances, and allows the caller to specify how many of these to run automatically for each trial. Note that regardless of how many models are run, the random variables are applied to all of the models associated with the simulation.","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"By default, all defined models are run. In some cases, you may want to run some of the models \"manually\" in the pre_trial_func or post_trial_func, which allow you to make arbitrary modifications to these additional models.","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"Example","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"The following example is derived from \"Mimi.jl/test/mcs/test_defmcs.jl\".","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"using Mimi\nusing Distributions\n\nN = 100\n\nsd = @defsim begin\n    # Define random variables. The rv() is required to disambiguate an\n    # RV definition name = Dist(args...) from application of a distribution\n    # to an external parameter. This makes the (less common) naming of an\n    # RV slightly more burdensome, but it's only required when defining\n    # correlations or sharing an RV across parameters.\n    rv(name1) = Normal(1, 0.2)\n    rv(name2) = Uniform(0.75, 1.25)\n    rv(name3) = LogNormal(20, 4)\n\n    # assign RVs to model Parameters\n    share = Uniform(0.2, 0.8)\n    sigma[:, Region1] *= name2\n    sigma[2020:5:2050, (Region2, Region3)] *= Uniform(0.8, 1.2)\n\n    depk = [Region1 => Uniform(0.08, 0.14),\n            Region2 => Uniform(0.10, 1.50),\n            Region3 => Uniform(0.10, 0.20)]\n\n    sampling(LHSData, corrlist=[(:name1, :name2, 0.7), (:name1, :name3, 0.5)])\n    \n    # indicate which parameters to save for each model run. Specify\n    # a parameter name or [later] some slice of its data, similar to the\n    # assignment of RVs, above.\n    save(grosseconomy.K, grosseconomy.YGROSS, emissions.E, emissions.E_Global)\nend\n\nMimi.reset_compdefs()\ninclude(\"../../examples/tutorial/02-multi-region-model/main.jl\")\n\nm = model\n\n# Optionally, user functions can be called just before or after a trial is run\nfunction print_result(m::Model, sim_inst::SimulationInstance, trialnum::Int)\n    ci = Mimi.compinstance(m.mi, :emissions)\n    value = Mimi.get_variable_value(ci, :E_Global)\n    println(\"$(ci.comp_id).E_Global: $value\")\nend\n\n# set some some constants\ntrials_output_filename = joinpath(output_dir, \"trialdata.csv\")\nresults_output_dir = joinpath(tempdir(), \"sim\")\nN = 100\n\n# Run trials and save trials results to the indicated directories\nsi = run(sd, m, N; trials_output_filename=trials_output_filename, results_output_dir=results_output_dir)\n\n# take a look at the results\nresults = getdataframe(si, :grosseconomy, :K) # model index chosen defaults to 1","category":"page"},{"location":"internals/montecarlo/#Plotting-and-the-Explorer-UI-1","page":"Sensitivity Analysis support","title":"Plotting and the Explorer UI","text":"","category":"section"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"As described in the User Guide, Mimi provides support for plotting using VegaLite and VegaLite.jl within the Mimi Explorer UI and Mimi.plot function. These functions not only work for Models, but for SimulationInstances as well. ","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"In order to invoke the explorer UI and explore all of the saved variables from the save list of a SimulationInstance, simply call the function explore with the simulation as the required argument as shown below.  This will produce a new browser window containing a selectable list of variables, each of which produces a graphic.","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"run(sim_inst)\nexplore(sim_inst)","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"There are several optional keyword arguments for the explore method, as shown by the full function signature:","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"explore(sim_inst::SimulationInstance; title=\"Electron\", model_index::Int = 1, scen_name::Union{Nothing, String} = nothing, results_output_dir::Union{Nothing, String} = nothing)","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"The title is the optional title of the application window, the model_index defines which model in your list of models passed to run you would like to explore (defaults to 1), and scen_name is the name of the specific scenario you would like to explore if there is a scenario dimension to your simulation.  Note that if there are multiple scenarios, this is a required argument. Finally, if you have saved the results of your simulation to disk and cleared them from memory using run's results_in_memory keyword argument flag set to false, you must provide a results_output_dir which indicates the parent folder for all outputs and potential subdirectories, identical to that passed to run.","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"(Image: Explorer Simulation Example)","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"Alternatively, in order to view just one variable, call the (unexported) function Mimi.plot as below to return a plot object and automatically display the plot in a viewer, assuming Mimi.plot is the last command executed.  Note that plot is not exported in order to avoid namespace conflicts, but a user may import it if desired. This call will return the type VegaLite.VLSpec, which you may interact with using the API described in the VegaLite.jl documentation.  For example, VegaLite.jl plots can be saved in many typical file formats such as  PNG, SVG, PDF and EPS files. You may save a plot using the save function. Note that while explore(sim_inst) returns interactive plots for several graphs, Mimi.plot(si, :foo, :bar) will return only static plots. ","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"using VegaLite\nrun(sim_inst)\np = Mimi.plot(sim_inst, :component1, :parameter1)\nsave(\"figure.svg\", p)","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"Note the function signature below, which has the same keyword arguments and requirements as the aforementioned explore method, save for title.","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"plot(sim_inst::SimulationInstance, comp_name::Symbol, datum_name::Symbol; interactive::Bool = false, model_index::Int = 1, scen_name::Union{Nothing, String} = nothing, results_output_dir::Union{Nothing, String} = nothing)","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"(Image: Plot Simulation Example)","category":"page"},{"location":"internals/montecarlo/#Simulation-Modification-Functions-1","page":"Sensitivity Analysis support","title":"Simulation Modification Functions","text":"","category":"section"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"A small set of unexported functions are available to modify an existing SimulationDefinition.  The functions include:","category":"page"},{"location":"internals/montecarlo/#","page":"Sensitivity Analysis support","title":"Sensitivity Analysis support","text":"delete_RV!\nadd_RV!\nreplace_RV!\ndelete_transform!\nadd_transform!\ndelete_save!\nadd_save!\nset_payload!\npayload","category":"page"},{"location":"tutorials/tutorial_main/#Introduction-1","page":"Tutorials Intro","title":"Introduction","text":"","category":"section"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"The following tutorials target Mimi users of different experience levels, starting with first-time users.  Before engaging with these tutorials, we recommend that users read the Welcome to Mimi documentation, including the User Guide, and refer back to those documents as needed to follow the tutorials.  It will also be helpful to be comfortable with the basics of the Julia language, though expertise is not required.","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"If you find a bug in these tutorials, or have a clarifying question or suggestion, please reach out via Github Issues or our Mimi Framework forum.  We welcome your feedback.","category":"page"},{"location":"tutorials/tutorial_main/#Terminology-1","page":"Tutorials Intro","title":"Terminology","text":"","category":"section"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"The following terminology is used throughout the documentation.","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"Application Programming Interface (API):  The public classes, methods, and functions provided by Mimi to facilitate construction of custom scripts and work with existing models. Function documentation provided in \"docstrings\" in the Reference define the Mimi API in more detail.","category":"page"},{"location":"tutorials/tutorial_main/#Available-Tutorials-1","page":"Tutorials Intro","title":"Available Tutorials","text":"","category":"section"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"Run an Existing Model\nTutorial 1: Run an Existing Model steps through the tasks to download, run, and view the results of a registered model such as FUND.  It should be usable for all users, including first-time users, and is a good place to start when learning to use Mimi.\nModify an Existing Model\nTutorial 2: Modify an Existing Model builds on Tutorial 1, showing how to modify an existing model such as DICE.\nCreate a Model\nTutorial 3: Create a Model takes a step beyond using registered models, explaining how to create a model from scratch.\nSensitivity Analysis\nTutorial 4: Sensitivity Analysis (SA) Support explores Mimi's Sensitivity Analysis support, using both the simple multi-Region tutorial model and MimiDICE2010 examples.","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"Additional AERE Workshop Tutorials: The Mimi developement team recently participated in the 2019 Association of Environmental and Resource Economists (AERE) summer conference during the pre-conference workshop on Advances in Integrated Assessment Models. This included both a presentation and a hands-on session demonstrating various use cases for Mimi. The Github repository here contains a) all slides from the workshop and b) all the code from the hands on sessions, which may be of interest to Mimi users. Importantly note that the linked code represents as a snapshot of Mimi at the time of the workshop, and will not be updated to reflect new changes.","category":"page"},{"location":"tutorials/tutorial_main/#Requirements-and-Initial-Setup-1","page":"Tutorials Intro","title":"Requirements and Initial Setup","text":"","category":"section"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"These tutorials require Julia v1.2.0 and Mimi v0.9.0, or later. ","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"To use the following tutorials, follow the steps below.","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"Download the latest version of Julia here, making sure that your downloaded version is v1.1.0 or later.\nOpen a Julia REPL, and enter ] to enter the Pkg REPL mode, and then type add Mimi to install the latest tagged version of Mimi, which must be version 0.9.4 or later.","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"pkg> add Mimi","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"To access the models in the MimiRegistry, you first need to connect your julia installation with the central Mimi registry of Mimi models. This central registry is like a catalogue of models that use Mimi that is maintained by the Mimi project. To add this registry, run the following command at the julia package REPL:","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"pkg> registry add https://github.com/mimiframework/MimiRegistry.git","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"You only need to run this command once on a computer. ","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"From there you will be add any of the registered packages, such as MimiDICE2010.jl by running the following command at the julia package REPL:","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"pkg> add MimiDICE2010","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"We also recommend that you frequently update your packages and requirements using the update command, which can be abbreviated up:","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"pkg> up","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"You are now ready to begin the tutorials!","category":"page"},{"location":"tutorials/tutorial_2/#Tutorial-2:-Modify-an-Existing-Model-1","page":"2 Modify an Existing Model","title":"Tutorial 2: Modify an Existing Model","text":"","category":"section"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"This tutorial walks through the steps to modify an existing model.  There are several existing models publically available on the MimiRegistry, and for the purposes of this tutorial we will use the MimiDICE2010 model.","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"Working through the following tutorial will require:","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"Julia v1.2.0 or higher\nMimi v0.9.4 ","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"If you have not yet prepared these, go back to the main tutorial page and follow the instructions for their download. ","category":"page"},{"location":"tutorials/tutorial_2/#Introduction-1","page":"2 Modify an Existing Model","title":"Introduction","text":"","category":"section"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"There are various ways to modify an existing model, and this tutorial aims to introduce the Mimi API relevant to this broad category of tasks.  It is important to note that regardless of the goals and complexities of your modifications, the API aims to allow for modification without alteration of the original code for the model being modified.  Instead, you will download and run the existing model, and then use API calls to modify it. This means that in practice, you should not need to alter the source code of the model you are modifying. Thus, it is easy to keep up with any external updates or improvements made to that model.","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"Possible modifications range in complexity, from simply altering parameter values, to adjusting an existing component, to adding a brand new component. These take advantage of the public API listed here, as well as other functions listed in the Mimi Documentation.","category":"page"},{"location":"tutorials/tutorial_2/#Parametric-Modifications:-The-API-1","page":"2 Modify an Existing Model","title":"Parametric Modifications: The API","text":"","category":"section"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"Several types of changes to models revolve around the parameters themselves, and may include updating the values of parameters and changing parameter connections without altering the elements of the components themselves or changing the general component structure of the model.  The most useful functions of the common API in these cases are likely update_param!/update_params!, disconnect_param!, and connect_param!.  For detail on these functions see the API reference here.","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"When the original model calls set_param!, Mimi creates an external parameter by the name provided, and stores the provided scalar or array value. The functions update_param! and update_params! allow you to change the value associated with this external parameter.  Note that if the external parameter has a :time dimension, use the optional argument update_timesteps=true to indicate that the time keys (i.e., year labels) associated with the parameter should be updated in addition to updating the parameter values.","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"update_param!(mymodel, :parametername, newvalues) # update values only \n\nupdate_param!(mymodel, :parametername, newvalues, update_timesteps=true) # also update time keys. Only necessary if the time dimension of the model has been changed.","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"Also note that in the code above, newvalues must be the same size and type (or be able to convert to the type) of the old values stored in that parameter.","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"If you wish to alter connections within an existing model, disconnect_param! and connect_param! can be used in conjunction with each other to update the connections within the model, although this is more likely to be done as part of larger changes involving components themslves, as discussed in the next subsection.","category":"page"},{"location":"tutorials/tutorial_2/#Parametric-Modifications:-DICE-Example-1","page":"2 Modify an Existing Model","title":"Parametric Modifications: DICE Example","text":"","category":"section"},{"location":"tutorials/tutorial_2/#Step-1.-Download-MimiDICE2010-1","page":"2 Modify an Existing Model","title":"Step 1. Download MimiDICE2010","text":"","category":"section"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"The first step in this process is downloading the DICE2010 model, which is now made easy with the Mimi registry. Assuming you have already done the one-time run of the following to connect your julia installation with the central Mimi registry of Mimi models:","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"pkg> registry add https://github.com/mimiframework/MimiRegistry.git","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"You simply need to add the MimiDICE2010 model in the Pkg REPL with:","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"pkg> add MimiDICE2010","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"You have now successfully downloaded MimiDICE2010 to your local machine.","category":"page"},{"location":"tutorials/tutorial_2/#Step-2.-Run-DICE-1","page":"2 Modify an Existing Model","title":"Step 2. Run DICE","text":"","category":"section"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"The next step is to run DICE using the provided API for the package:","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"using MimiDICE2010\nm = MimiDICE2010.get_model()\nrun(m)","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"Note that these steps should be relatively consistent across models, where a repository for ModelX should contain a primary file ModelX.jl which exports, at minimum, a function named something like get_model or construct_model which returns a version of the model, and can allow for model customization within the call.","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"In this case, the function MimiDICE2010.get_model() has the signature","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"get_model(params=nothing)","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"Thus there are no required arguments, although the user can input params, a dictionary definining the parameters of the model. If nothing is provided, the model will be built with the default parameters for DICE2010.","category":"page"},{"location":"tutorials/tutorial_2/#Step-3.-Altering-Parameters-1","page":"2 Modify an Existing Model","title":"Step 3. Altering Parameters","text":"","category":"section"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"In the case that you wish to alter an exogenous parameter, you may use the update_param! function.  Per usual, you will start by importing the Mimi package to your space with ","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"using Mimi","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"For example, in DICE the parameter fco22x is the forcings of equilibrium CO2 doubling in watts per square meter, and exists in the components climatedynamics and radiativeforcing.  If you wanted to change this value from its default value of 3.200 to 3.000 in both components,you would use the following code:","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"update_param!(m, :fco22x, 3.000)\nrun(m)","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"A more complex example may a situation where you want to update several parameters, including some with a :time dimension, in conjunction with altering the time index of the model itself. DICE uses a default time horizon of 2005 to 2595 with 10 year increment timesteps.  If you wish to change this, say, to 2000 to 2500 by 10 year increment timesteps and use parameters that match this time, you could use the following code:","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"First you upate the time dimension of the model as follows:","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"const ts = 10\nconst years = collect(2000:ts:2500)\nnyears = length(years)\nset_dimension!(m, :time, years)","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"Next, create a dictionary params with one entry (k, v) per external parameter by name k to value v. Each key k must be a symbol or convert to a symbol matching the name of an external parameter that already exists in the model definition.  Part of this dictionary may look like:","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"params = Dict{Any, Any}()\nparams[:a1]         = 0.00008162\nparams[:a2]         = 0.00204626\n...\nparams[:S]          = repeat([0.23], nyears)\n...","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"Now you simply update the parameters listen in params and re-run the model with","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"update_params!(m, params, update_timesteps=true)\nrun(m)","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"Note that here we use the update_timesteps flag and set it to true, because since we have changed the time index we want the time labels on the parameters to change, not simply their values.","category":"page"},{"location":"tutorials/tutorial_2/#Component-and-Structural-Modifications:-The-API-1","page":"2 Modify an Existing Model","title":"Component and Structural Modifications: The API","text":"","category":"section"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"Most model modifications will include not only parametric updates, but also strutural changes and component modification, addition, replacement, and deletion along with the required re-wiring of parameters etc. The most useful functions of the common API, in these cases are likely replace_comp!, add_comp! along with Mimi.delete! and the requisite functions for parameter setting and connecting.  For detail on the public API functions look at the API reference here. ","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"If you wish to modify the component structure we recommend you also look into the built-in helper components adder, ConnectorCompVector, and ConnectorCompMatrix in the src/components folder, as these can prove quite useful.  ","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"adder.jl  Defines Mimi.adder, which simply adds two parameters, input and add and stores the result in output.\nconnector.jl  Defines a pair of components, Mimi.ConnectorCompVector and Mimi.ConnectorCompMatrix. These copy the value of parameter input1, if available, to the variable output, otherwise the value of parameter input2 is used. It is an error if neither has a value.","category":"page"},{"location":"tutorials/tutorial_2/#Component-and-Structural-Modifications:-DICE-Example-1","page":"2 Modify an Existing Model","title":"Component and Structural Modifications: DICE Example","text":"","category":"section"},{"location":"tutorials/tutorial_2/#","page":"2 Modify an Existing Model","title":"2 Modify an Existing Model","text":"This example is in progress and will be built out soon.","category":"page"},{"location":"faq/#Frequently-asked-questions-1","page":"FAQ","title":"Frequently asked questions","text":"","category":"section"},{"location":"faq/#What's-up-with-the-name?-1","page":"FAQ","title":"What's up with the name?","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"The name is probably an acronym for \"Modular Integrated Modeling Interface\", but we are not sure. What is certain is that it came up during a dinner that Bob, David and Sol had in 2015. David thinks that Bob invented the name, Bob doesn't remember and Sol thinks the waiter might have come up with it (although we can almost certainly rule that option out). It certainly is better than the previous name \"IAMF\". We now use \"Mimi\" purely as a name of the package, not as an acronym.","category":"page"},{"location":"faq/#How-do-I-use-component-references?-1","page":"FAQ","title":"How do I use component references?","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"Component references allow you to write cleaner model code when connecting components.  The add_comp! function returns a reference to the component that you just added:","category":"page"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"using Mimi\n\n# create a component\n@defcomp MyComp begin\n    # empty\nend\n\n# construct a model and add the component\nm = Model()\nset_dimension!(m, :time, collect(2015:5:2110))\nadd_comp!(m, MyComp)\ntypeof(MyComp) # note the type is a Mimi Component Definition","category":"page"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"If you want to get a reference to a component after the add_comp! call has been made, you can construct the reference as:","category":"page"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"mycomponent = Mimi.ComponentReference(m, :MyComp)\ntypeof(mycomponent) # note the type is a Mimi Component Reference","category":"page"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"You can use this component reference in place of the set_param! and connect_param! calls.","category":"page"},{"location":"faq/#References-in-place-of-set_param!-1","page":"FAQ","title":"References in place of set_param!","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"The line set_param!(model, :MyComponent, :myparameter, myvalue) can be written as mycomponent[:myparameter] = myvalue, where mycomponent is a component reference.","category":"page"},{"location":"faq/#References-in-place-of-connect_param!-1","page":"FAQ","title":"References in place of connect_param!","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"The line connect_param!(model, :MyComponent, :myparameter, :YourComponent, :yourparameter) can be written as mycomponent[:myparameter] = yourcomponent[:yourparameter], where mycomponent and yourcomponent are component references.","category":"page"},{"location":"tutorials/tutorial_4/#Tutorial-4:-Sensitivity-Analysis-(SA)-Support-1","page":"4 Sensitivity Analysis","title":"Tutorial 4: Sensitivity Analysis (SA) Support","text":"","category":"section"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"This tutorial walks through the sensitivity analysis (SA) functionality of Mimi, including core routines and examples.  We will start with looking at using the SA routines with the multi-region Mimi model built in the second half of Tutorial 3, which is also available in the Mimi repository at examples/tutorial/02-multi-region-model. Then we will show some more advanced features using a real Integrated Assessment model, MimiDICE2010.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"Working through the following tutorial will require:","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"Julia v1.2.0 or higher\nMimi v0.9.4 ","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"If you have not yet prepared these, go back to the main tutorial page and follow the instructions for their download.  ","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"Futhermore, if you are not yet comfortable with downloading (only needs to be done once) and running MimiDICE2010, refer to Tutorial 1 for instructions.  Carry out Steps 1 and 2 from Tutorial 1 for the MimiDICE2010 package and then return to continue with this tutorial. Note that MimiDICE2010 is only required for the second example in this tutorial. ","category":"page"},{"location":"tutorials/tutorial_4/#The-API-1","page":"4 Sensitivity Analysis","title":"The API","text":"","category":"section"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"The best current documentation on the SA API is the internals documentation here, which provides a working and informal description of the Sensitivity Analysis support of Mimi. This file should be used in conjunction with the examples below for details, since the documentation covers more advanced options such as non-stochastic scenarios and running multiple models, which are not yet included in this tutorial.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"We will refer separately to two types, SimulationDef and SimulationInstance.  They are referred to as sim_def and sim_inst respectively as function arguments, and sd and si respectively as local variables.","category":"page"},{"location":"tutorials/tutorial_4/#Multi-Region-Model-Example-1","page":"4 Sensitivity Analysis","title":"Multi-Region Model Example","text":"","category":"section"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"This section will walk through a simple example of how to define a simulation, run the simulation for a given model, and access the outputs.","category":"page"},{"location":"tutorials/tutorial_4/#Step-1.-Setup-1","page":"4 Sensitivity Analysis","title":"Step 1. Setup","text":"","category":"section"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"You should have Mimi installed by now, and if you do not have the Distributions package, take a moment to add that package by entering ] to enter the Pkg REPL mode and then typing add Distributions.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"As a reminder, the following code is the multi-region model that was constructed in the second half of tutorial 3. You can either load the MyModel module from tutorial 3, or run the following code which defines the same construct_Mymodel function that we will use.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"using Mimi \n\n# Define the grosseconomy component\n@defcomp grosseconomy begin\n    regions = Index()                           #Note that a regional index is defined here\n\n    YGROSS  = Variable(index=[time, regions])   #Gross output\n    K       = Variable(index=[time, regions])   #Capital\n    l       = Parameter(index=[time, regions])  #Labor\n    tfp     = Parameter(index=[time, regions])  #Total factor productivity\n    s       = Parameter(index=[time, regions])  #Savings rate\n    depk    = Parameter(index=[regions])        #Depreciation rate on capital - Note that it only has a region index\n    k0      = Parameter(index=[regions])        #Initial level of capital\n    share   = Parameter()                       #Capital share\n\n    function run_timestep(p, v, d, t)\n    # Note that the regional dimension is defined in d and parameters and variables are indexed by 'r'\n\n        # Define an equation for K\n        for r in d.regions\n            if is_first(t)\n                v.K[t,r] = p.k0[r]\n            else\n                v.K[t,r] = (1 - p.depk[r])^5 * v.K[t-1,r] + v.YGROSS[t-1,r] * p.s[t-1,r] * 5\n            end\n        end\n\n        # Define an equation for YGROSS\n        for r in d.regions\n            v.YGROSS[t,r] = p.tfp[t,r] * v.K[t,r]^p.share * p.l[t,r]^(1-p.share)\n        end\n    end\nend\n\n# define the emissions component\n@defcomp emissions begin\n    regions     = Index()                           # The regions index must be specified for each component\n\n    E           = Variable(index=[time, regions])   # Total greenhouse gas emissions\n    E_Global    = Variable(index=[time])            # Global emissions (sum of regional emissions)\n    sigma       = Parameter(index=[time, regions])  # Emissions output ratio\n    YGROSS      = Parameter(index=[time, regions])  # Gross output - Note that YGROSS is now a parameter\n\n    # function init(p, v, d)\n    # end\n    \n    function run_timestep(p, v, d, t)\n        # Define an equation for E\n        for r in d.regions\n            v.E[t,r] = p.YGROSS[t,r] * p.sigma[t,r]\n        end\n\n        # Define an equation for E_Global\n        for r in d.regions\n            v.E_Global[t] = sum(v.E[t,:])\n        end\n    end\n\nend\n\n# Define values for input parameters to be used when constructing the model\n\nl = Array{Float64}(undef, 20, 3)\nfor t in 1:20\n    l[t,1] = (1. + 0.015)^t *2000\n    l[t,2] = (1. + 0.02)^t * 1250\n    l[t,3] = (1. + 0.03)^t * 1700\nend\n\ntfp = Array{Float64}(undef, 20, 3)\nfor t in 1:20\n    tfp[t,1] = (1 + 0.06)^t * 3.2\n    tfp[t,2] = (1 + 0.03)^t * 1.8\n    tfp[t,3] = (1 + 0.05)^t * 2.5\nend\n\ns = Array{Float64}(undef, 20, 3)\nfor t in 1:20\n    s[t,1] = 0.21\n    s[t,2] = 0.15\n    s[t,3] = 0.28\nend\n\ndepk = [0.11, 0.135 ,0.15]\nk0   = [50.5, 22., 33.5]\n\nsigma = Array{Float64}(undef, 20, 3)\nfor t in 1:20\n    sigma[t,1] = (1. - 0.05)^t * 0.58\n    sigma[t,2] = (1. - 0.04)^t * 0.5\n    sigma[t,3] = (1. - 0.045)^t * 0.6\nend\n\n# Define a function for building the model\n\nfunction construct_MyModel()\n\n\tm = Model()\n\n\tset_dimension!(m, :time, collect(2015:5:2110))\n\tset_dimension!(m, :regions, [:Region1, :Region2, :Region3])\t # Note that the regions of your model must be specified here\n\n\tadd_comp!(m, grosseconomy)\n\tadd_comp!(m, emissions)\n\n\tset_param!(m, :grosseconomy, :l, l)\n\tset_param!(m, :grosseconomy, :tfp, tfp)\n\tset_param!(m, :grosseconomy, :s, s)\n\tset_param!(m, :grosseconomy, :depk,depk)\n\tset_param!(m, :grosseconomy, :k0, k0)\n\tset_param!(m, :grosseconomy, :share, 0.3)\n\n\t# set parameters for emissions component\n\tset_param!(m, :emissions, :sigma, sigma)\n\tconnect_param!(m, :emissions, :YGROSS, :grosseconomy, :YGROSS)\n\n    return m\nend","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"Then, we obtain a copy of the model:","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"m = construct_MyModel()","category":"page"},{"location":"tutorials/tutorial_4/#Step-2.-Define-Random-Variables-1","page":"4 Sensitivity Analysis","title":"Step 2. Define Random Variables","text":"","category":"section"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"The @defsim macro is the first step in the process, and returns a SimulationDef. The following syntax allows users to define random variables (RVs) as distributions,  and associate model parameters with the defined random variables.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"There are two ways of assigning random variables to model parameters in the @defsim macro. Notice that both of the following syntaxes are used in the following example.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"The first is the following:","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"rv(rv1) = Normal(0, 0.8)    # create a random variable called \"rv1\" with the specified distribution\nparam1 = rv1                # then assign this random variable \"rv1\" to the parameter \"param1\" in the model","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"The second is a shortcut, in which you can directly assign the distribution on the right-hand side to the name of the model parameter on the left hand side. With this syntax, a random variable is created under the hood and then assigned to param1.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"param1 = Normal(0, 0.8)","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"The @defsim macro also selects the sampling method. Simple random sampling (also called Monte Carlo sampling) is the default.  Other options include Latin Hypercube sampling and Sobol sampling.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"using Mimi\nusing Distributions \n\nsd = @defsim begin\n    # Define random variables. The rv() is only required when defining correlations \n    # or sharing an RV across parameters. Otherwise, you can use the shortcut syntax\n    # to assign a distribution to a parameter name.\n    rv(name1) = Normal(1, 0.2)\n    rv(name2) = Uniform(0.75, 1.25)\n    rv(name3) = LogNormal(20, 4)\n\n    # If using LHS, you can define correlations like this:\n    sampling(LHSData, corrlist=[(:name1, :name2, 0.7), (:name1, :name3, 0.5)])\n\n    # Exclude the sampling() call, or use the following for simple random sampling:\n    # sampling(MCSData)\n\n    # For Sobol sampling, specify N, and calc_second_order, which defaults to false.\n    # sampling(SobolData, N=10000, calc_second_order=true)\n\n    # assign RVs to model Parameters\n    share = Uniform(0.2, 0.8)\n    sigma[:, Region1] *= name2\n    sigma[2020:5:2050, (Region2, Region3)] *= Uniform(0.8, 1.2)\n\n    # For parameters that have a region dimension, you can assign an array of distributions, \n    # keyed by region label, which must match the region labels in the model\n    depk = [Region1 => Uniform(0.7, .9),\n            Region2 => Uniform(0.8, 1.),\n            Region3 => Truncated(Normal(), 0, 1)]\n\n    # Indicate which variables to save for each model run.\n    # The syntax is: component_name.variable_name\n    save(grosseconomy.K, grosseconomy.YGROSS, \n         emissions.E, emissions.E_Global)\nend","category":"page"},{"location":"tutorials/tutorial_4/#Step-3.-Run-Simulation-1","page":"4 Sensitivity Analysis","title":"Step 3. Run Simulation","text":"","category":"section"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"Next, use the run function to run the simulation for the specified simulation definition, model (or list of models), and number of trials. View the internals documentation here for critical and useful details on the full signature of the run function.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"In its simplest use, the run function generates and iterates over a sample of trial data from the distributions of the random variables defined in the SimulationDef, perturbing the subset of Mimi's \"external parameters\" that have been assigned random variables, and then runs the given Mimi model(s) for each set of trial data. The function returns a SimulationInstance, which holds a copy of the original SimulationDef in addition to trials information (trials, current_trial, and current_data), the model list models, and results information in results. Optionally, trial values and/or model results are saved to CSV files. Note that if there is concern about in-memory storage space for the results, use the results_in_memory flag set to false to incrementally clear the results from memory. ","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"# Run 100 trials, and optionally save results to the indicated directories\nsi = run(sd, m, 100; trials_output_filename = \"/tmp/trialdata.csv\", results_output_dir=\"/tmp/tutorial4\")\n\n# Explore the results saved in-memory by using getdataframe with the returned SimulationInstance.\n# Values are saved from each trial for each variable or parameter specified by the call to \"save()\" at the end of the @defsim block.\nK_results = getdataframe(si, :grosseconomy, :K)\nE_results = getdataframe(si, :emissions, :E)","category":"page"},{"location":"tutorials/tutorial_4/#Step-4.-Explore-and-Plot-Results-1","page":"4 Sensitivity Analysis","title":"Step 4. Explore and Plot Results","text":"","category":"section"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"As described in the internals documentation here, Mimi provides both explore and Mimi.plot to explore the results of both a run Model and a run SimulationInstance. ","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"To view your results in an interactive application viewer, simply call:","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"explore(si)","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"If desired, you may also include a title for your application window. If more than one model was run in your Simulation, indicate which model you would like to explore with the model keyword argument, which defaults to 1. Finally, if your model leverages different scenarios, you must indicate the scenario_name.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"explore(si; title = \"MyWindow\", model_index = 1) # we do not indicate scen_name here since we have no scenarios","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"To view the results for one of the saved variables from the save command in @defsim, use the (unexported to avoid namespace collisions) Mimi.plot function.  This function has the same keyword arguments and requirements as explore (except for title), and three required arguments: the SimulationInstance, the component name (as a Symbol), and the variable name (as a Symbol).","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"Mimi.plot(si, :grosseconomy, :K)","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"To save your figure, use the save function to save typical file formats such as PNG, SVG, PDF and EPS files. Note that while explore(sim_inst) returns interactive plots for several graphs, Mimi.plot(si, :foo, :bar) will return only static plots. ","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"p = Mimi.plot(si, :grosseconomy, :K)\nsave(\"MyFigure.png\", p)","category":"page"},{"location":"tutorials/tutorial_4/#Advanced-Features-Social-Cost-of-Carbon-(SCC)-Example-1","page":"4 Sensitivity Analysis","title":"Advanced Features - Social Cost of Carbon (SCC) Example","text":"","category":"section"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"This example will discuss the more advanced SA capabilities of post-trial functions and payload objects.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"Case: We want to do an SCC calculation with MimiDICE2010, which consists of running both a base and marginal model (the latter being a model including an additional emissions pulse, see the create_marginal_model function or create your own two models). We then take the difference between the consumption level in these two models and obtain the discounted net present value to get the SCC.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"The beginning steps for this case are identical to those above. We first define the typical variables for a simulation, including the number of trials N and the simulation definition sd.  In this case we only define one random variable, t2xco2, but note there could be any number of random variables defined here.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"using Mimi\nusing MimiDICE2010\nusing Distributions\n\n# define the number of trials\nN = 100\n\n# define your simulation (defaults to Monte Carlo sampling)\nsd = @defsim begin\n    t2xco2 = Truncated(Gamma(6.47815626,0.547629469), 1.0, Inf) # a dummy distribution\nend","category":"page"},{"location":"tutorials/tutorial_4/#Payload-object-1","page":"4 Sensitivity Analysis","title":"Payload object","text":"","category":"section"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"Simulation definitions can hold a user-defined payload object which is not used or modified by Mimi. In this example, we will use the payload to hold an array of pre-computed discount factors that we will use in the SCC calculation, as well as a storage array for saving the SCC values.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"# Choose what year to calculate the SCC for\nscc_year = 2015\nyear_idx = findfirst(isequal(scc_year), MimiDICE2010.model_years)\n\n# Pre-compute the discount factors for each discount rate\ndiscount_rates = [0.03, 0.05, 0.07]\nnyears = length(MimiDICE2010.model_years)\ndiscount_factors = [[zeros(year_idx - 1)... [(1/(1 + r))^((t-year_idx)*10) for t in year_idx:nyears]...] for r in discount_rates] \n\n# Create an array to store the computed SCC in each trial for each discount rate\nscc_results = zeros(N, length(discount_rates))  \n\n# Set the payload object in the simulation definition\nmy_payload_object = (discount_factors, scc_results) # In this case, the payload object is a tuple which holds both both arrays\nMimi.set_payload!(sd, my_payload_object)","category":"page"},{"location":"tutorials/tutorial_4/#Post-trial-function-1","page":"4 Sensitivity Analysis","title":"Post-trial function","text":"","category":"section"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"In the simple multi-region simulation example, the only values that were saved during each trial of the simulation were values of variables calculated internally by the model. Sometimes, a user may need to perform other calculations before or after each trial is run. For example, the SCC is calculated using two models, so this calculation needs to happen in a post-trial function, as shown below.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"Here we define a post_trial_function called my_scc_calculation which will calculate the SCC for each trial of the simulation. Notice that this function retrieves and uses the payload object that was previously stored in the SimulationDef.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"function my_scc_calculation(sim_inst::SimulationInstance, trialnum::Int, ntimesteps::Int, tup::Nothing)\n    mm = sim_inst.models[1] \n    discount_factors, scc_results = Mimi.payload(sim_inst)  # Unpack the payload object\n\n    marginal_damages = mm[:neteconomy, :C] * -1 * 10^12 * 12/44 # convert from trillion $/ton C to $/ton CO2; multiply by -1 to get positive value for damages\n    for (i, df) in enumerate(discount_factors)\n        scc_results[trialnum, i] = sum(df .* marginal_damages .* 10)\n    end\nend","category":"page"},{"location":"tutorials/tutorial_4/#Run-the-simulation-1","page":"4 Sensitivity Analysis","title":"Run the simulation","text":"","category":"section"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"Now that we have our post-trial function, we can proceed to obtain our two models and run the simulation. Note that we are using a Mimi MarginalModel mm from MimiDICE2010, which is a Mimi object that holds both the base model and the model with the additional pulse of emissions.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"# Build the marginal model\nmm = MimiDICE2010.get_marginal_model(year = scc_year)   # The additional emissions pulse will be added in the specified year\n\n# Run\nsi = run(sd, mm, N; trials_output_filename = \"ecs_sample.csv\", post_trial_func = my_scc_calculation)\n\n# View the scc_results by retrieving them from the payload object\nscc_results = Mimi.payload(si)[2]   # Recall that the SCC array was the second of two arrays we stored in the payload tuple","category":"page"},{"location":"tutorials/tutorial_4/#Simulation-Modification-Functions-1","page":"4 Sensitivity Analysis","title":"Simulation Modification Functions","text":"","category":"section"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"A small set of unexported functions are available to modify an existing SimulationDef.  The functions include:","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"delete_RV!\nadd_RV!\nreplace_RV!\ndelete_transform!\nadd_transform!\ndelete_save!\nadd_save!\nset_payload!\npayload","category":"page"},{"location":"tutorials/tutorial_4/#Full-list-of-keyword-options-for-running-a-simulation-1","page":"4 Sensitivity Analysis","title":"Full list of keyword options for running a simulation","text":"","category":"section"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"View the internals documentation here for critical and useful details on the full signature of this function:","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Sensitivity Analysis","title":"4 Sensitivity Analysis","text":"function Base.run(sim_def::SimulationDef{T}, models::Union{Vector{Model}, Model}, samplesize::Int;\n                 ntimesteps::Int=typemax(Int), \n                 trials_output_filename::Union{Nothing, AbstractString}=nothing, \n                 results_output_dir::Union{Nothing, AbstractString}=nothing, \n                 pre_trial_func::Union{Nothing, Function}=nothing, \n                 post_trial_func::Union{Nothing, Function}=nothing,\n                 scenario_func::Union{Nothing, Function}=nothing,\n                 scenario_placement::ScenarioLoopPlacement=OUTER,\n                 scenario_args=nothing,\n                 results_in_memory::Bool=true) where T <: AbstractSimulationData","category":"page"},{"location":"tutorials/tutorial_3/#Tutorial-3:-Create-a-Model-1","page":"3 Create a Model","title":"Tutorial 3: Create a Model","text":"","category":"section"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"This tutorial walks through the steps to create a new model, first a one-region model and then a more complex multi-region model. ","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"While we will walk through the code step by step below, the full code for implementation is also available in the examples/tutorial folder in the Mimi github repository.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"Working through the following tutorial will require:","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"Julia v1.2.0 or higher\nMimi v0.9.4 ","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"If you have not yet prepared these, go back to the main tutorial page and follow the instructions for their download. ","category":"page"},{"location":"tutorials/tutorial_3/#Constructing-A-One-Region-Model-1","page":"3 Create a Model","title":"Constructing A One-Region Model","text":"","category":"section"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"In this example, we construct a stylized model of the global economy and its changing greenhouse gas emission levels through time. The overall strategy involves creating components for the economy and emissions separately, and then defining a model where the two components are coupled together.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"There are two main steps to creating a component, both within the  @defcomp macro which defines a component:","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"List the parameters and variables.\nUse the run_timestep function run_timestep(p, v, d, t) to set the equations of that component.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"Starting with the economy component, each variable and parameter is listed. If either variables or parameters have a time-dimension, that must be set with (index=[time]).","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"Next, the run_timestep function must be defined along with the various equations of the grosseconomy component. In this step, the variables and parameters are linked to this component and must be identified as either a variable or a parameter in each equation. For this example, v will refer to variables while p refers to parameters.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"It is important to note that t below is an AbstractTimestep, and the specific API for using this argument are described in detail in the userguide in Advanced Topics:  Timesteps and available functions. ","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"using Mimi # start by importing the Mimi package to your space\n\n@defcomp grosseconomy begin\n\tYGROSS\t= Variable(index=[time])\t# Gross output\n\tK\t    = Variable(index=[time])\t# Capital\n\tl\t    = Parameter(index=[time])\t# Labor\n\ttfp\t    = Parameter(index=[time])\t# Total factor productivity\n\ts\t    = Parameter(index=[time])\t# Savings rate\n\tdepk\t= Parameter()\t\t\t    # Depreciation rate on capital - Note that it has no time index\n\tk0\t    = Parameter()\t\t\t    # Initial level of capital\n\tshare\t= Parameter()\t\t\t    # Capital share\n\n\tfunction run_timestep(p, v, d, t)\n\t\t# Define an equation for K\n\t\tif is_first(t)\n\t\t\t# Note the use of v. and p. to distinguish between variables and parameters\n\t\t\tv.K[t] \t= p.k0\t\n\t\telse\n\t\t\tv.K[t] \t= (1 - p.depk)^5 * v.K[t-1] + v.YGROSS[t-1] * p.s[t-1] * 5\n\t\tend\n\n\t\t# Define an equation for YGROSS\n\t\tv.YGROSS[t] = p.tfp[t] * v.K[t]^p.share * p.l[t]^(1-p.share)\n\tend\nend","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"Next, the component for greenhouse gas emissions must be created.  Although the steps are the same as for the grosseconomy component, there is one minor difference. While YGROSS was a variable in the grosseconomy component, it now enters the emissions component as a parameter. This will be true for any variable that becomes a parameter for another component in the model.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"@defcomp emissions begin\n\tE \t    = Variable(index=[time])\t# Total greenhouse gas emissions\n\tsigma\t= Parameter(index=[time])\t# Emissions output ratio\n\tYGROSS\t= Parameter(index=[time])\t# Gross output - Note that YGROSS is now a parameter\n\n\tfunction run_timestep(p, v, d, t)\n\n\t\t# Define an equation for E\n\t\tv.E[t] = p.YGROSS[t] * p.sigma[t]\t# Note the p. in front of YGROSS\n\tend\nend","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"We can now use Mimi to construct a model that binds the grosseconomy and emissions components together in order to solve for the emissions level of the global economy over time. In this example, we will run the model for twenty periods with a timestep of five years between each period.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"Once the model is defined, set_dimension! is used to set the length and interval of the time step.\nWe then use add_comp! to incorporate each component that we previously created into the model.  It is important to note that the order in which the components are listed here matters.  The model will run through each equation of the first component before moving onto the second component.\nNext, set_param! is used to assign values to each parameter in the model, with parameters being uniquely tied to each component. If population was a parameter for two different components, it must be assigned to each one using set_param! two different times. The syntax is set_param!(model_name, :component_name, :parameter_name, value)\nIf any variables of one component are parameters for another, connect_param! is used to couple the two components together. In this example, YGROSS is a variable in the grosseconomy component and a parameter in the emissions component. The syntax is connect_param!(model_name, :component_name_parameter, :parameter_name, :component_name_variable, :variable_name), where :component_name_variable refers to the component where your parameter was initially calculated as a variable.\nFinally, the model can be run using the command run(model_name).\nTo access model results, use model_name[:component, :variable_name].\nTo observe model results in a graphical form , explore as either explore(model_name) to open the UI window, or use Mimi.plot(model_name, :component_name, :variable_name) or Mimi.plot(model_name, :component_name, :parameter_name) to plot a specific parameter or variable.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"\nusing Mimi\n\nfunction construct_model()\n\tm = Model()\n\n\tset_dimension!(m, :time, collect(2015:5:2110))\n\n\t# Order matters here. If the emissions component were defined first, the model would not run.\n\tadd_comp!(m, grosseconomy)  \n\tadd_comp!(m, emissions)\n\n\t# Set parameters for the grosseconomy component\n\tset_param!(m, :grosseconomy, :l, [(1. + 0.015)^t *6404 for t in 1:20])\n\tset_param!(m, :grosseconomy, :tfp, [(1 + 0.065)^t * 3.57 for t in 1:20])\n\tset_param!(m, :grosseconomy, :s, ones(20).* 0.22)\n\tset_param!(m, :grosseconomy, :depk, 0.1)\n\tset_param!(m, :grosseconomy, :k0, 130.)\n\tset_param!(m, :grosseconomy, :share, 0.3)\n\n\t# Set parameters for the emissions component\n\tset_param!(m, :emissions, :sigma, [(1. - 0.05)^t *0.58 for t in 1:20])\n\tconnect_param!(m, :emissions, :YGROSS, :grosseconomy, :YGROSS)  \n\t# Note that connect_param! was used here.\n\n\treturn m\n\nend #end function","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"Note that as an alternative to using many of the set_param! calls above, one may use the default keyword argument in @defcomp when first defining a Variable or Parameter, as shown in examples/tutorial/01-one-region-model/one-region-model-defaults.jl.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"Now we can run the model and examine the results:","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"# Run model\nm = construct_model()\nrun(m)\n\n# Check model results\ngetdataframe(m, :emissions, :E) # or m[:emissions, :E_Global] to return just the Array","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"Finally we can visualize the results via plotting and explorer:","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"# Plot model results\nMimi.plot(m, :emissions, :E);\n\n# Observe all model result graphs in UI\nexplore(m)","category":"page"},{"location":"tutorials/tutorial_3/#Constructing-A-Multi-Region-Model-1","page":"3 Create a Model","title":"Constructing A Multi-Region Model","text":"","category":"section"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"We can now modify our two-component model of the globe to include multiple regional economies.  Global greenhouse gas emissions will now be the sum of regional emissions. The modeling approach is the same, with a few minor adjustments:","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"When using @defcomp, a regions index must be specified. In addition, for variables that have a regional index it is necessary to include (index=[regions]). This can be combined with the time index as well, (index=[time, regions]).\nIn the run_timestep function, unlike the time dimension, regions must be specified and looped through in any equations that contain a regional variable or parameter.\nset_dimension! must be used to specify your regions in the same way that it is used to specify your timestep.\nWhen using set_param! for values with a time and regional dimension, an array is used.  Each row corresponds to a time step, while each column corresponds to a separate region. For regional values with no timestep, a vector can be used. It is often easier to create an array of parameter values before model construction. This way, the parameter name can be entered into set_param! rather than an entire equation.\nWhen constructing regionalized models with multiple components, it is often easier to save each component as a separate file and to then write a function that constructs the model.  When this is done, using Mimi must be speficied for each component. This approach will be used here.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"To create a three-regional model, we will again start by constructing the grosseconomy and emissions components, making adjustments for the regional index as needed.  Each component should be saved as a separate file.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"As this model is also more complex and spread across several files, we will also take this as a chance to introduce the custom of using Modules to package Mimi models, as shown below.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"using Mimi\n\n@defcomp grosseconomy begin\n    regions = Index()                           #Note that a regional index is defined here\n\n    YGROSS  = Variable(index=[time, regions])   #Gross output\n    K       = Variable(index=[time, regions])   #Capital\n    l       = Parameter(index=[time, regions])  #Labor\n    tfp     = Parameter(index=[time, regions])  #Total factor productivity\n    s       = Parameter(index=[time, regions])  #Savings rate\n    depk    = Parameter(index=[regions])        #Depreciation rate on capital - Note that it only has a region index\n    k0      = Parameter(index=[regions])        #Initial level of capital\n    share   = Parameter()                       #Capital share\n\n    function run_timestep(p, v, d, t)\n    # Note that the regional dimension is defined in d and parameters and variables are indexed by 'r'\n\n        # Define an equation for K\n        for r in d.regions\n            if is_first(t)\n                v.K[t,r] = p.k0[r]\n            else\n                v.K[t,r] = (1 - p.depk[r])^5 * v.K[t-1,r] + v.YGROSS[t-1,r] * p.s[t-1,r] * 5\n            end\n        end\n\n        # Define an equation for YGROSS\n        for r in d.regions\n            v.YGROSS[t,r] = p.tfp[t,r] * v.K[t,r]^p.share * p.l[t,r]^(1-p.share)\n        end\n    end\nend","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"Save this component as gross_economy.jl","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"using Mimi\t#Make sure to call Mimi again\n\n@defcomp emissions begin\n    regions     = Index()                           # The regions index must be specified for each component\n\n    E           = Variable(index=[time, regions])   # Total greenhouse gas emissions\n    E_Global    = Variable(index=[time])            # Global emissions (sum of regional emissions)\n    sigma       = Parameter(index=[time, regions])  # Emissions output ratio\n    YGROSS      = Parameter(index=[time, regions])  # Gross output - Note that YGROSS is now a parameter\n\n    # function init(p, v, d)\n    # end\n    \n    function run_timestep(p, v, d, t)\n        # Define an equation for E\n        for r in d.regions\n            v.E[t,r] = p.YGROSS[t,r] * p.sigma[t,r]\n        end\n\n        # Define an equation for E_Global\n        for r in d.regions\n            v.E_Global[t] = sum(v.E[t,:])\n        end\n    end\n\nend","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"Save this component as emissions.jl","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"Let's create a file with all of our parameters that we can call into our model.  This will help keep things organized as the number of components and regions increases. Each column refers to parameter values for a region, reflecting differences in initial parameter values and growth rates between the three regions.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"l = Array{Float64}(undef, 20, 3)\nfor t in 1:20\n    l[t,1] = (1. + 0.015)^t *2000\n    l[t,2] = (1. + 0.02)^t * 1250\n    l[t,3] = (1. + 0.03)^t * 1700\nend\n\ntfp = Array{Float64}(undef, 20, 3)\nfor t in 1:20\n    tfp[t,1] = (1 + 0.06)^t * 3.2\n    tfp[t,2] = (1 + 0.03)^t * 1.8\n    tfp[t,3] = (1 + 0.05)^t * 2.5\nend\n\ns = Array{Float64}(undef, 20, 3)\nfor t in 1:20\n    s[t,1] = 0.21\n    s[t,2] = 0.15\n    s[t,3] = 0.28\nend\n\ndepk = [0.11, 0.135 ,0.15]\nk0   = [50.5, 22., 33.5]\n\nsigma = Array{Float64}(undef, 20, 3)\nfor t in 1:20\n    sigma[t,1] = (1. - 0.05)^t * 0.58\n    sigma[t,2] = (1. - 0.04)^t * 0.5\n    sigma[t,3] = (1. - 0.045)^t * 0.6\nend","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"Save this file as region_parameters.jl","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"The final step is to create a module:","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"module MyModel\n\nusing Mimi\n\ninclude(\"region_parameters.jl\")\ninclude(\"gross_economy.jl\")\ninclude(\"emissions.jl\")\n\nexport construct_MyModel","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"function construct_MyModel()\n\n\tm = Model()\n\n\tset_dimension!(m, :time, collect(2015:5:2110))\n\tset_dimension!(m, :regions, [:Region1, :Region2, :Region3])\t # Note that the regions of your model must be specified here\n\n\tadd_comp!(m, grosseconomy)\n\tadd_comp!(m, emissions)\n\n\tset_param!(m, :grosseconomy, :l, l)\n\tset_param!(m, :grosseconomy, :tfp, tfp)\n\tset_param!(m, :grosseconomy, :s, s)\n\tset_param!(m, :grosseconomy, :depk,depk)\n\tset_param!(m, :grosseconomy, :k0, k0)\n\tset_param!(m, :grosseconomy, :share, 0.3)\n\n\t# set parameters for emissions component\n\tset_param!(m, :emissions, :sigma, sigma)\n\tconnect_param!(m, :emissions, :YGROSS, :grosseconomy, :YGROSS)\n\n    return m\nend","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"end #module","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"Save this file as MyModel.jl","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"We can now run the model and evaluate the results.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"using Mimi\n\ninclude(\"MyModel.jl\")\nusing .MyModel","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"m = construct_MyModel()\nrun(m)\n\n# Check results\ngetdataframe(m, :emissions, :E_Global) # or m[:emissions, :E_Global] to return just the Array","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Create a Model","title":"3 Create a Model","text":"# Observe model result graphs\nexplore(m)","category":"page"},{"location":"internals/structure/#Mimi-Internal-Structure-1","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"","category":"section"},{"location":"internals/structure/#.-Code-organization-1","page":"Mimi Internal Structure","title":"1. Code organization","text":"","category":"section"},{"location":"internals/structure/#Types-1","page":"Mimi Internal Structure","title":"Types","text":"","category":"section"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"All Mimi types are defined in Mimi/src/core/types.jl.","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"The types are broadly divided into two categories reflecting \"structural definitions\" versus \"instantiated model info\". Structural definition types include:","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"ModelDef\nComponentDef\nDatumDef (used for both variable and parameter definitions)","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"Instantiated model info types include:","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"ModelInstance\nComponentInstance\nComponentInstanceVariables\nComponentInstanceParameters","category":"page"},{"location":"internals/structure/#Model-object-1","page":"Mimi Internal Structure","title":"Model object","text":"","category":"section"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"The \"user-facing\" Model no longer directly holds other model information: it now holds a ModelDef and, once the model is built, a ModelInstance, and delegates all function calls to one or the other of these, as appropriate. The \"public\" API to models is provided by functions taking a Model instance, which are defined in the file model.jl.","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"With this change, all previous \"direct\" access of data in the Model instance are replaced by a functional API. That is, all occurrences of m.xxx (where m::Model) have been replaced with function calls on m, which are then delegated to the ModelDef or ModelInstance, as appropriate.","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"To simplify coding the delegated calls, a new macro, @modelegate allows you to write, e.g., ","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"@modelegate external_param_conns(m::Model) => mi","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"which translates to:","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"external_param_conns(m::Model) = external_param_conns.mi)","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"The right-hand side can also be => md to indicate delegation to the ModelDef rather than to the ModelInstance. See model.jl for numerous examples.","category":"page"},{"location":"internals/structure/#Connections-1","page":"Mimi Internal Structure","title":"Connections","text":"","category":"section"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"The types InternalParameterConnection and ExternalParameterConnection are now both subtypes of the abstract type Connection.","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"[We may merge these two connection types since the only functional differences are that the ExternalParameterConnections type has fewer fields and its instances are stored in a separate list in the model.]","category":"page"},{"location":"internals/structure/#ComponentInstanceData-1","page":"Mimi Internal Structure","title":"ComponentInstanceData","text":"","category":"section"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"ComponentInstanceVariables and ComponentInstanceParameters are parametric types that are subtypes of ComponentInstanceData. The names and types of the variables or parameters are encoded into the type information; the struct proper contains only the parameter or variable values. Use of this parametric type allows us to use @generated to produce type-specific getproperty and setproperty! functions that efficiently access model parameters. [See Dot-overloading, below.]","category":"page"},{"location":"internals/structure/#.-Changes-to-@defcomp-1","page":"Mimi Internal Structure","title":"2. Changes to @defcomp","text":"","category":"section"},{"location":"internals/structure/#Macro-simplification-1","page":"Mimi Internal Structure","title":"Macro simplification","text":"","category":"section"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"The @defcomp macro has been substantially simplified by relying on MacroTools.jl package and by avoiding the construction of expressions using Abstract Syntax Tree form. The macro now operates by producing a fairly simple sequence of function calls.","category":"page"},{"location":"internals/structure/#Dot-overloading-1","page":"Mimi Internal Structure","title":"Dot-overloading","text":"","category":"section"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"In a change from the prior iteration of Mimi, the run_timestep function must now be defined within the @defcomp macro. It takes four arguments: parameters, variables, dimensions, and time.","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"    function run_timestep(p, v, d, t)\n       ...\n    end","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"With the run_timestep function inside the @defcomp macro, we are able to modify the code to translate references like p.gdp and assignments like v.foo = 3 to use new @generated functions getproperty and setproperty!, which compile down to direct array access operations on the values field of parameter and variable instances.","category":"page"},{"location":"internals/structure/#Component-naming-1","page":"Mimi Internal Structure","title":"Component naming","text":"","category":"section"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"In the previous version of Mimi, components were named by a pair of symbols indicating the module the component was defined in, and the name of the component. Each component was also reified in a newly generated custom type.","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"In the new version, all component definitions are represented by one type, ComponentDef. The @defcomp macro creates a global variable with the name provided to @defcomp which holds a new type of object, ComponentId, which holds the symbol names of the module and component. The name of the model given in the @defcomp macro invocation becomes a variable holding the ComponentId. Thus, instead of referring to a component as, say, (:Mimi, :grosseconomy), you refer to it by its associated global constant, e.g., Mimi.grosseconomy. Note that models can be defined in their own module to avoid namespace collisions.","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"(Image: Object structure)","category":"page"},{"location":"internals/structure/#.-New-macro-@defmodel-1","page":"Mimi Internal Structure","title":"3. New macro @defmodel","text":"","category":"section"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"The @defmodel macro provides simplified syntax for model creation, eliminating many redundant parameters. For example, you can write:","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"@defmodel mymodel begin\n\n    index[time] = 2015:5:2110\n\n    component(grosseconomy)\n    component(emissions)\n\n    # Set parameters for the grosseconomy component\n    grosseconomy.l = [(1. + 0.015)^t *6404 for t in 1:20]\n    grosseconomy.tfp = [(1 + 0.065)^t * 3.57 for t in 1:20]\n    grosseconomy.s = ones(20).* 0.22\n    grosseconomy.depk = 0.1\n    grosseconomy.k0 = 130.0\n    grosseconomy.share = 0.3\n\n    # Set parameters for the emissions component\n    emissions.sigma = [(1. - 0.05)^t *0.58 for t in 1:20]\n\n    # Connect pararameters (source_variable => destination_parameter)\n    grosseconomy.YGROSS => emissions.YGROSS\nend","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"which produces these function calls:","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"quote\n    mymodel = Model()\n    set_dimension!(mymodel, :time, 2015:5:2110)\n    add_comp!(mymodel, Main.grosseconomy, :grosseconomy)\n    add_comp!(mymodel, Main.emissions, :emissions)\n    set_param!(mymodel, :grosseconomy, :l, [(1.0 + 0.015) ^ t * 6404 for t = 1:20])\n    set_param!(mymodel, :grosseconomy, :tfp, [(1 + 0.065) ^ t * 3.57 for t = 1:20])\n    set_param!(mymodel, :grosseconomy, :s, ones(20) * 0.22)\n    set_param!(mymodel, :grosseconomy, :depk, 0.1)\n    set_param!(mymodel, :grosseconomy, :k0, 130.0)\n    set_param!(mymodel, :grosseconomy, :share, 0.3)\n    set_param!(mymodel, :emissions, :sigma, [(1.0 - 0.05) ^ t * 0.58 for t = 1:20])\n    connect_param!(mymodel, :emissions, :YGROSS, :grosseconomy, :YGROSS)\nend","category":"page"},{"location":"internals/structure/#.-Pre-compilation-and-built-in-components-1","page":"Mimi Internal Structure","title":"4. Pre-compilation and built-in components","text":"","category":"section"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"To get __precompile__() to work required moving the creation of \"helper\" components to an __init__() method in Mimi.jl, which is run automatically after Mimi loads. It defines the two \"built-in\" components, from adder.jl and connector.jl in the components subdirectory.","category":"page"},{"location":"reference/#Reference-1","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"@defcomp\nMarginalModel\nModel\nadd_comp!  \nconnect_param!\ncreate_marginal_model\ndim_count\ndim_keys\ndim_key_dict\ndisconnect_param!\nexplore\ngetdataframe\ngettime\nget_param_value\nget_var_value\nhasvalue\nis_first\nis_last\nis_time\nis_timestep\nmodeldef\nparameter_names\nparameter_dimensions\nplot_comp_graph\nreplace_comp! \nset_dimension! \nset_leftover_params! \nset_param! \nTimestepIndex\nTimestepValue\nvariable_dimensions\nvariable_names\nupdate_param!\nupdate_params!","category":"page"},{"location":"reference/#Mimi.@defcomp","page":"Reference","title":"Mimi.@defcomp","text":"defcomp(comp_name::Symbol, ex::Expr)\n\nDefine a Mimi component comp_name with the expressions in ex.  The following  types of expressions are supported:\n\ndimension_name = Index()   # defines a dimension\nparameter = Parameter(index = [dimension_name], units = \"unit_name\", default = default_value)    # defines a parameter with optional arguments\nvariable = Variable(index = [dimension_name], units = \"unit_name\")    # defines a variable with optional arguments\ninit(p, v, d)              # defines an init function for the component\nrun_timestep(p, v, d, t)   # defines a run_timestep function for the component\n\nParses a @defcomp definition, converting it into a series of function calls that create the corresponding ComponentDef instance. At model build time, the ModelDef (including its ComponentDefs) will be converted to a runnable model.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#Mimi.MarginalModel","page":"Reference","title":"Mimi.MarginalModel","text":"MarginalModel\n\nA Mimi Model whose results are obtained by subtracting results of one base Model from those of another marginal Modelthat has a difference ofdelta`.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Mimi.Model","page":"Reference","title":"Mimi.Model","text":"Model\n\nA user-facing API containing a ModelInstance (mi) and a ModelDef (md). This Model can be created with the optional keyword argument number_type indicating the default type of number used for the ModelDef.  If not specified the Model assumes a number_type of Float64.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Mimi.add_comp!","page":"Reference","title":"Mimi.add_comp!","text":"add_comp!(\n    obj::AbstractCompositeComponentDef,\n    comp_def::AbstractComponentDef,\n    comp_name::Symbol=comp_def.comp_id.comp_name;\n    before::NothingSymbol=nothing,\n    after::NothingSymbol=nothing,\n    rename::NothingPairList=nothing\n)\n\nAdd the component comp_def to the composite component indicated by obj. The component is added at the end of the list unless one of the keywords before or after is specified. Note that a copy of comp_id is made in the composite and assigned the give name. The optional argument rename can be a list of pairs indicating original_name => imported_name.\n\n\n\n\n\nadd_comp!(\n    obj::AbstractCompositeComponentDef,\n    comp_id::ComponentId,\n    comp_name::Symbol=comp_id.comp_name;\n    before::NothingSymbol=nothing,\n    after::NothingSymbol=nothing,\n    rename::NothingPairList=nothing\n)\n\nAdd the component indicated by comp_id to the composite component indicated by obj. The component is added at the end of the list unless one of the keywords before or after is specified. Note that a copy of comp_id is made in the composite and assigned the give name.\n\n[Not yet implemented:] The optional argument rename can be a list of pairs indicating original_name => imported_name.\n\n\n\n\n\nadd_comp!(obj::AbstractCompositeComponentInstance, ci::AbstractComponentInstance)\n\nAdd the (leaf or composite) component ci to a composite's list of components.\n\n\n\n\n\nadd_comp!(\n    m::Model, comp_id::ComponentId, comp_name::Symbol=comp_id.comp_name;\n    before::NothingSymbol=nothing,\n    after::NothingSymbol=nothing,\n    rename::NothingPairList=nothing\n)\n\nAdd the component indicated by comp_id to the model indicated by m. The component is added at the end of the list unless one of the keywords before or after is specified. Note that a copy of comp_id is made in the composite and assigned the give name. The optional argument rename can be a list of pairs indicating original_name => imported_name.\n\n\n\n\n\nadd_comp!(\n    m::Model, comp_def::AbstractComponentDef, comp_name::Symbol=comp_id.comp_name;\n    before::NothingSymbol=nothing,\n    after::NothingSymbol=nothing,\n    rename::NothingPairList=nothing\n)\n\nAdd the component comp_def to the model indicated by m. The component is added at the end of the list unless one of the keywords, first, last, before, after. Note that a copy of comp_id is made in the composite and assigned the give name. The optional argument rename can be a list of pairs indicating original_name => imported_name.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mimi.connect_param!","page":"Reference","title":"Mimi.connect_param!","text":"connect_param!(obj::AbstractCompositeComponentDef, comp_name::Symbol, param_name::Symbol, ext_param_name::Symbol;\n               check_labels::Bool=true)\n\nConnect a parameter param_name in the component comp_name of composite obj to the external parameter ext_param_name.\n\n\n\n\n\nconnect_param!(obj::AbstractCompositeComponentDef,\n    dst_comp_path::ComponentPath, dst_par_name::Symbol,\n    src_comp_path::ComponentPath, src_var_name::Symbol,\n    backup::Union{Nothing, Array}=nothing;\n    ignoreunits::Bool=false, offset::Int=0)\n\nBind the parameter dst_par_name of one component dst_comp_path of composite obj to a variable src_var_name in another component src_comp_path of the same model using backup to provide default values and the ignoreunits flag to indicate the need to check match units between the two.  The offset argument indicates the offset between the destination and the source ie. the value would be 1 if the destination component parameter should only be calculated for the second timestep and beyond.\n\n\n\n\n\nconnect_param!(obj::AbstractCompositeComponentDef,\n    dst::Pair{Symbol, Symbol}, src::Pair{Symbol, Symbol},\n    backup::Union{Nothing, Array}=nothing;\n    ignoreunits::Bool=false, offset::Int=0)\n\nBind the parameter dst[2] of one component dst[1] of composite obj to a variable src[2] in another component src[1] of the same composite using backup to provide default values and the ignoreunits flag to indicate the need to check match units between the two.  The offset argument indicates the offset between the destination and the source ie. the value would be 1 if the destination component parameter should only be calculated for the second timestep and beyond.\n\n\n\n\n\nConnect a parameter and variable using string notation \"/path/to/component:datum_name\" where the potion before the \":\" is the string representation of a component path from obj and the portion after is the name of the src or dst datum.\n\n\n\n\n\nconnect_param!(dst::ComponentReference, dst_name::Symbol, src::ComponentReference, src_name::Symbol)\n\nConnect two components as connect_param!(dst, dst_name, src, src_name).\n\n\n\n\n\nconnect_param!(dst::ComponentReference, src::ComponentReference, name::Symbol)\n\nConnect two components with the same name as connect_param!(dst, src, name).\n\n\n\n\n\nconnect_param!(m::Model, dst_comp_path::ComponentPath, dst_par_name::Symbol, src_comp_path::ComponentPath,\n    src_var_name::Symbol, backup::Union{Nothing, Array}=nothing; ignoreunits::Bool=false, offset::Int=0)\n\nBind the parameter dst_par_name of one component dst_comp_path of model md to a variable src_var_name in another component src_comp_path of the same model using backup to provide default values and the ignoreunits flag to indicate the need to check match units between the two.  The offset argument indicates the offset between the destination and the source ie. the value would be 1 if the destination component parameter should only be calculated for the second timestep and beyond.\n\n\n\n\n\nconnect_param!(m::Model, dst::Pair{Symbol, Symbol}, src::Pair{Symbol, Symbol}, backup::Array; ignoreunits::Bool=false)\n\nBind the parameter dst[2] of one component dst[1] of model md to a variable src[2] in another component src[1] of the same model using backup to provide default values and the ignoreunits flag to indicate the need to check match units between the two.  The offset argument indicates the offset between the destination and the source ie. the value would be 1 if the destination component parameter should only be calculated for the second timestep and beyond.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mimi.create_marginal_model","page":"Reference","title":"Mimi.create_marginal_model","text":"create_marginal_model(base::Model, delta::Float64=1.0)\n\nCreate a MarginalModel where base is the baseline model and delta is the difference used to create the marginal model.  Return the resulting MarginaModel which shares the internal ModelDef between the base and marginal.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mimi.dim_count","page":"Reference","title":"Mimi.dim_count","text":"dim_count(mi::ModelInstance, dim_name::Symbol)\n\nReturn the size of index dim_name in model instance mi.\n\n\n\n\n\ndim_count(m::Model, dim_name::Symbol)\n\nReturn the size of index dim_name in model m.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mimi.dim_keys","page":"Reference","title":"Mimi.dim_keys","text":"dim_keys(m::Model, dim_name::Symbol)\n\nReturn keys for dimension dim-name in model m.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mimi.dim_key_dict","page":"Reference","title":"Mimi.dim_key_dict","text":"dim_key_dict(m::Model)\n\nReturn a dict of dimension keys for all dimensions in model m.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mimi.disconnect_param!","page":"Reference","title":"Mimi.disconnect_param!","text":"disconnect_param!(obj::AbstractCompositeComponentDef, comp_def::AbstractComponentDef, param_name::Symbol)\n\nRemove any parameter connections for a given parameter param_name in a given component comp_def which must be a direct subcomponent of composite obj.\n\n\n\n\n\ndisconnect_param!(obj::AbstractCompositeComponentDef, comp_name::Symbol, param_name::Symbol)\n\nRemove any parameter connections for a given parameter param_name in a given component comp_def which must be a direct subcomponent of composite obj.\n\n\n\n\n\ndisconnect_param!(obj::AbstractCompositeComponentDef, comp_path::ComponentPath, param_name::Symbol)\n\nRemove any parameter connections for a given parameter param_name in the component identified by comp_path which must be under the composite obj.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mimi.explore","page":"Reference","title":"Mimi.explore","text":"explore(m::Model; title = \"Electron\")\n\nProduce a UI to explore the parameters and variables of Model m in a Window with title title.\n\n\n\n\n\nexplore(sim_inst::SimulationInstance; title=\"Electron\", model_index::Int = 1, scen_name::Union{Nothing, String} = nothing, results_output_dir::Union{Nothing, String} = nothing)\n\nProduce a UI to explore the output distributions of the saved variables in SimulationInstance sim for results of model model_index and scenario with the name scen_name in a Window with title title. The optional arguments default to a model_index of 1, a scen_name of nothing  assuming there is no secenario dimension, and a window with title Electron.   The results_output_dir keyword argument refers to the main output directory as provided to run,  where all subdirectories are held. If provided, results are assumed to be stored there, otherwise it is  assumed that results are held in results.sim and not  in an output folder.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mimi.getdataframe","page":"Reference","title":"Mimi.getdataframe","text":"getdataframe(m::AbstractModel, comp_name::Symbol, pairs::Pair{Symbol, Symbol}...)\n\nReturn a DataFrame with values for the given variables or parameters of model m indicated by pairs, where each pair is of the form comp_name => item_name. If more than one pair is provided, all must refer to items with the same dimensions, which are used to join the respective item values.\n\n\n\n\n\ngetdataframe(m::AbstractModel, pair::Pair{Symbol, NTuple{N, Symbol}})\n\nReturn a DataFrame with values for the given variables or parameters  indicated by pairs, where each pair is of the form comp_name => item_name. If more than one pair is provided, all must refer to items with the same dimensions, which are used to join the respective item values.\n\n\n\n\n\ngetdataframe(m::AbstractModel, comp_name::Symbol, item_name::Symbol)\n\nReturn the values for variable or parameter item_name in comp_name of  model m as a DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mimi.gettime","page":"Reference","title":"Mimi.gettime","text":"gettime(ts::FixedTimestep)\n\nReturn the time (year) represented by Timestep ts \n\n\n\n\n\ngettime(ts::VariableTimestep)\n\nReturn the time (year) represented by Timestep ts \n\n\n\n\n\ngettime(c::Clock)\n\nReturn the current time of the timestep held by the c clock.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mimi.get_param_value","page":"Reference","title":"Mimi.get_param_value","text":"get_param_value(ci::AbstractComponentInstance, name::Symbol)\n\nReturn the value of parameter name in (leaf or composite) component ci.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mimi.get_var_value","page":"Reference","title":"Mimi.get_var_value","text":"get_var_value(ci::AbstractComponentInstance, name::Symbol)\n\nReturn the value of variable name in component ci.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mimi.hasvalue","page":"Reference","title":"Mimi.hasvalue","text":"hasvalue(arr::TimestepArray, ts::FixedTimestep)\n\nReturn true or false, true if the TimestepArray arr contains the Timestep ts.\n\n\n\n\n\nhasvalue(arr::TimestepArray, ts::VariableTimestep)\n\nReturn true or false, true if the TimestepArray arr contains the Timestep ts.\n\n\n\n\n\nhasvalue(arr::TimestepArray, ts::FixedTimestep, idxs::Int...)\n\nReturn true or false, true if the TimestepArray arr contains the Timestep ts within indices idxs. Used when Array and Timestep have different FIRST, validating all dimensions.\n\n\n\n\n\nhasvalue(arr::TimestepArray, ts::VariableTimestep, idxs::Int...)\n\nReturn true or false, true if the TimestepArray arr contains the Timestep ts within indices idxs. Used when Array and Timestep different TIMES, validating all dimensions.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mimi.is_first","page":"Reference","title":"Mimi.is_first","text":"is_first(ts::AbstractTimestep)\n\nReturn true or false, true if ts is the first timestep to be run.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mimi.is_last","page":"Reference","title":"Mimi.is_last","text":"is_last(ts::FixedTimestep)\n\nReturn true or false, true if ts is the last timestep to be run.\n\n\n\n\n\nis_last(ts::VariableTimestep)\n\nReturn true or false, true if ts is the last timestep to be run.  Note that you may run next_timestep on ts, as ths final timestep has not been run through yet.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mimi.is_time","page":"Reference","title":"Mimi.is_time","text":"is_time(ts::AbstractTimestep, t::Int)\n\nReturn true or false, true if the current time (year) for ts is t\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mimi.is_timestep","page":"Reference","title":"Mimi.is_timestep","text":"is_timestep(ts::AbstractTimestep, t::Int)\n\nReturn true or false, true if ts timestep is step t.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mimi.modeldef","page":"Reference","title":"Mimi.modeldef","text":"modeldef(mi)\n\nReturn the ModelDef contained by ModelInstance mi.\n\n\n\n\n\nmodeldef(m)\n\nReturn the ModelDef contained by Model m.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mimi.parameter_names","page":"Reference","title":"Mimi.parameter_names","text":"parameter_names(md::ModelDef, comp_name::Symbol)\n\nReturn a list of all parameter names for a given component comp_name in a model def md.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mimi.parameter_dimensions","page":"Reference","title":"Mimi.parameter_dimensions","text":"parameter_dimensions(obj::AbstractComponentDef, param_name::Symbol)\n\nReturn the names of the dimensions of parameter param_name exposed in the component definition indicated by obj.\n\n\n\n\n\nparameter_dimensions(obj::AbstractComponentDef, comp_name::Symbol, param_name::Symbol)\n\nReturn the names of the dimensions of parameter param_name in component comp_name, which is exposed in composite component definition indicated byobj.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mimi.plot_comp_graph","page":"Reference","title":"Mimi.plot_comp_graph","text":"plot_comp_graph(m::Model, filename::Union{Nothing, Symbol} = nothing)\n\nPlot the DAG of component connections within model m and save to filename. If no filename is given, plot will simply display.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mimi.replace_comp!","page":"Reference","title":"Mimi.replace_comp!","text":"replace_comp!(\n    obj::AbstractCompositeComponentDef,\n    comp_id::ComponentId,\n    comp_name::Symbol=comp_id.comp_name;\n    before::NothingSymbol=nothing,\n    after::NothingSymbol=nothing,\n    reconnect::Bool=true\n)\n\nReplace the component with name comp_name in composite component definition obj with the component comp_id using the same name. The component is added in the same position as the old component, unless one of the keywords before or after is specified. The component is added with the same first and last values, unless the keywords first or last are specified. Optional boolean argument reconnect with default value true indicates whether the existing parameter connections should be maintained in the new component. Returns the added comp def.\n\n\n\n\n\nreplace_comp!(\n    m::Model, comp_id::ComponentId, comp_name::Symbol=comp_id.comp_name;\n    before::NothingSymbol=nothing,\n    after::NothingSymbol=nothing,\n    reconnect::Bool=true\n)\n\nReplace the component with name comp_name in model m with the component comp_id using the same name.  The component is added in the same position as the old component, unless one of the keywords before or after is specified. The component is added with the same first and last values, unless the keywords first or last are specified. Optional boolean argument reconnect with default value true indicates whether the existing parameter connections should be maintained in the new component.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mimi.set_dimension!","page":"Reference","title":"Mimi.set_dimension!","text":"set_dimension!(ccd::CompositeComponentDef, name::Symbol, keys::Union{Int, Vector, Tuple, AbstractRange})\n\nSet the values of ccd dimension name to integers 1 through count, if keys is an integer; or to the values in the vector or range if keys is either of those types.\n\n\n\n\n\nset_dimension!(m::Model, name::Symbol, keys::Union{Vector, Tuple, AbstractRange})\n\nSet the values of m dimension name to integers 1 through count, if keysis an integer; or to the values in the vector or range ifkeys`` is either of those types.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mimi.set_leftover_params!","page":"Reference","title":"Mimi.set_leftover_params!","text":"set_leftover_params!(m::Model, parameters::Dict)\n\nSet all of the parameters in model m that don't have a value and are not connected to some other component to a value from a dictionary parameters. This method assumes the dictionary keys are strings that match the names of unset parameters in the model.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mimi.set_param!","page":"Reference","title":"Mimi.set_param!","text":"set_param!(md::ModelDef, comp_name::Symbol,\n           value_dict::Dict{Symbol, Any}, param_names)\n\nCall set_param!() for each name in param_names, retrieving the corresponding value from value_dict[param_name].\n\n\n\n\n\nset_param!(md::ModelDef, comp_path::ComponentPath, param_name::Symbol,\n           value_dict::Dict{Symbol, Any}, dims=nothing)\n\nCall set_param!() with param_name and a value dict in which value_dict[param_name] references the value of parameter param_name.\n\n\n\n\n\nset_param!(md::ModelDef, param_name::Symbol, value, dims=nothing)\n\nSet the value of a parameter exposed in md by following the ParameterDefReference. If not found in the local namespace, import it if there is only one such parameter in md'same children, and it is not yet bound. Otherwise raise an error.\n\nThe value can by a scalar, an array, or a NamedAray. Optional argument 'dims' is a list of the dimension names of the provided data, and will be used to check that they match the model's index labels.\n\n\n\n\n\nset_param!(ref::ComponentReference, name::Symbol, value)\n\nSet a component parameter as set_param!(reference, name, value).\n\n\n\n\n\nset_param!(m::Model, comp_name::Symbol, name::Symbol, value, dims=nothing)\n\nSet the parameter of a component comp_name in a model m to a given value. The value can by a scalar, an array, or a NamedAray. Optional argument 'dims' is a list of the dimension names of the provided data, and will be used to check that they match the model's index labels.\n\n\n\n\n\nset_param!(m::Model, path::AbstractString, param_name::Symbol, value, dims=nothing)\n\nSet a parameter for a component with the given relative path (as a string), in which \"/x\" means the component with name :x beneath m.md. If the path does not begin with \"/\", it is treated as relative to m.md, which at the top of the hierarchy, produces the same result as starting with \"/\".\n\n\n\n\n\nset_param!(m::Model, path::AbstractString, value, dims=nothing)\n\nSimilar to above but param_name appears in path after a colon delimiter.\n\n\n\n\n\nset_param!(m::Model, param_name::Symbol, value, dims=nothing)\n\nSet the value of a parameter exposed in the ModelDef (m.md).\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mimi.TimestepIndex","page":"Reference","title":"Mimi.TimestepIndex","text":"TimestepIndex\n\nA user-facing type used to index into a TimestepArray in run_timestep functions, containing an Int index that indicates the position in the array in terms of timesteps.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Mimi.TimestepValue","page":"Reference","title":"Mimi.TimestepValue","text":"TimestepValue\n\nA user-facing type used to index into a TimestepArray in run_timestep functions, containing a value of the same Type as the times in the TimstepArray which is used to index into the array at that position, with an optional Int offset in terms of timesteps.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Mimi.variable_dimensions","page":"Reference","title":"Mimi.variable_dimensions","text":"variable_dimensions(obj::AbstractCompositeComponentDef, comp_path::ComponentPath, var_name::Symbol)\n\nReturn the names of the dimensions of variable var_name exposed in the composite component definition indicated byobj along the component path comp_path. The comp_path is of type Mimi.ComponentPath with the single field being an NTuple of symbols describing the relative (to a composite) or absolute (relative to ModelDef) path through composite nodes to specific composite or leaf node.\n\n\n\n\n\nvariable_dimensions(obj::AbstractCompositeComponentDef, comp::Symbol, var_name::Symbol)\n\nReturn the names of the dimensions of variable var_name exposed in the composite component definition indicated by obj for the component comp, which exists in a flat model.\n\n\n\n\n\nvariable_dimensions(obj::AbstractCompositeComponentDef, comp::Symbol, var_name::Symbol)\n\nReturn the names of the dimensions of variable var_name exposed in the composite component definition indicated by obj along the component path comp_path. The comp_path is a tuple of symbols describing the relative (to a composite) or absolute (relative to ModelDef) path through composite nodes to specific composite or leaf node.\n\n\n\n\n\nvariable_dimensions(obj::AbstractComponentDef, name::Symbol)\n\nReturn the names of the dimensions of variable name exposed in the component definition indicated by obj.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mimi.variable_names","page":"Reference","title":"Mimi.variable_names","text":"variable_names(md::AbstractCompositeComponentDef, comp_name::Symbol)\n\nReturn a list of all variable names for a given component comp_name in a model def md.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mimi.update_param!","page":"Reference","title":"Mimi.update_param!","text":"update_param!(obj::AbstractCompositeComponentDef, name::Symbol, value; update_timesteps = false)\n\nUpdate the value of an external model parameter in composite obj, referenced by name. Optional boolean argument update_timesteps with default value false indicates whether to update the time keys associated with the parameter values to match the model's time index.\n\n\n\n\n\nupdate_param!(m::Model, name::Symbol, value; update_timesteps = false)\n\nUpdate the value of an external model parameter in model m, referenced by name. Optional boolean argument update_timesteps with default value false indicates whether to update the time keys associated with the parameter values to match the model's time index.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mimi.update_params!","page":"Reference","title":"Mimi.update_params!","text":"update_params!(obj::AbstractCompositeComponentDef, parameters::Dict{T, Any};\n               update_timesteps = false) where T\n\nFor each (k, v) in the provided parameters dictionary, update_param! is called to update the external parameter by name k to value v, with optional Boolean argument update_timesteps. Each key k must be a symbol or convert to a symbol matching the name of an external parameter that already exists in the component definition.\n\n\n\n\n\nupdate_params!(m::Model, parameters::Dict{T, Any}; update_timesteps = false) where T\n\nFor each (k, v) in the provided parameters dictionary, update_param!` is called to update the external parameter by name k to value v, with optional Boolean argument update_timesteps. Each key k must be a symbol or convert to a symbol matching the name of an external parameter that already exists in the model definition.\n\n\n\n\n\n","category":"function"},{"location":"integrationguide/#Integration-Guide:-Porting-Mimi-Models-from-v0.4.0-to-v0.5.0-1","page":"Integration Guide: Port to v0.5.0","title":"Integration Guide:  Porting Mimi Models from v0.4.0 to v0.5.0","text":"","category":"section"},{"location":"integrationguide/#Overview-1","page":"Integration Guide: Port to v0.5.0","title":"Overview","text":"","category":"section"},{"location":"integrationguide/#","page":"Integration Guide: Port to v0.5.0","title":"Integration Guide: Port to v0.5.0","text":"The release of Mimi v0.5.0 is a breaking release, necessitating the adaptation of existing models' syntax and structure in order for those models to run on this new version.  This guide provides an overview of the steps required to get most models using the v0.4.0 API working with v0.5.0.  It is not a comprehensive review of all changes and new functionalities, but a guide to the minimum steps required to port old models between versions.  For complete information on the new version and its functionalities, see the full documentation.","category":"page"},{"location":"integrationguide/#","page":"Integration Guide: Port to v0.5.0","title":"Integration Guide: Port to v0.5.0","text":"This guide is organized into six main sections, each descripting an independent set of changes that can be undertaken in any order desired.  For clarity, these sections echo the organization of the userguide.","category":"page"},{"location":"integrationguide/#","page":"Integration Guide: Port to v0.5.0","title":"Integration Guide: Port to v0.5.0","text":"Defining components\nConstructing a model\nRunning the model\nAccessing results\nPlotting\nAdvanced topics","category":"page"},{"location":"integrationguide/#","page":"Integration Guide: Port to v0.5.0","title":"Integration Guide: Port to v0.5.0","text":"A Note on Function Naming: There has been a general overhaul on function names, especially those in the explicity user-facing API, to be consistent with Julia conventions and the conventions of this Package.  These can be briefly summarized as follows:","category":"page"},{"location":"integrationguide/#","page":"Integration Guide: Port to v0.5.0","title":"Integration Guide: Port to v0.5.0","text":"use _ for readability\nappend all functions with side-effects, i.e., non-pure functions that return a value but leave all else unchanged with a !\nthe commonly used terms component, variable, and parameter are shortened to comp, var, and param\nfunctions that act upon a component, variable, or parameter are often written in the form [action]_[comp/var/param]","category":"page"},{"location":"integrationguide/#Defining-Components-1","page":"Integration Guide: Port to v0.5.0","title":"Defining Components","text":"","category":"section"},{"location":"integrationguide/#","page":"Integration Guide: Port to v0.5.0","title":"Integration Guide: Port to v0.5.0","text":"The run_timestep function is now contained by the @defcomp macro, and takes the parameters p, v, d, t, referring to Parameters, Variables, and Dimensions of the component you defined.  The fourth argument is an AbstractTimestep, i.e., either a FixedTimestep or a VariableTimestep.  Similarly, the optional init function is also contained by @defcomp, and takes the parameters p, v, d.  Thus, as described in the user guide, defining a single component is now done as follows:","category":"page"},{"location":"integrationguide/#","page":"Integration Guide: Port to v0.5.0","title":"Integration Guide: Port to v0.5.0","text":"In this version, the fourth argument (t below) can no longer always be used simply as an Int. Indexing with t is still permitted, but special care must be taken when comparing t with conditionals or using it in arithmatic expressions.  The full API as described later in this document in Advanced Topics:  Timesteps and available functions.  Since differential equations are commonly used as the basis for these models' equations, the most commonly needed change will be changing if t == 1 to if is_first(t)","category":"page"},{"location":"integrationguide/#","page":"Integration Guide: Port to v0.5.0","title":"Integration Guide: Port to v0.5.0","text":"@defcomp component1 begin\n\n    # First define the state this component will hold\n    savingsrate = Parameter()\n\n    # Second, define the (optional) init function for the component\n    function init(p, v, d)\n    end\n\n    # Third, define the run_timestep function for the component\n    function run_timestep(p, v, d, t)\n    end\n\nend","category":"page"},{"location":"integrationguide/#Constructing-a-Model-1","page":"Integration Guide: Port to v0.5.0","title":"Constructing a Model","text":"","category":"section"},{"location":"integrationguide/#","page":"Integration Guide: Port to v0.5.0","title":"Integration Guide: Port to v0.5.0","text":"In an effort to standardize the function naming protocol within Mimi, and to streamline it with the Julia convention, several function names have been changed.  The table below lists a subset of these changes, focused on the exported API functions most commonly used in model construction.  ","category":"page"},{"location":"integrationguide/#","page":"Integration Guide: Port to v0.5.0","title":"Integration Guide: Port to v0.5.0","text":"Old Syntax New Syntax\naddcomponent! add_comp!\nconnectparameter connect_param!\nsetleftoverparameters set_leftover_params!\nsetparameter set_param!\nadddimension add_dimension!\nsetindex set_dimension!","category":"page"},{"location":"integrationguide/#","page":"Integration Guide: Port to v0.5.0","title":"Integration Guide: Port to v0.5.0","text":"Changes to various optional keyword arguments:","category":"page"},{"location":"integrationguide/#","page":"Integration Guide: Port to v0.5.0","title":"Integration Guide: Port to v0.5.0","text":"add_comp!:  Through Mimi v0.9.4, the optional keyword arguments first and last could be used to specify times for components that do not run for the full length of the model, like this: add_comp!(mymodel, ComponentC; first=2010, last=2100). This functionality is currently disabled, and all components must run for the full length of the model's time dimension. This functionality may be re-implemented in a later version of Mimi.","category":"page"},{"location":"integrationguide/#Running-a-Model-1","page":"Integration Guide: Port to v0.5.0","title":"Running a Model","text":"","category":"section"},{"location":"integrationguide/#Accessing-Results-1","page":"Integration Guide: Port to v0.5.0","title":"Accessing Results","text":"","category":"section"},{"location":"integrationguide/#Plotting-and-the-Explorer-UI-1","page":"Integration Guide: Port to v0.5.0","title":"Plotting and the Explorer UI","text":"","category":"section"},{"location":"integrationguide/#","page":"Integration Guide: Port to v0.5.0","title":"Integration Guide: Port to v0.5.0","text":"This release of Mimi does not include the plotting functionality previously offered by Mimi.  While the previous files are still included, the functions are not exported as efforts are made to simplify and improve the plotting associated with Mimi.  ","category":"page"},{"location":"integrationguide/#","page":"Integration Guide: Port to v0.5.0","title":"Integration Guide: Port to v0.5.0","text":"The new version does, however, include a new UI tool that can be used to visualize model results.  This explore function is described in the User Guide under Advanced Topics.","category":"page"},{"location":"integrationguide/#Advanced-Topics-1","page":"Integration Guide: Port to v0.5.0","title":"Advanced Topics","text":"","category":"section"},{"location":"integrationguide/#Timesteps-and-available-functions-1","page":"Integration Guide: Port to v0.5.0","title":"Timesteps and available functions","text":"","category":"section"},{"location":"integrationguide/#","page":"Integration Guide: Port to v0.5.0","title":"Integration Guide: Port to v0.5.0","text":"As previously mentioned, some relevant function names have changed.  These changes were made to eliminate ambiguity.  For example, the new naming clarifies that is_last returns whether the timestep is on the last valid period to be run, not whether it has run through that period already.  This check can still be achieved with is_finished, which retains its name and function.  Below is a subset of such changes related to timesteps and available functions.","category":"page"},{"location":"integrationguide/#","page":"Integration Guide: Port to v0.5.0","title":"Integration Guide: Port to v0.5.0","text":"Old Syntax New Syntax\nisstart is_first\nisstop is_last","category":"page"},{"location":"integrationguide/#","page":"Integration Guide: Port to v0.5.0","title":"Integration Guide: Port to v0.5.0","text":"As mentioned in earlier in this document, the fourth argument in run_timestep is an AbstractTimestep i.e. a FixedTimestep or a VariableTimestep and is a type defined within Mimi in \"src/time.jl\".  In this version, the fourth argument (t below) can no longer always be used simply as an Int. Defining the AbstractTimestep object as t, indexing with t is still permitted, but special care must be taken when comparing t with conditionals or using it in arithmatic expressions.  Since differential equations are commonly used as the basis for these models' equations, the most commonly needed change will be changing if t == 1 to if is_first(t).","category":"page"},{"location":"integrationguide/#","page":"Integration Guide: Port to v0.5.0","title":"Integration Guide: Port to v0.5.0","text":"The full API:","category":"page"},{"location":"integrationguide/#","page":"Integration Guide: Port to v0.5.0","title":"Integration Guide: Port to v0.5.0","text":"you may index into a variable or parameter with [t] or [t +/- x] as usual\nto access the time value of t (currently a year) as a Number, use gettime(t)\nuseful functions for commonly used conditionals are is_first(t) and is_last(t)\nto access the index value of t as a Number representing the position in the time array, use t.t.  Users are encouraged to avoid this access, and instead use the options listed above or a separate counter variable. each time the function gets called.  ","category":"page"},{"location":"integrationguide/#Parameter-connections-between-different-length-components-1","page":"Integration Guide: Port to v0.5.0","title":"Parameter connections between different length components","text":"","category":"section"},{"location":"integrationguide/#More-on-parameter-indices-1","page":"Integration Guide: Port to v0.5.0","title":"More on parameter indices","text":"","category":"section"},{"location":"integrationguide/#Updating-an-external-parameter-1","page":"Integration Guide: Port to v0.5.0","title":"Updating an external parameter","text":"","category":"section"},{"location":"integrationguide/#","page":"Integration Guide: Port to v0.5.0","title":"Integration Guide: Port to v0.5.0","text":"To update an external parameter, use the functions update_param! and udpate_params! (previously known as update_external_parameter and update_external_parameters, respectively.)  Their calling signatures are:","category":"page"},{"location":"integrationguide/#","page":"Integration Guide: Port to v0.5.0","title":"Integration Guide: Port to v0.5.0","text":"update_params!(md::ModelDef, parameters::Dict; update_timesteps = false)\nupdate_param!(md::ModelDef, name::Symbol, value; update_timesteps = false)","category":"page"},{"location":"integrationguide/#","page":"Integration Guide: Port to v0.5.0","title":"Integration Guide: Port to v0.5.0","text":"For external parameters with a :time dimension, passing update_timesteps=true indicates that the time keys (i.e., year labels) should also be updated in addition to updating the parameter values.","category":"page"},{"location":"integrationguide/#Setting-parameters-with-a-dictionary-1","page":"Integration Guide: Port to v0.5.0","title":"Setting parameters with a dictionary","text":"","category":"section"},{"location":"integrationguide/#","page":"Integration Guide: Port to v0.5.0","title":"Integration Guide: Port to v0.5.0","text":"The function set_leftover_params! replaces the function setleftoverparameters.","category":"page"},{"location":"integrationguide/#Using-NamedArrays-for-setting-parameters-1","page":"Integration Guide: Port to v0.5.0","title":"Using NamedArrays for setting parameters","text":"","category":"section"},{"location":"integrationguide/#The-internal-'build'-function-and-model-instances-1","page":"Integration Guide: Port to v0.5.0","title":"The internal 'build' function and model instances","text":"","category":"section"},{"location":"internals/dimension_mapping/#Cross-model-Connectors-1","page":"Cross-model Connectors","title":"Cross-model Connectors","text":"","category":"section"},{"location":"internals/dimension_mapping/#Thoughts-on-matching-indices-across-models-that-may-have-different-timesteps,-regional-aggregations,-etc.-1","page":"Cross-model Connectors","title":"Thoughts on matching indices across models that may have different timesteps, regional aggregations, etc.","text":"","category":"section"},{"location":"internals/dimension_mapping/#","page":"Cross-model Connectors","title":"Cross-model Connectors","text":"The basic idea is to allow a keyword arg to connect_param!() to identify a connector  component that performs the mapping between disparate dimension definitions.","category":"page"},{"location":"internals/dimension_mapping/#","page":"Cross-model Connectors","title":"Cross-model Connectors","text":"We could provide a couple more \"standard\" connectors","category":"page"},{"location":"internals/dimension_mapping/#","page":"Cross-model Connectors","title":"Cross-model Connectors","text":"Time\nGet most recent value from before the receiving model's current timestep\nGet the sum of values between the receiving model's current and prior timestep\nRegions\nPass in a region map that defines transformations between two regional definitions\nOperators can include\nWeighted Avg:  new region value = avg(parameter[regions] .* weight[regions])\nWeighted sum: new region value = sum(parameter[regions] .* weight[regions])\nWeights can be the value of some parameter, e.g., population, area, GDP\nDisaggregation can be handled similarly\nnew sub-region value = parameter[region] * weight[region]","category":"page"},{"location":"internals/dimension_mapping/#","page":"Cross-model Connectors","title":"Cross-model Connectors","text":"We can create macro to define connector components that perform these dimension adjustments. We would define a new macro that simplifies creation of a @defcomp of a given name  that can be specified in connect_param! to perform the defined mapping.","category":"page"},{"location":"internals/dimension_mapping/#","page":"Cross-model Connectors","title":"Cross-model Connectors","text":"To map across both time and regions, we could implement a pair of connector components that might look like the following, which would be called for each timestep t in  the receiving component:","category":"page"},{"location":"internals/dimension_mapping/#","page":"Cross-model Connectors","title":"Cross-model Connectors","text":"# This component would run first, mapping emissions to the new time boundaries\n@defcomp time_mapper begin\n    src = Variable(index=[m1.time, m1.regions])\n    dst = Parameter(index=[m2.time, m1.regions])   # uses src model's regions\n\n    # Simple time adapter that just sums any values produced since the prior \n    # timestep, without performing any allocation or interpolation.\n    function run_timestep(p, v, d, t)\n        for r in d.regions\n            values = [v.src[tsrc, r] for tsrc in m1.time if t - 1 < tsrc <= t]\n            p.dst[t, r] = sum(values)\n        end\n    end\nend\n\n# This component would run next, mapping emissions to the new regional boundaries\n@defcomp region_mapper begin\n    # Source here would be the emissions_time_mapper component\n    src  = Variable(index=[time, m1.regions])\n    sgdp = Variable(index=[time, m1.regions])\n    dst  = Parameter(index=[time, m2.regions])\n    dgdp = Parameter(index=[time, m2.regions])\n\n    function run_timestep(p, v, d, t)\n        # Aggregate to region :OthNAmer by summing values of src over :Mex and :Can\n        p.dst[t, :OthNAmer] = sum(v.src[t, [:Mex, :Can]])\n\n        # Disaggregate :SAmer into :Bra and :OthSAmer by fraction of GDP\n        p.dst[:Bra, t]      = v.src[t, :SAmer] * p.dgdp[t, :Bra]      / v.sgdp[t, :SAmer]\n        p.dst[:OthSAmer, t] = v.src[t, :SAmer] * p.dgdp[t, :OthSAmer] / v.sgdp[t, :SAmer]\n    end\nend","category":"page"},{"location":"internals/dimension_mapping/#","page":"Cross-model Connectors","title":"Cross-model Connectors","text":"Notes:","category":"page"},{"location":"internals/dimension_mapping/#","page":"Cross-model Connectors","title":"Cross-model Connectors","text":"Specifying index values by symbol as we do currently is inadequate when these can  refer to different models. Probably need to support module specification, e.g.,  dice2010.time.\nWhen combining components with different time dimensions, we should run the model on the union of all time dimension definitions. For example, if model 1 is defined on 10-yr timesteps (2010, 2020, ...) and model 2 is defined on 4-yr timesteps (2010, 2014, 2018, ...), the combined time dimension for the models would be (2010, 2014, 2018, 2020, 2022, ... ).\nThe main run_timestep would iterate over the combined time dimension, calling each component's run_timestep only for timesteps defined for that component.\nIf  src has 5-yr timesteps and dst has 10-yr timesteps, emissions in dst  time tdst would sum emissions from src time tsrc and tsrc - 1.  More generally, accumulating into dst in timestep tdst would sum values from src timesteps tsrc where  tdst - 1 < tsrc <= tdst. For dependencies on the  prior timestep, it would sum values where dst[t-2] < tsrc <= dst[t-1].\nRegional alignment may be combined with timestep alignment. In this case, time should be aligned first, since components are run on time boundaries. Then regional alignment can be handled based on time-aligned values.\nIn some cases, we will want to allocate values from a source model across multiple timesteps in the destination model. For example, if model src is defined on 10-yr timesteps (2010, 2020, 2030, ...) and model dst is defined on 5-yr timesteps, (2010, 2015, 2020, 2025, ...) we might allocate half of the 2010-2010  value from src in 2010-2020 to each of the dst periods 2010-2015 and 2015-2020. This allocation would be appropriate for flow parameters such as emissions. For stock  parameters, e.g., CO<sub>2</sub> concentration, we would want to interpolate between src timestep values.\nThis suggests a need for metadata on parameters indicating whether they are of the stock or flow variety.\nThe problem with this is that is requires knowing a future value to allocate or interpolate between a past value before the dst model's timestep t, and the subsequent value in occurring after t. This would require running the dst model one or more timesteps lagged.","category":"page"},{"location":"userguide/#User-Guide-1","page":"User Guide","title":"User Guide","text":"","category":"section"},{"location":"userguide/#Overview-1","page":"User Guide","title":"Overview","text":"","category":"section"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"See the Tutorials for in-depth examples of Mimi's functionality.","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"This guide is organized into six main sections for understanding how to use Mimi.","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"Defining components\nConstructing a model\nRunning the model\nAccessing results\nPlotting and the Explorer UI\nSensitivity Analysis\nAdvanced topics","category":"page"},{"location":"userguide/#Defining-Components-1","page":"User Guide","title":"Defining Components","text":"","category":"section"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"Any Mimi model is made up of at least one component, so before you construct a model, you need to create your components.","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"A component can have any number of parameters and variables. Parameters are data values that will be provided to the component as input, and variables are values that the component will calculate in the run_timestep function when the model is run. The index of a parameter or variable determines the number of dimensions that parameter or variable has. They can be scalar values and have no index, such as parameter 'c' in the example below. They can be one-dimensional, such as the variable 'A' and the parameters 'd' and 'f' below. They can be two dimensional such as variable 'B' and parameter 'e' below. Note that any index other than 'time' must be declared at the top of the component, as shown by regions = Index() below.","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"The user must define a run_timestep function for each component. ","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"We define a component in the following way:","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"using Mimi\n\n@defcomp MyComponentName begin\n  regions = Index()\n\n  A = Variable(index = [time])\n  B = Variable(index = [time, regions])\n\n  c = Parameter()\n  d = Parameter(index = [time])\n  e = Parameter(index = [time, regions])\n  f = Parameter(index = [regions])\n\n  function run_timestep(p, v, d, t)\n    v.A[t] = p.c + p.d[t]\n    for r in d.regions\n      v.B[t, r] = p.f[r] * p.e[t, r]\n    end\n  end\nend","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"The run_timestep function is responsible for calculating values for each variable in that component.  Note that the component state (defined by the first three arguments) has fields for the Parameters, Variables, and Dimensions of the component you defined. You can access each parameter, variable, or dimension using dot notation as shown above.  The fourth argument is an AbstractTimestep, i.e., either a FixedTimestep or a VariableTimestep, which represents which timestep the model is at.","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"The API for using the fourth argument, represented as t in this explanation, is described in this document under Advanced Topics:  Timesteps and available functions. ","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"To access the data in a parameter or to assign a value to a variable, you must use the appropriate index or indices (in this example, either the Timestep or region or both).","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"By default, all parameters and variables defined in the @defcomp will be allocated storage as scalars or Arrays of type Float64. For a description of other data type options, see Advanced Topics: DataType specification of Parameters and Variables.","category":"page"},{"location":"userguide/#Constructing-a-Model-1","page":"User Guide","title":"Constructing a Model","text":"","category":"section"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"The first step in constructing a model is to set the values for each index of the model. Below is an example for setting the 'time' and 'regions' indexes. The time index expects either a numerical range or an array of numbers.  If a single value is provided, say '100', then that index will be set from 1 to 100. Other indexes can have values of any type.","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"using Mimi\n\nm = Model()\nset_dimension!(m, :time, 1850:2200)\nset_dimension!(m, :regions, [\"USA\", \"EU\", \"LATAM\"])","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"A Note on Time Indexes: It is important to note that the values used for the time index are the start times of the timesteps.  If the range or array of time values has a uniform timestep length, the model will run through the last year of the range with a last timestep period length consistent with the other timesteps.  If the time values are provided as an array with non-uniform timestep lengths, the model will run through the last year in the array with a last timestep period length assumed to be one. ","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"The next step is to add components to the model. This is done by the following syntax:","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"add_comp!(m, ComponentA, :GDP)\nadd_comp!(m, ComponentB; first=2010)\nadd_comp!(m, ComponentC; first=2010, last=2100)","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"The first argument to add_comp! is the model, the second is the name of the ComponentId defined by @defcomp. If an optional third symbol is provided (as in the first line above), this will be used as the name of the component in this model. This allows you to add multiple versions of the same component to a model, with different names.","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"The next step is to set the values for all the parameters in the components. Parameters can either have their values assigned from external data, or they can internally connect to the values from variables in other components of the model.","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"To make an external connection, the syntax is as follows:","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"set_param!(m, :ComponentName, :ParameterName, 0.8) # a scalar parameter\nset_param!(m, :ComponentName, :ParameterName2, rand(351, 3)) # a two-dimensional parameter","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"To make an internal connection, the syntax is as follows.  ","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"connect_param!(m, :TargetComponent=>:ParameterName, :SourceComponent=>:VariableName)\nconnect_param!(m, :TargetComponent=>:ParameterName, :SourceComponent=>:VariableName)","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"If you wish to delete a component that has already been added, do the following:","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"delete!(m, :ComponentName)","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"This will delete the component from the model and remove any existing connections it had. Thus if a different component was previously connected to this component, you will need to connect its parameter(s) to something else.","category":"page"},{"location":"userguide/#Running-a-Model-1","page":"User Guide","title":"Running a Model","text":"","category":"section"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"After all components have been added to your model and all parameters have been connected to either external values or internally to another component, then the model is ready to be run. Note: at each timestep, the model will run the components in the order you added them. So if one component is going to rely on the value of another component, then the user must add them to the model in the appropriate order.","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"run(m)","category":"page"},{"location":"userguide/#Accessing-Results-1","page":"User Guide","title":"Accessing Results","text":"","category":"section"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"After a model has been run, you can access the results (the calculated variable values in each component) in a few different ways.","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"You can use the getindex syntax as follows:","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"m[:ComponentName, :VariableName] # returns the whole array of values\nm[:ComponentName, :VariableName][100] # returns just the 100th value","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"Indexing into a model with the name of the component and variable will return an array with values from each timestep. You can index into this array to get one value (as in the second line, which returns just the 100th value). Note that if the requested variable is two-dimensional, then a 2-D array will be returned.","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"You can also get data in the form of a dataframe, which will display the corresponding index labels rather than just a raw array. The syntax for this is:","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"getdataframe(m, :ComponentName=>:Variable) # request one variable from one component\ngetdataframe(m, :ComponentName=>(:Variable1, :Variable2)) # request multiple variables from the same component\ngetdataframe(m, :Component1=>:Var1, :Component2=>:Var2) # request variables from different components","category":"page"},{"location":"userguide/#Plotting-and-the-Explorer-UI-1","page":"User Guide","title":"Plotting and the Explorer UI","text":"","category":"section"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"Mimi provides support for plotting using VegaLite and VegaLite.jl within the Mimi Explorer UI and Mimi.plot function, and the LightGraphs and MetaGraphs for the plot_comp_graph function described below.","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"In order to view a DAG representing the component ordering and relationships, use the plot_comp_graph function to view a plot and optionally save it to a file.","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"run(m)\nplot_comp_graph(m; filename = \"MyFilePath.png\")","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"(Image: Plot Component Graph Example)","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"Other plotting support is provided by the Explorer UI, rooted in VegaLite.  The explore function allows the user to view and explore the variables and parameters of a model run.  The explorer can be used in two primary ways.","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"In order to invoke the explorer UI and explore all of the variables and parameters in a model, simply call the function explore with the model run as the required argument, and a window title as an optional keyword argument, as shown below.  This will produce a new browser window containing a selectable list of parameters and variables, organized by component, each of which produces a graphic.  The exception here being that if the parameter or variable is a single scalar value, the value will appear alongside the name in the left-hand list.","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"run(m)\nexplore(m, title = \"run1 results\")","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"(Image: Explorer Model Example)","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"Alternatively, in order to view just one parameter or variable, call the (unexported) function Mimi.plot as below to return a plot object and automatically display the plot in a viewer, assuming Mimi.plot is the last command executed.  Note that plot is not exported in order to avoid namespace conflicts, but a user may import it if desired. This call will return the type VegaLite.VLSpec, which you may interact with using the API described in the VegaLite.jl documentation.  For example, VegaLite.jl plots can be saved as PNG, SVG, PDF and EPS files. You may save a plot using the save function. Note that while explore(m) returns interactive plots for line graphs, Mimi.plot(m, :foo, :bar) will return only static plots. ","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"using VegaLite\nrun(m)\np = Mimi.plot(m, :ComponentName, :ParameterName)\nsave(\"figure.svg\", p)","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"(Image: Plot Model Example)","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"These two functions, explore and plot also have methods applicable to the sensitivity analysis support described in the next section. Details can be found in the linked internals documentation as well as Tutorial 4: Sensitivity Analysis (SA) Support.","category":"page"},{"location":"userguide/#Sensitivity-Analysis-(SA)-Support-1","page":"User Guide","title":"Sensitivity Analysis (SA) Support","text":"","category":"section"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"Mimi includes a host of routines which support running various sensitivity analysis methods on Mimi models. The best current documentation on the SA API is the internals documentation here, which provides a working, although informal, description of the SA support of Mimi. This file should be used in conjunction with the examples in Tutorial 4: Sensitivity Analysis (SA) Support, since the documentation covers more advanced options such as non-stochastic scenarios and running multiple models, which are not yet included in this tutorial.","category":"page"},{"location":"userguide/#Advanced-Topics-1","page":"User Guide","title":"Advanced Topics","text":"","category":"section"},{"location":"userguide/#Timesteps-and-available-functions-1","page":"User Guide","title":"Timesteps and available functions","text":"","category":"section"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"An AbstractTimestep i.e. a FixedTimestep or a VariableTimestep is a type defined within Mimi in \"src/time.jl\". It is used to represent and keep track of time indices when running a model.","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"In the run_timestep functions which the user defines, it may be useful to use any of the following functions, where t is an AbstractTimestep object:","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"is_first(t) # returns true or false, true if t is the first timestep to be run\nis_last(t) # returns true or false, true if t is the last timestep to be run\ngettime(t) # returns the year represented by timestep t","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"There are also two helper types TimestepValue and TimestepIndex that can be used with comparison operators (==, <, and >) to check whether an AbstractTimestep t during the run_timestep function corresponds with a certain year or index number. For example:","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"if t > TimestepValue(2020)\n  # run this code only for timesteps after the year 2020\nend\n\nif t == TimestepIndex(3)\n  # run this code only during the third timestep\nend","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"See below for further discussion of the TimestepValue and TimestepIndex objects and how they should be used.","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"The API details for AbstractTimestep object t are as follows:","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"you may index into a variable or parameter with [t] or [t +/- x] as usual\nto access the time value of t (currently a year) as a Number, use gettime(t)\nuseful functions for commonly used conditionals are is_first(t) and is_last(t)\nto access the index value of t as a Number representing the position in the time array, use t.t.  Users are encouraged to avoid this access, and instead use comparisons with TimestepIndex objects to check if an AbstractTimestep t corresponds with a specific index number, as described above.","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"Indexing into a variable or parameter's time dimension with an Integer is deprecated and will soon error. Instead, users should take advantage of the TimestepIndex and TimestepValue types. For examples we will refer back to our component definition above, and repeated below.","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"@defcomp MyComponentName begin\n  regions = Index()\n\n  A = Variable(index = [time])\n  B = Variable(index = [time, regions])\n\n  c = Parameter()\n  d = Parameter(index = [time])\n  e = Parameter(index = [time, regions])\n  f = Parameter(index = [regions])\n\n  function run_timestep(p, v, d, t)\n    v.A[t] = p.c + p.d[t]\n    for r in d.regions\n      v.B[t, r] = p.f[r] * p.e[t, r]\n    end\n  end\n\nend","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"TimestepIndex has one field, index, which refers to the absolute index in the parameter or variable array's time dimension. Thus, constructing a TimestepIndex is done by simply writing TimestepIndex(index::Int). Looking back at our original component example one could modify the first line of run_timestep to always refer to the first timestep of p.d with the following. One may index into the time dimension with a single TimestepIndex, or an Array of them.","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"v.A[t] = p.c + p.d[TimestepIndex(1)]","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"TimestepValue has two fields, value and offset, referring to the value within the time dimension and an optional offset from that value. Thus, constructing a TimestepValue is done either by writing TimestepValue(value), with an implied offset of 0, or TimestepValue(value, offset = i::Int), with an explicit offset of i. One may index into the time dimension with a single TimestepValue, or an Array of them. For example, you can use a TimestepValue to keep track of a baseline year.","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"v.A[t] = p.c + p.d[TimestepValue(2000)]","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"You may also use shorthand to create arrays of TimestepIndex using Colon syntax.","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"TimestepIndex(1):TimestepIndex(10) # implicit step size of 1\nTimestepIndex(1):2:TimestepIndex(10) # explicit step of type Int ","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"Both TimestepIndex and TimestepArray have methods to support addition and subtraction of integers.  Note that the addition or subtraction is relative to the definition of the time dimension, so while TimestepIndex(1) + 1 == TimestepIndex(2), TimestepValue(2000) + 1 could be equivalent to TimestepValue(2001) if 2001 is the next year in the time dimension, or TimestepValue(2005) if the array has a step size of 5. Hence adding or subtracting is relative to the definition of the time dimension. ","category":"page"},{"location":"userguide/#DataType-specification-of-Parameters-and-Variables-1","page":"User Guide","title":"DataType specification of Parameters and Variables","text":"","category":"section"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"By default, the Parameters and Variables defined by a user will be allocated storage arrays of type Float64 when a model is constructed. This default \"number_type\" can be overriden when a model is created, with the following syntax:","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"m = Model(Int64)    # creates a model with default number type Int64","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"But you can also specify individual Parameters or Variables to have different data types with the following syntax in a @defcomp macro:","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"@defcomp example begin\n  p1 = Parameter{Bool}()                         # ScalarModelParameter that is a Bool\n  p2 = Parameter{Bool}(index = [regions])        # ArrayModelParameter with one dimension whose eltype is Bool\n  p3 = Parameter{Matrix{Int64}}()                # ScalarModelParameter that is a Matrix of Integers\n  p4 = Parameter{Int64}(index = [time, regions]) # ArrayModelParameter with two dimensions whose eltype is Int64\nend","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"If there are \"index\"s listed in the Parameter definition, then it will be an ArrayModelParameter whose eltype is the type specified in the curly brackets. If there are no \"index\"s listed, then the type specified in the curly brackets is the actual type of the parameter value, and it will be represent by Mimi as a ScalarModelParameter.","category":"page"},{"location":"userguide/#Parameter-connections-between-different-length-components-1","page":"User Guide","title":"Parameter connections between different length components","text":"","category":"section"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"As mentioned earlier, it is possible for some components to start later or end sooner than the full length of the model. This presents potential complications for connecting their parameters. If you are setting the parameters to external values, then the provided values just need to be the right size for that component's parameter. If you are making an internal connection, this can happen in one of two ways:","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"A shorter component is connected to a longer component. In this case, nothing additional needs to happen. The shorter component will pick up the correct values it needs from the longer component.\nA longer component is connected to a shorter component. In this case, the shorter component will not have enough values to supply to the longer component. In order to make this connection, the user must also provide an array of backup data for the parameter to default to when the shorter component does not have values to give. Do this in the following way:","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"backup = rand(100) # data array of the proper size\nconnect_param!(m, :LongComponent=>:ParameterName, :ShortComponent=>:VariableName, backup)","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"Note: for now, to avoid discrepancy with timing and alignment, the backup data must be the length of the whole component's first to last time, even though it will only be used for values not found in the shorter component.","category":"page"},{"location":"userguide/#More-on-parameter-indices-1","page":"User Guide","title":"More on parameter indices","text":"","category":"section"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"As mentioned above, a parameter can have no index (a scalar), or one or multiple of the model's indexes. A parameter can also have an index specified in the following ways:","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"@defcomp MyComponent begin\n  p1 = Parameter(index=[4]) # an array of length 4\n  p2 = Parameter{Array{Float64, 2}}() # a two dimensional array of unspecified length\nend","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"In both of these cases, the parameter's values are stored of as an array (p1 is one dimensional, and p2 is two dimensional). But with respect to the model, they are considered \"scalar\" parameters, simply because they do not use any of the model's indices (namely 'time', or 'regions').","category":"page"},{"location":"userguide/#Updating-an-external-parameter-1","page":"User Guide","title":"Updating an external parameter","text":"","category":"section"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"When set_param! is called, it creates an external parameter by the name provided, and stores the provided scalar or array value. It is possible to later change the value associated with that parameter name using the functions described below. If the external parameter has a :time dimension, use the optional argument update_timesteps=true to indicate that the time keys (i.e., year labels) associated with the parameter should be updated in addition to updating the parameter values.","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"update_param!(m, :ParameterName, newvalues) # update values only \nupdate_param!(m, :ParameterName, newvalues, update_timesteps=true) # also update time keys","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"Note: newvalues must be the same size and type (or be able to convert to the type) of the old values stored in that parameter.","category":"page"},{"location":"userguide/#Setting-parameters-with-a-dictionary-1","page":"User Guide","title":"Setting parameters with a dictionary","text":"","category":"section"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"In larger models it can be beneficial to set some of the external parameters using a dictionary of values. To do this, use the following function:","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"set_leftover_params!(m, parameters)","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"Where parameters is a dictionary of type Dict{String, Any} where the keys are strings that match the names of the unset parameters in the model, and the values are the values to use for those parameters.","category":"page"},{"location":"userguide/#Using-NamedArrays-for-setting-parameters-1","page":"User Guide","title":"Using NamedArrays for setting parameters","text":"","category":"section"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"When a user sets a parameter, Mimi checks that the size and dimensions match what it expects for that component. If the user provides a NamedArray for the values, Mimi will further check that the names of the dimensions match the expected dimensions for that parameter, and that the labels match the model's index values for those dimensions. Examples of this can be found in \"test/testparameterlabels.jl\".","category":"page"},{"location":"userguide/#The-internal-'build'-function-and-model-instances-1","page":"User Guide","title":"The internal 'build' function and model instances","text":"","category":"section"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"When you call the run function on your model, first the internal build function is called, which produces a ModelInstance, and then the ModelInstance is run. A model instance is an instantiated version of the model you have designed where all of the component constructors have been called and all of the data arrays have been allocated. If you wish to create and run multiple versions of your model, you can use the intermediate build function and store the separate ModelInstances. This may be useful if you want to change some parameter values, while keeping the model's structure mostly the same. For example:","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"instance1 = Mimi.build(m)\nrun(instance1)\n\nupdate_param!(m, ParameterName, newvalue)\ninstance2 = Mimi.build(m)\nrun(instance2)\n\nresult1 = instance1[:Comp, :Var]\nresult2 = instance2[:Comp, :Var]","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"Note that you can retrieve values from a ModelInstance in the same way previously shown for indexing into a model.","category":"page"},{"location":"userguide/#The-init-function-1","page":"User Guide","title":"The init function","text":"","category":"section"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"The init function can optionally be called within @defcomp and before run_timestep.  Similarly to run_timestep, this function is called with parameters init(p, v, d), where the component state (defined by the first three arguments) has fields for the Parameters, Variables, and Dimensions of the component you defined.   ","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"If defined for a specific component, this function will run before the timestep loop, and should only be used for parameters or variables without a time index e.g. to compute the values of scalar variables that only depend on scalar parameters. Note that when using init, it may be necessary to add special handling in the run_timestep function for the first timestep, in particular for difference equations.  A skeleton @defcomp script using both run_timestep and init would appear as follows:","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"@defcomp component1 begin\n\n    # First define the state this component will hold\n    savingsrate = Parameter()\n\n    # Second, define the (optional) init function for the component\n    function init(p, v, d)\n    end\n\n    # Third, define the run_timestep function for the component\n    function run_timestep(p, v, d, t)\n    end\n\nend","category":"page"},{"location":"internals/composite_components/#Composite-Components-1","page":"Composite Components","title":"Composite Components","text":"","category":"section"},{"location":"internals/composite_components/#Overview-1","page":"Composite Components","title":"Overview","text":"","category":"section"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"This document describes the core data structures used to implement in Mimi 1.0.","category":"page"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"Prior versions of Mimi supported only \"flat\" models, i.e., with one level of components. The current version supports mulitple layers of components, with some components being \"final\" or leaf components, and others being \"composite\" components which themselves contain other leaf or composite components. This approach allows for a cleaner organization of complex models, and allows the construction of building blocks that can be re-used in multiple models.","category":"page"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"To the degree possible, composite components are designed to operate the same as leaf components, though there are necessarily differences:","category":"page"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"Leaf components are defined using the macro @defcomp, while composites are defined using @defcomposite. Each macro supports syntax and semantics specific to the type of component. See below for more details on these macros.\nLeaf composites support user-defined run_timestep() functions, whereas composites have a built-in run_timestep() function that iterates over its subcomponents and calls their run_timestep() function. The init() function is handled analogously.","category":"page"},{"location":"internals/composite_components/#Classes.jl-1","page":"Composite Components","title":"Classes.jl","text":"","category":"section"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"Most of the core data structures are defined using the Classes.jl package, which was developed for Mimi, but separated out as a generally useful julia package. The main features of Classes are:","category":"page"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"Classes can subclass other classes, thereby inheriting the same list of fields as a starting point, which can then be extended with further fields.\nA type hierarchy is defined automatically that allows classes and subclasses to be referenced with a single type. In short, if you define a class Foo, an abstract type called AbstractFoo is defined, along with the concrete class Foo. If you subclass Foo (say with the class Bar), then AbstractBar will be a subtype of AbstractFoo, allowing methods to be defined that operate on both the superclass and subclass. See the Classes.jl documentation for further details.","category":"page"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"For example, in Mimi, ModelDef is a subclass of CompositeComponentDef, which in turn is a subclass of ComponentDef. Thus, methods can be written with arguments typed x::ComponentDef to operate on leaf components only, or x::AbstractCompositeComponentDef to operate on composites and ModelDef, or as x::AbstractComponentDef to operate on all three concrete types.","category":"page"},{"location":"internals/composite_components/#Core-types-1","page":"Composite Components","title":"Core types","text":"","category":"section"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"These are defined in types/core.jl.","category":"page"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"MimiStruct and MimiClass","category":"page"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"All structs and classes in Mimi are derived from these abstract types, which allows us to identify Mimi-defined items when writing show() methods.","category":"page"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"ComponentId\nTo identify components, @defcomp creates a variable with the name of  the component whose value is an instance of this type. The definition is:\njulia  struct ComponentId <: MimiStruct      module_obj::Union{Nothing, Module}      comp_name::Symbol  end\nComponentPath\nA ComponentPath identifies the path from one or more composites to any component, using an NTuple of symbols. Since component names are unique at the composite level, the sequence of names through a component hierarchy uniquely identifies a component in that hierarchy.\njulia  struct ComponentPath <: MimiStruct      names::NTuple{N, Symbol} where N  end","category":"page"},{"location":"internals/composite_components/#Model-Definition-1","page":"Composite Components","title":"Model Definition","text":"","category":"section"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"Models are composed of two separate structures, which we refer to as the \"definition\" side and the \"instance\" or \"instantiated\" side. The definition side is operated on by the user via the @defcomp and @defcomposite macros, and the public API.","category":"page"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"The instantiated model can be thought of as a \"compiled\" version of the model definition, with its data structures oriented toward run-time efficiency. It is constructed by Mimi in the build() function, which is called by the run() function.","category":"page"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"The public API sets a flag whenever the user modifies the model definition, and the instance is rebuilt before it is run if the model definition has changed. Otherwise, the model instance is re-run.","category":"page"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"The model definition is constructed from the following elements.","category":"page"},{"location":"internals/composite_components/#Leaf-components-1","page":"Composite Components","title":"Leaf components","text":"","category":"section"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"DatumDef\nThis is a superclass holding elements common to VariableDef and ParameterDef, including the ComponentPath to the component in which the datum is defined, the data type, and dimension definitions. DatumDef subclasses are stored only in leaf components.\nVariableDef <: DatumDef\nThis class adds no new fields. It exists to differentiate variables from parameters.\nParameterDef <: DatumDef\nThis class adds only a \"default value\" field to the DatumDef. Note that functions defined to operate on the AbstractDatumDef type work for both variable and parameter definitions.\nComponentDef","category":"page"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"Instances of ComponentDef are defined using @defcomp. Their internal namespace dictionary can hold both VariableDef and ParameterDef instances.","category":"page"},{"location":"internals/composite_components/#Composite-components-1","page":"Composite Components","title":"Composite components","text":"","category":"section"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"Composite components provide a single component-like interface to an arbitrarily complex set of components (both leaf and composite components).","category":"page"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"DatumReference\nThis abstract class serves as a superclass for ParameterDefReference, and  VariableDefReference.\nParameterDefReference, and VariableDefReference\nThese are used in composite components to store references to ParameterDef and VariableDef instances defined in leaf components. (They are conceptually like symbolic links in a  file system.) Whereas a VariableDef or ParameterDef can appear in a leaf  component, references to these may appear in any number of composite components.\n\"Importing\" a parameter or variable from a sub-component defines a reference to that  datum in a leaf component. Note that if a composite imports a datum from another  composite, a reference to the leaf datum is stored in each case. That is, we don't  store references to references.\nCompositeComponentDef <: ComponentDef\nInstances of CompositeComponentDef are defined using @defcomposite. Their internal namespace dictionary can hold instances of ComponentDef, CompositeComponentDef, VariableDefReference and ParameterDefReference.  Composite components also record internal parameter connections.\nModelDef <: CompositeComponentDef\nA ModelDef is a top-level composite that also stores external parameters and a list  of external parameter connections.","category":"page"},{"location":"internals/composite_components/#Parameter-Connections-1","page":"Composite Components","title":"Parameter Connections","text":"","category":"section"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"Parameters hold values defined exogneously to the model (\"external\" parameters) or to the component (\"internal\" parameters).","category":"page"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"InternalParameterConnection","category":"page"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"Internal parameters are defined by connecting a parameter in one component to a variable in another component. This struct holds the names and ComponentPaths of the parameter and variable, and other information such as the \"backup\" data source. At build time, internal parameter connections result in direct references from the parameter to the storage allocated for the variable.","category":"page"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"ExternalParameterConnection","category":"page"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"Values that are exogenous to the model are defined in external parameters whose values are assigned using the public API function set_param!(), or by setting default values in @defcomp or @defcomposite, in which case, the default values are assigned via an internal call to set_param!().","category":"page"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"External connections are stored in the ModelDef, along with the actual ModelParameters, which may be scalar values or arrays, as described below.","category":"page"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"ModelParameter","category":"page"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"This is an abstract type that is the supertype of both ScalarModelParameter{T} and ArrayModelParameter{T}. These two parameterized types are used to store values set for external model parameters.","category":"page"},{"location":"internals/composite_components/#Instantiated-Models-1","page":"Composite Components","title":"Instantiated Models","text":"","category":"section"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"ComponentInstanceData","category":"page"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"This is the supertype for variables and parameters in component instances.","category":"page"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"@class ComponentInstanceData{NT <: NamedTuple} <: MimiClass begin\n    nt::NT\n    comp_paths::Vector{ComponentPath}   # records the origin of each datum\nend","category":"page"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"ComponentInstanceParameters\nComponentInstanceVariables\nComponentInstance\nLeafComponentInstance <: ComponentInstance\nCompositeComponentInstance <: ComponentInstance\nThe run_timestep() method of a ComponentInstance simply calls the run_timestep()  method of each of its sub-components in dependency order.\nModelInstance <: CompositeComponentInstance","category":"page"},{"location":"internals/composite_components/#User-facing-Classes-1","page":"Composite Components","title":"User-facing Classes","text":"","category":"section"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"Model","category":"page"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"The Model class contains the ModelDef, and after the build() function is called, a ModelInstance that can be run. The API for Model delegates many calls to either its top-level ModeDef or ModelInstance, while providing additional functionality including running a Monte Carlo simulation.","category":"page"},{"location":"internals/composite_components/#","page":"Composite Components","title":"Composite Components","text":"ComponentReference\nVariableReference","category":"page"},{"location":"#Welcome-to-Mimi-1","page":"Home","title":"Welcome to Mimi","text":"","category":"section"},{"location":"#Overview-1","page":"Home","title":"Overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Mimi is a package that provides a component model for integrated assessment models.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Mimi is an installable package which requires the programming language julia to run. To install Mimi, first enter Pkg REPL mode by typing ], and then use the following script. You may then exit Pkg REPL mode with a single backpace.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"pkg> add Mimi","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For more complete setup instructions, follow the Installation Guide.","category":"page"},{"location":"#Mimi-Registry-1","page":"Home","title":"Mimi Registry","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Several models currently use the Mimi framework, as listed in the section below.  For convenience, several models are registered in the MimiRegistry, and operate as julia packages. To use this feature, you first need to connect your julia installation with the central Mimi registry of Mimi models. This central registry is like a catalogue of models that use Mimi that is maintained by the Mimi project. To add this registry, run the following command at the julia package REPL: ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"pkg> registry add https://github.com/mimiframework/MimiRegistry.git","category":"page"},{"location":"#","page":"Home","title":"Home","text":"You only need to run this command once on a computer. ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"From there you may add any of the registered packages, such as MimiRICE2010.jl by running the following command at the julia package REPL:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"pkg> add MimiRICE2010","category":"page"},{"location":"#Models-using-Mimi-1","page":"Home","title":"Models using Mimi","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"MimiFUND.jl (currently in beta)\nMimiDICE2010.jl\nMimiDICE2013.jl\nMimiRICE2010.jl\nMimi-SNEASY.jl (currently in closed beta)\nMimi-FAIR.jl (currently in closed beta)\nMimiPAGE2009.jl (currently in closed beta)\nMimi-MAGICC.jl (CH4 parts currently in closed beta)\nMimi-HECTOR.jl (CH4 parts currently in closed beta)\nMimi-CIAM.jl (currently in closed beta)\nMimi-BRICK.jl (currently in closed beta)\nAWASH\nPAGE-ICE","category":"page"},{"location":"tutorials/tutorial_1/#Tutorial-1:-Run-an-Existing-Model-1","page":"1 Run an Existing Model","title":"Tutorial 1: Run an Existing Model","text":"","category":"section"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"This tutorial walks through the steps to download, run, and view the output of an existing model.  There are several existing models publically available on Github for the purposes of this tutorial we will use The Climate Framework for Uncertainty, Negotiation and Distribution (FUND), available on Github here.","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"Working through the following tutorial will require:","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"Julia v1.2.0 or higher\nMimi v0.9.4","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"If you have not yet prepared these, go back to the main tutorial page and follow the instructions for their download.","category":"page"},{"location":"tutorials/tutorial_1/#Step-1.-Download-FUND-1","page":"1 Run an Existing Model","title":"Step 1. Download FUND","text":"","category":"section"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"The first step in this process is downloading the FUND model, which is now made easy with the Mimi registry. Assuming you have already done the one-time run of the following command to connect your julia installation with the central Mimi registry of Mimi models:","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"pkg> registry add https://github.com/mimiframework/MimiRegistry.git","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"You simply need to add the FUND model in the Pkg REPL with:","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"pkg> add MimiFUND","category":"page"},{"location":"tutorials/tutorial_1/#Step-2.-Run-FUND-1","page":"1 Run an Existing Model","title":"Step 2. Run FUND","text":"","category":"section"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"The next step is to run FUND. If you wish to first get more acquainted with the model itself, take a look at the provided online documentation.","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"Now open a julia REPL and type the following command to load the MimiFUND package into the current environment:","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"using MimiFUND","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"Now we can access the public API of FUND, including the function MimiFUND.get_model. This function returns a copy of the default FUND model. Here we will first get the model, and then use the run function to run it.","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"m = MimiFUND.get_model()\nrun(m)","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"Note that these steps should be relatively consistent across models, where a repository for ModelX should contain a primary file ModelX.jl which exports, at minimum, a function named something like get_model or construct_model which returns a version of the model, and can allow for model customization within the call.","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"In the MimiFUND package, the function get_model has the signature","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"get_model(; nsteps = default_nsteps, datadir = default_datadir, params = default_params)","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"Thus there are no required arguments, although the user can input nsteps to define the number of timesteps (years in this case) the model runs for, datadir to define the location of the input data, and params, a dictionary definining the parameters of the model.  For example, if you wish to run only the first 200 timesteps, you may use:","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"using MimiFUND\nm = MimiFUND.get_model(nsteps = 200)\nrun(m)","category":"page"},{"location":"tutorials/tutorial_1/#Step-3.-Access-Results:-Values-1","page":"1 Run an Existing Model","title":"Step 3. Access Results: Values","text":"","category":"section"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"After the model has been run, you may access the results (the calculated variable values in each component) in a few different ways.","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"Start off by importing the Mimi package to your space with","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"using Mimi","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"First of all, you may use the getindex syntax as follows:","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"m[:ComponentName, :VariableName] # returns the whole array of values\nm[:ComponentName, :VariableName][100] # returns just the 100th value\n","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"Indexing into a model with the name of the component and variable will return an array with values from each timestep. You may index into this array to get one value (as in the second line, which returns just the 100th value). Note that if the requested variable is two-dimensional, then a 2-D array will be returned. For example, try taking a look at the income variable of the socioeconomic component of FUND using the code below:","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"m[:socioeconomic, :income]\nm[:socioeconomic, :income][100]","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"You may also get data in the form of a dataframe, which will display the corresponding index labels rather than just a raw array. The syntax for this uses getdataframe as follows:","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"getdataframe(m, :ComponentName=>:Variable) # request one variable from one component\ngetdataframe(m, :ComponentName=>(:Variable1, :Variable2)) # request multiple variables from the same component\ngetdataframe(m, :Component1=>:Var1, :Component2=>:Var2) # request variables from different components","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"Try doing this for the income variable of the socioeconomic component using:","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"getdataframe(m, :socioeconomic=>:income) # request one variable from one component\ngetdataframe(m, :socioeconomic=>:income)[1:16,:] # results for all regions in first year (1950)","category":"page"},{"location":"tutorials/tutorial_1/#Step-4.-Access-Results:-Plots-and-Graphs-1","page":"1 Run an Existing Model","title":"Step 4. Access Results: Plots and Graphs","text":"","category":"section"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"After running the FUND model, you may also explore the results using plots and graphs.","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"Mimi provides support for plotting using VegaLite and VegaLite.jl within the Mimi Explorer UI, and the LightGraphs and MetaGraphs for the plot_comp_graph function.","category":"page"},{"location":"tutorials/tutorial_1/#Explore-1","page":"1 Run an Existing Model","title":"Explore","text":"","category":"section"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"If you wish to explore the results graphically, use the explorer UI, described here in Section 5 of the Mimi User Guide.","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"To explore all variables and parameters of FUND in a dynamic UI app window, use the explore function called with the model as the required first argument, and the optional argument of the title  The menu on the left hand side will list each element in a label formatted as component: variable/parameter.","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"explore(m, title = \"My Window\")","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"Alternatively, in order to view just one parameter or variable, call the function explore as below to return a plot object and automatically display the plot in a viewer, assuming explore is the last command executed.  This call will return the type VegaLite.VLSpec, which you may interact with using the API described in the VegaLite.jl documentation.  For example, VegaLite.jl plots can be saved as PNG, SVG, PDF and EPS files. You may save a plot using the save function. Note that saving an interactive plot in a non-interactive file format, such as .pdf or .svg will result in a warning WARN Can not resolve event source: window, but the plot will be saved as a static image. If you wish to preserve interactive capabilities, you may save it using the .vegalite file extension. If you then open this file in Jupyter lab, the interactive aspects will be preserved.","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"p = Mimi.plot(m, :mycomponent, :myvariable)\nsave(\"MyFilePath.svg\", p)","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"More specifically for our tutorial use of FUND, try:","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"p = Mimi.plot(m, :socioeconomic, :income)\nsave(\"MyFilePath.svg\", p)","category":"page"},{"location":"tutorials/tutorial_1/#Component-Graph-1","page":"1 Run an Existing Model","title":"Component Graph","text":"","category":"section"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"In order to view a DAG representing the component ordering and relationships, use the plot_comp_graph function to view a plot and optionally save it to a file. This function returns a plot object displayed in the viewer and showing a graph with components as nodes and component connections as edges.","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"plot_comp_graph(m, \"MyFilePath.png\")","category":"page"},{"location":"tutorials/tutorial_1/#Step-4.-Tutorial-2-1","page":"1 Run an Existing Model","title":"Step 4. Tutorial 2","text":"","category":"section"},{"location":"tutorials/tutorial_1/#","page":"1 Run an Existing Model","title":"1 Run an Existing Model","text":"Next, feel free to move on to the second tutorial, which will go into depth on how to modify an existing model such as FUND!","category":"page"}]
}
