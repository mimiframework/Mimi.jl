var documenterSearchIndex = {"docs":
[{"location":"howto/howto_3/#How-to-Guide-3:-Conduct-Sensitivity-Analysis-1","page":"3 Sensitivity Analysis","title":"How-to Guide 3: Conduct Sensitivity Analysis","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"Mimi includes a host of routines which support running various sensitivity analysis methods on Mimi models. Tutorial 5: Sensitivity Analysis (SA) Support is a good starting point for learning about these methods.  This how-to guide includes more detail and optionality, covering more advanced options such as non-stochastic scenarios and running multiple models, which are not yet included in the tutorial.","category":"page"},{"location":"howto/howto_3/#Overview-1","page":"3 Sensitivity Analysis","title":"Overview","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"Running a sensitivity analysis in Mimi can be broken down into three primary user-facing elements:","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"The @defsim macro, which defines random variables (RVs) which are assigned distributions and associated with model parameters, and override the default (random) sampling method.\nThe run function, which runs a simulation instance, setting the model(s) on which a simulation definition can be run with set_models!, generates all trial data with generate_trials!, and has several with optional parameters and optional callback functions to customize simulation behavior. \nThe analyze function, which takes a simulation instance, analyzes the results and returns results specific to the type of simulation passed in.  Currently this function is only defined for the SobolSimulationInstance subtype of SimulationInstance","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"The rest of this document will be organized as follows:","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"The @defsim macro\nThe run function\nThe analyze function\nPlotting and the Explorer UI\nSimulation Modification Functions\nExamples","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"We will refer separately to two types, SimulationDef and SimulationInstance.  They are referred to as sim_def and sim_inst respectively as function arguments, and sd and si respectively as local variables.","category":"page"},{"location":"howto/howto_3/#.-The-@defsim-macro-1","page":"3 Sensitivity Analysis","title":"1. The @defsim macro","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"The first step in a Mimi sensitivity analysis is using the @defsim macro to define and return a SimulationDef{T}. This simulation definition contains all the definition information in a form that can be applied at run-time. The T in SimulationDef{T} is any type that your application would like to live inside the SimulationDef struct, and most importantly specifies the sampling strategy to be used in your sensitivity analysis.  ","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"We have implemented three types for T <: AbstractSimulationData:","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"Simple random-sampling Monte Carlo Simulation (MCSData),\nLatin Hypercube Sampling (LHSData)\nSobol sampling and analysis (SobolData)","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"We also define type constants with friendlier names for these parameterized types:","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"const MonteCarloSimulationDef = SimulationDef{MCSData}\nconst MonteCarloSimulationInstance = SimulationInstance{MCSData}\n\nconst LatinHypercubeSimulationDef = SimulationDef{LHSData}\nconst LatinHypercubeSimulationInstance = SimulationInstance{LHSData}\n\nconst SobolSimulationDef = SimulationDef{SobolData}\nconst SobolSimulationInstance = SimulationInstance{SobolData}","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"In order to build the information required at run-time, the @defsim macro carries out several tasks including the following.","category":"page"},{"location":"howto/howto_3/#Define-Random-Variables-(RVs)-1","page":"3 Sensitivity Analysis","title":"Define Random Variables (RVs)","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"The macro must define random variables (RVs) by assigning names to distributions, which can be any object that supports the following function:","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"rand(dist, count::Int=1) which produces a single value when count == 1, else a Vector of values.","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"If using Latin Hypercube Sampling (LHS) is used, the following function must also be defined:","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"quantile(dist, quantiles::Vector{Float64}) which returns values for the given quantiles of the distribution.","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"In addition to the distributions available in the Distributions package, Mimi provides:","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"EmpiricalDistribution, which takes a vector of values and (optional) vector of probabilities and produces samples from these values using the given probabilities, if provided, or equal probability otherwise.\nSampleStore{T}, which stores a vector of samples that are produced in order by the rand function. This allows the user to to store a predefined set of values (useful for regression testing) and it is used by the LHS method, which draws all required samples at once at equal probability intervals and then shuffles the values. It is also used when rank correlations are specified, since this requires re-ordering draws from random variables.\nReshapedDistribution, which supports use of vector-valued distributions, i.e., those that generate   vectors of values for each single draw. An example (that motivated this addition) is the Dirichlet distribution, which produces a vector of values that sum to 1. To use this in @defsim, you might do:\n  rd = ReshapedDistribution([5, 5], Dirichlet(25,1))\nThis code creates a pseudo-distribution that, for each draw, produces a 5x5 matrix of values that sum to 1.","category":"page"},{"location":"howto/howto_3/#Apply-RVs-to-model-parameters-1","page":"3 Sensitivity Analysis","title":"Apply RVs to model parameters","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"The macro next defines how to apply the values generated by each RV to model parameters based on a pseudo-assignment operator:","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"param = RV replaces the values in the parameter with the value of the RV for the current trial.\nparam += RV replaces the values in the parameter with the sum of the original value and the value of the RV for the current trial.\nparam *= RV replaces the values in the parameter with the product of the original value and the value of the RV for the current trial.","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"Furthermore, in @defsim, you can apply distributions to specific slices of array parameters, and you can \"bulk assign\" distributions to elements of a vector or matrix using a more condensed syntax.","category":"page"},{"location":"howto/howto_3/#Apply-RVs-to-model-parameters:-Assigning-to-array-slices-1","page":"3 Sensitivity Analysis","title":"Apply RVs to model parameters: Assigning to array slices","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"Options for applying distributions to array slices is accomplished using array access syntax on the left-hand side of an assignment. The assignment may use any of these assignment operators: =, *=, or +=, as described above. Slices can be indicated using a variety of specifications. Assume we define two parameters in @defcomp as","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"  foo = Parameter(index=[regions])\n  bar = Parameter(index=[time, regions])","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"with regions defined as [:USA, :CAN, :MEX, :ROW]","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"We can assign distributions to the elements of foo several ways:","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"Using a symbol or string or tuple of symbols or strings. Note that values specified without a \":\" prefix or double quotes are treated as symbols. To specify strings, quote them the usual way.\nfoo[USA] = Uniform(0, 1) would assign the RV to foo[:USA] only.\nfoo[(USA, CAN, MEX)] = Uniform(0, 1) would assign the same RV to 3 elements of foo.  That is, a single value is drawn from the RV with distribution Uniform(0, 1) and this value is assigned to all three elements of foo.\nA :, indicating all elements for this dimension\nfoo[:] = Normal(10.0 3.0) would use a draw from the Normal RV for all elements of foo.\nA : range, with or without a step, or a tuple of integers\nbar[2050:10:2080, :] = Uniform(2, 3) would assign a single Uniform RV to all regions for  time steps with labels 2050, 2060, 2070, and 2080.\nbar[(2050, 2060, 2070, 2080), :] = Uniform(2, 3) does the same thing using a tuple of values.","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"If regions were defined using strings, as in [\"USA\", \"CAN\", \"MEX\", \"ROW\"], the examples above would be written as foo[\"USA\"] = Uniform(0, 1) and so on.","category":"page"},{"location":"howto/howto_3/#Apply-RVs-to-model-parameters:-Assigning-a-vector-of-distributions-1","page":"3 Sensitivity Analysis","title":"Apply RVs to model parameters: Assigning a vector of distributions","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"In some cases, it's more convenient to assign a vector of distributions (e.g., with different functional forms or parameters) to a single parameter. For example we can use the following syntax:","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"  foo = [USA => Uniform(0, 1),\n         (CAN, MEX) => Uniform(1, 2),\n         ROW => Normal(10, 3)]","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"which is equivalent to:","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"  foo[USA] = Uniform(0, 1),\n  foo[(CAN, MEX)] = Uniform(1, 2),\n  foo[ROW] = Normal(10, 3)]","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"To assign to parameters with more than one dimension, use square brackets around the dimensions on the left-hand side of each => operator, e.g.,","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"  bar = [[2050, USA] => Uniform(0, 1),\n         [:, (CAN, MEX)] => Uniform(1, 2),\n         [2010:10:2080, ROW] => Normal(10, 3)]","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"Currently, the more condensed syntax (using the pair operator =>) supports only direct assignment  of RV value, i.e., you cannot combine this with the *= or += operators.","category":"page"},{"location":"howto/howto_3/#Specify-a-Sampling-Strategies-1","page":"3 Sensitivity Analysis","title":"Specify a Sampling Strategies","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"As previously mentioned and included in the tutorial, the @defsim macro uses the call to sampling to type-parameterize the SimulationDef with one of three types, which in turn direct the sampling strategy of the simulation. This is done with the sampling line of the macro.","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"Simple random-sampling Monte Carlo Simulation (MCSData),\nLatin Hypercube Sampling (LHSData)","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"Latin Hypercube sampling divides the distribution into equally-spaced quantiles, obtains values at those quantiles, and then shuffles the values. The result is better representation of the tails of the distribution with fewer samples than would be required for purely random sampling.","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"Sobol sampling and analysis (SobolData)","category":"page"},{"location":"howto/howto_3/#Include-Sampling-Strategy-specifc-Parameters-1","page":"3 Sensitivity Analysis","title":"Include Sampling Strategy-specifc Parameters","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"Certain sampling strategies support (or necessitate) further customization. These may include:","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"rank correlations (LHS)): In some cases, it may be desireable to define  rank correlations between pairs of random variables. Approximate rank correlation is achieved by re-ordering vectors of random draws as per Iman and Conover (1982). \nextra parameters (Sobol): Sobol sampling allows specification of the sample size N and whether or not one wishes to calculate second-order effects.","category":"page"},{"location":"howto/howto_3/#.-The-run-function-1","page":"3 Sensitivity Analysis","title":"2. The run function","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"In it's simplest use, the run function generates and iterates over generated trial data, perturbing a chosen subset of Mimi's \"external parameters\", based on the defined distributions, and then runs the given Mimi model(s). The function retuns an instance of SimulationInstance, holding a copy of the original SimulationDef with additional trial information as well as a list of references ot the models and the results. Optionally, trial values and/or model results are saved to CSV files.","category":"page"},{"location":"howto/howto_3/#Function-signature-1","page":"3 Sensitivity Analysis","title":"Function signature","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"The full signature for the run is:","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"function Base.run(sim_def::SimulationDef{T}, models::Union{Vector{Model}, Model}, samplesize::Int;\n                 ntimesteps::Int=typemax(Int), \n                 trials_output_filename::Union{Nothing, AbstractString}=nothing, \n                 results_output_dir::Union{Nothing, AbstractString}=nothing, \n                 pre_trial_func::Union{Nothing, Function}=nothing, \n                 post_trial_func::Union{Nothing, Function}=nothing,\n                 scenario_func::Union{Nothing, Function}=nothing,\n                 scenario_placement::ScenarioLoopPlacement=OUTER,\n                 scenario_args=nothing,\n                 results_in_memory::Bool=true) where T <: AbstractSimulationData","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"Using this function allows a user to run the simulation definition sim_def for the models using samplesize samples.","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"Optionally the user may run the models for ntimesteps, if specified, else to the maximum defined time period. Note that trial data are applied to all the associated models even when running only a portion of them.   ","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"If provided, the generated trials and results will be saved in the indicated trials_output_filename and results_output_dir respectively. If results_in_memory is set to false, then results will be cleared from memory and only stored in the results_output_dir. After run, the results of a SimulationInstance can be accessed using the getdataframe function with the following signature, which returns a DataFrame. ","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"getdataframe(sim_inst::SimulationInstance, comp_name::Symbol, datum_name::Symbol; model::Int = 1)","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"If pre_trial_func or post_trial_func are defined, the designated functions are called  just before or after (respectively) running a trial. The functions must have the signature:","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"fn(sim_inst::SimulationInstance, trialnum::Int, ntimesteps::Int, tup::Tuple)","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"where tup is a tuple of scenario arguments representing one element in the cross-product of all scenario value vectors. In situations in which you want the simulation loop to run only some of the models, the remainder of the runs can be handled using a pre_trial_func or post_trial_func.","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"If provided, scenario_args must be a Vector{Pair}, where each Pair is a symbol and a  Vector of arbitrary values that will be meaningful to scenario_func, which must have the signature:","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"scenario_func(sim_inst::SimulationInstance, tup::Tuple)","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"By default, the scenario loop encloses the simulation loop, but the scenario loop can be placed inside the simulation loop by specifying scenario_placement=INNER. When INNER  is specified, the scenario_func is called after any pre_trial_func but before the model is run.","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"Finally, run returns the type SimulationInstance that contains a copy of the original SimulationDef in addition to trials information (trials, current_trial, and current_data), the model list models, and results information in results.","category":"page"},{"location":"howto/howto_3/#Internal-Functions-to-run-1","page":"3 Sensitivity Analysis","title":"Internal Functions to run","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"The following functions are internal to run, and do not need to be understood by users but may be interesting to understand.","category":"page"},{"location":"howto/howto_3/#The-set_models!-function-1","page":"3 Sensitivity Analysis","title":"The set_models! function","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"The run function sets the model or models to run using set_models! function and saving references to these in the SimulationInstance instance.  The set_models! function has several methods for associating the model(s) to run with the SimulationDef:","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"set_models!(sim_inst::SimulationInstance, models::Vector{Model})\nset_models!(sim_inst::SimulationInstance, m::Model)\nset_models!(sim_inst::SimulationInstance, mm::MarginalModel)","category":"page"},{"location":"howto/howto_3/#The-generate_trials!-function-1","page":"3 Sensitivity Analysis","title":"The generate_trials! function","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"The generate_trials! function is used to pre-generate data using the given samplesize and save all random variable values in the file filename. Its calling signature is:","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"  generate_trials!(sim_def::SimulationDefinition, samplesize::Int; filename::Union{String, Nothing}=nothing)","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"If the sim_def parameter has multiple scenarios and the scenario_loop placement is set to OUTER this function must be called if the user wants to ensure the same trial data be used in each scenario. If this function is not called, new trial data will be generated for each scenario. ","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"Also note that if the filename argument is used, all random variable draws are saved to the given filename. Internally, any Distribution instance is converted to a SampleStore and the values are subsequently returned in the order generated when rand! is called.","category":"page"},{"location":"howto/howto_3/#Non-stochastic-Scenarios-1","page":"3 Sensitivity Analysis","title":"Non-stochastic Scenarios","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"In many cases, scenarios (which we define as a choice of values from a discrete set for one or more parameters) need to be considered in addition to the stochastic parameter variation. To support scenarios, run also offers iteration over discrete scenario values, which are passed to run via the keyword parameter scenario_args::Dict{Symbol, Vector}. For example, to iterate over scenario values \"a\", and \"b\", as well as, say, discount rates 0.025, 0.05, 0.07, you could provide the argument:","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"scenario_args=Dict([:name => [\"a\", \"b\"], :rate => [0.025, 0.05, 0.07]])","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"Of course, the SA subsystem does not know what you want to do with these values, so the user must also provide a callback function in the scenario_func argument. This function must be defined with the signature:","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"function any_name_you_like(sim_inst::SimulationInstance, tup)","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"where tup is an element of the set of tuples produced by calling Itertools.product() on all the scenario arguments. In the example above, this would produce the following vector of tuples:","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"[(\"a\", 0.025), (\"b\", 0.025), (\"a\", 0.03), (\"b\", 0.03), (\"a\", 0.05), (\"b\", 0.05)].","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"This approach allows all scenario combinations to be iterated over using a single loop. A final keyword argument, scenario_placement::ScenarioLoopPlacement indicates whether the scenario loop should occur inside or outside the loop over stochastic trial values. The type ScenarioLoopPlacement is an enum with values INNER and OUTER, the latter being the default placement.","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"In approximate pseudo-julia, these options produce the following behavior:","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"scenario_placement=OUTER","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"for tup in scenario_tuples\n  scenario_func(tup)\n\n  # for each scenario, run all SA trials\n  for trial in trials\n    trial_data = get_trial_data(trial)\n    apply_trial_data()\n\n    pre_trial_func()\n    run(model)\n    post_trial_func()\n  end\nend","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"scenario_placement=INNER","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"for trial in trials\n  trial_data = get_trial_data(trial)\n  apply_trial_data()\n\n  # for each SA trial, run all scenarios\n  for tup in scenario_tuples\n    scenario_func(tup)\n\n    pre_trial_func()\n    run(model)\n    post_trial_func()\n  end\nend","category":"page"},{"location":"howto/howto_3/#Running-Multiple-Models-1","page":"3 Sensitivity Analysis","title":"Running Multiple Models","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"In some simulations, a baseline model needs to be compared to one or more models that are perturbed parametrically or structurally (i.e., with different components or equations.) To support this, the SimulationInstance type holds a vector of Model instances, and allows the caller to specify how many of these to run automatically for each trial. Note that regardless of how many models are run, the random variables are applied to all of the models associated with the simulation.","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"By default, all defined models are run. In some cases, you may want to run some of the models \"manually\" in the pre_trial_func or post_trial_func, which allow you to make arbitrary modifications to these additional models.","category":"page"},{"location":"howto/howto_3/#.-The-analyze-function-1","page":"3 Sensitivity Analysis","title":"3. The analyze function","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"[TODO]","category":"page"},{"location":"howto/howto_3/#.-Plotting-and-the-Explorer-UI-1","page":"3 Sensitivity Analysis","title":"4. Plotting and the Explorer UI","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"As described in the User Guide, Mimi provides support for plotting using VegaLite and VegaLite.jl within the Mimi Explorer UI and Mimi.plot function. These functions not only work for Models, but for SimulationInstances as well. ","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"In order to invoke the explorer UI and explore all of the saved variables from the save list of a SimulationInstance, simply call the function explore with the simulation as the required argument as shown below.  This will produce a new browser window containing a selectable list of variables, each of which produces a graphic.","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"run(sim_inst)\nexplore(sim_inst)","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"There are several optional keyword arguments for the explore method, as shown by the full function signature:","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"explore(sim_inst::SimulationInstance; title=\"Electron\", model_index::Int = 1, scen_name::Union{Nothing, String} = nothing, results_output_dir::Union{Nothing, String} = nothing)","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"The title is the optional title of the application window, the model_index defines which model in your list of models passed to run you would like to explore (defaults to 1), and scen_name is the name of the specific scenario you would like to explore if there is a scenario dimension to your simulation.  Note that if there are multiple scenarios, this is a required argument. Finally, if you have saved the results of your simulation to disk and cleared them from memory using run's results_in_memory keyword argument flag set to false, you must provide a results_output_dir which indicates the parent folder for all outputs and potential subdirectories, identical to that passed to run.","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"(Image: Explorer Simulation Example)","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"Alternatively, in order to view just one variable, call the (unexported) function Mimi.plot as below to return a plot object and automatically display the plot in a viewer, assuming Mimi.plot is the last command executed.  Note that plot is not exported in order to avoid namespace conflicts, but a user may import it if desired. This call will return the type VegaLite.VLSpec, which you may interact with using the API described in the VegaLite.jl documentation.  For example, VegaLite.jl plots can be saved in many typical file formats such as  PNG, SVG, PDF and EPS files. You may save a plot using the save function. Note that while explore(sim_inst) returns interactive plots for several graphs, Mimi.plot(si, :foo, :bar) will return only static plots. ","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"using VegaLite\nrun(sim_inst)\np = Mimi.plot(sim_inst, :component1, :parameter1)\nsave(\"figure.svg\", p)","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"Note the function signature below, which has the same keyword arguments and requirements as the aforementioned explore method, save for title.","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"plot(sim_inst::SimulationInstance, comp_name::Symbol, datum_name::Symbol; interactive::Bool = false, model_index::Int = 1, scen_name::Union{Nothing, String} = nothing, results_output_dir::Union{Nothing, String} = nothing)","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"(Image: Plot Simulation Example)","category":"page"},{"location":"howto/howto_3/#.-Simulation-Modification-Functions-1","page":"3 Sensitivity Analysis","title":"5. Simulation Modification Functions","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"A small set of unexported functions are available to modify an existing SimulationDefinition.  The functions include:","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"delete_RV!\nadd_RV!\nreplace_RV!\ndelete_transform!\nadd_transform!\ndelete_save!\nadd_save!\nset_payload!\npayload","category":"page"},{"location":"howto/howto_3/#.-Examples-1","page":"3 Sensitivity Analysis","title":"6. Examples","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"The following example is derived from \"Mimi.jl/test/mcs/test_defmcs.jl\".","category":"page"},{"location":"howto/howto_3/#","page":"3 Sensitivity Analysis","title":"3 Sensitivity Analysis","text":"using Mimi\nusing Distributions\n\nN = 100\n\nsd = @defsim begin\n    # Define random variables. The rv() is required to disambiguate an\n    # RV definition name = Dist(args...) from application of a distribution\n    # to an external parameter. This makes the (less common) naming of an\n    # RV slightly more burdensome, but it's only required when defining\n    # correlations or sharing an RV across parameters.\n    rv(name1) = Normal(1, 0.2)\n    rv(name2) = Uniform(0.75, 1.25)\n    rv(name3) = LogNormal(20, 4)\n\n    # assign RVs to model Parameters\n    share = Uniform(0.2, 0.8)\n    sigma[:, Region1] *= name2\n    sigma[2020:5:2050, (Region2, Region3)] *= Uniform(0.8, 1.2)\n\n    depk = [Region1 => Uniform(0.08, 0.14),\n            Region2 => Uniform(0.10, 1.50),\n            Region3 => Uniform(0.10, 0.20)]\n\n    sampling(LHSData, corrlist=[(:name1, :name2, 0.7), (:name1, :name3, 0.5)])\n    \n    # indicate which parameters to save for each model run. Specify\n    # a parameter name or [later] some slice of its data, similar to the\n    # assignment of RVs, above.\n    save(grosseconomy.K, grosseconomy.YGROSS, emissions.E, emissions.E_Global)\nend\n\nMimi.reset_compdefs()\ninclude(\"../../examples/tutorial/02-multi-region-model/main.jl\")\n\nm = model\n\n# Optionally, user functions can be called just before or after a trial is run\nfunction print_result(m::Model, sim_inst::SimulationInstance, trialnum::Int)\n    ci = Mimi.compinstance(m.mi, :emissions)\n    value = Mimi.get_variable_value(ci, :E_Global)\n    println(\"$(ci.comp_id).E_Global: $value\")\nend\n\n# set some some constants\ntrials_output_filename = joinpath(output_dir, \"trialdata.csv\")\nresults_output_dir = joinpath(tempdir(), \"sim\")\nN = 100\n\n# Run trials and save trials results to the indicated directories\nsi = run(sd, m, N; trials_output_filename=trials_output_filename, results_output_dir=results_output_dir)\n\n# take a look at the results\nresults = getdataframe(si, :grosseconomy, :K) # model index chosen defaults to 1","category":"page"},{"location":"howto/howto_5/#How-to-Guide-5:-Port-to-Mimi-v0.5.0-1","page":"5 Port to v0.5.0","title":"How-to Guide 5: Port to Mimi v0.5.0","text":"","category":"section"},{"location":"howto/howto_5/#","page":"5 Port to v0.5.0","title":"5 Port to v0.5.0","text":"The release of Mimi v0.5.0 is a breaking release, necessitating the adaptation of existing models' syntax and structure in order for those models to run on this new version.  This guide provides an overview of the steps required to get most models using the v0.4.0 API working with v0.5.0.  It is not a comprehensive review of all changes and new functionalities, but a guide to the minimum steps required to port old models between versions.  For complete information on the new version and its functionalities, see the full documentation.","category":"page"},{"location":"howto/howto_5/#","page":"5 Port to v0.5.0","title":"5 Port to v0.5.0","text":"This guide is organized into six main sections, each descripting an independent set of changes that can be undertaken in any order desired.  ","category":"page"},{"location":"howto/howto_5/#","page":"5 Port to v0.5.0","title":"5 Port to v0.5.0","text":"Defining components\nConstructing a model\nRunning the model\nAccessing results\nPlotting\nAdvanced topics","category":"page"},{"location":"howto/howto_5/#","page":"5 Port to v0.5.0","title":"5 Port to v0.5.0","text":"A Note on Function Naming: There has been a general overhaul on function names, especially those in the explicity user-facing API, to be consistent with Julia conventions and the conventions of this Package.  These can be briefly summarized as follows:","category":"page"},{"location":"howto/howto_5/#","page":"5 Port to v0.5.0","title":"5 Port to v0.5.0","text":"use _ for readability\nappend all functions with side-effects, i.e., non-pure functions that return a value but leave all else unchanged with a !\nthe commonly used terms component, variable, and parameter are shortened to comp, var, and param\nfunctions that act upon a component, variable, or parameter are often written in the form [action]_[comp/var/param]","category":"page"},{"location":"howto/howto_5/#Defining-Components-1","page":"5 Port to v0.5.0","title":"Defining Components","text":"","category":"section"},{"location":"howto/howto_5/#","page":"5 Port to v0.5.0","title":"5 Port to v0.5.0","text":"The run_timestep function is now contained by the @defcomp macro, and takes the parameters p, v, d, t, referring to Parameters, Variables, and Dimensions of the component you defined.  The fourth argument is an AbstractTimestep, i.e., either a FixedTimestep or a VariableTimestep.  Similarly, the optional init function is also contained by @defcomp, and takes the parameters p, v, d.  Thus, as described in the user guide, defining a single component is now done as follows:","category":"page"},{"location":"howto/howto_5/#","page":"5 Port to v0.5.0","title":"5 Port to v0.5.0","text":"In this version, the fourth argument (t below) can no longer always be used simply as an Int. Indexing with t is still permitted, but special care must be taken when comparing t with conditionals or using it in arithmatic expressions.  The full API as described later in this document in Advanced Topics:  Timesteps and available functions.  Since differential equations are commonly used as the basis for these models' equations, the most commonly needed change will be changing if t == 1 to if is_first(t)","category":"page"},{"location":"howto/howto_5/#","page":"5 Port to v0.5.0","title":"5 Port to v0.5.0","text":"@defcomp component1 begin\n\n    # First define the state this component will hold\n    savingsrate = Parameter()\n\n    # Second, define the (optional) init function for the component\n    function init(p, v, d)\n    end\n\n    # Third, define the run_timestep function for the component\n    function run_timestep(p, v, d, t)\n    end\n\nend","category":"page"},{"location":"howto/howto_5/#Constructing-a-Model-1","page":"5 Port to v0.5.0","title":"Constructing a Model","text":"","category":"section"},{"location":"howto/howto_5/#","page":"5 Port to v0.5.0","title":"5 Port to v0.5.0","text":"In an effort to standardize the function naming protocol within Mimi, and to streamline it with the Julia convention, several function names have been changed.  The table below lists a subset of these changes, focused on the exported API functions most commonly used in model construction.  ","category":"page"},{"location":"howto/howto_5/#","page":"5 Port to v0.5.0","title":"5 Port to v0.5.0","text":"Old Syntax New Syntax\naddcomponent! add_comp!\nconnectparameter connect_param!\nsetleftoverparameters set_leftover_params!\nsetparameter set_param!\nadddimension add_dimension!\nsetindex set_dimension!","category":"page"},{"location":"howto/howto_5/#","page":"5 Port to v0.5.0","title":"5 Port to v0.5.0","text":"Changes to various optional keyword arguments:","category":"page"},{"location":"howto/howto_5/#","page":"5 Port to v0.5.0","title":"5 Port to v0.5.0","text":"add_comp!:  Through Mimi v0.9.4, the optional keyword arguments first and last could be used to specify times for components that do not run for the full length of the model, like this: add_comp!(mymodel, ComponentC; first=2010, last=2100). This functionality is currently disabled, and all components must run for the full length of the model's time dimension. This functionality may be re-implemented in a later version of Mimi.","category":"page"},{"location":"howto/howto_5/#Running-a-Model-1","page":"5 Port to v0.5.0","title":"Running a Model","text":"","category":"section"},{"location":"howto/howto_5/#Accessing-Results-1","page":"5 Port to v0.5.0","title":"Accessing Results","text":"","category":"section"},{"location":"howto/howto_5/#Plotting-and-the-Explorer-UI-1","page":"5 Port to v0.5.0","title":"Plotting and the Explorer UI","text":"","category":"section"},{"location":"howto/howto_5/#","page":"5 Port to v0.5.0","title":"5 Port to v0.5.0","text":"This release of Mimi does not include the plotting functionality previously offered by Mimi.  While the previous files are still included, the functions are not exported as efforts are made to simplify and improve the plotting associated with Mimi.  ","category":"page"},{"location":"howto/howto_5/#","page":"5 Port to v0.5.0","title":"5 Port to v0.5.0","text":"The new version does, however, include a new UI tool that can be used to visualize model results.  This explore function is described in the User Guide under Advanced Topics.","category":"page"},{"location":"howto/howto_5/#Advanced-Topics-1","page":"5 Port to v0.5.0","title":"Advanced Topics","text":"","category":"section"},{"location":"howto/howto_5/#Timesteps-and-available-functions-1","page":"5 Port to v0.5.0","title":"Timesteps and available functions","text":"","category":"section"},{"location":"howto/howto_5/#","page":"5 Port to v0.5.0","title":"5 Port to v0.5.0","text":"As previously mentioned, some relevant function names have changed.  These changes were made to eliminate ambiguity.  For example, the new naming clarifies that is_last returns whether the timestep is on the last valid period to be run, not whether it has run through that period already.  This check can still be achieved with is_finished, which retains its name and function.  Below is a subset of such changes related to timesteps and available functions.","category":"page"},{"location":"howto/howto_5/#","page":"5 Port to v0.5.0","title":"5 Port to v0.5.0","text":"Old Syntax New Syntax\nisstart is_first\nisstop is_last","category":"page"},{"location":"howto/howto_5/#","page":"5 Port to v0.5.0","title":"5 Port to v0.5.0","text":"As mentioned in earlier in this document, the fourth argument in run_timestep is an AbstractTimestep i.e. a FixedTimestep or a VariableTimestep and is a type defined within Mimi in \"src/time.jl\".  In this version, the fourth argument (t below) can no longer always be used simply as an Int. Defining the AbstractTimestep object as t, indexing with t is still permitted, but special care must be taken when comparing t with conditionals or using it in arithmatic expressions.  Since differential equations are commonly used as the basis for these models' equations, the most commonly needed change will be changing if t == 1 to if is_first(t).","category":"page"},{"location":"howto/howto_5/#","page":"5 Port to v0.5.0","title":"5 Port to v0.5.0","text":"The full API:","category":"page"},{"location":"howto/howto_5/#","page":"5 Port to v0.5.0","title":"5 Port to v0.5.0","text":"you may index into a variable or parameter with [t] or [t +/- x] as usual\nto access the time value of t (currently a year) as a Number, use gettime(t)\nuseful functions for commonly used conditionals are is_first(t) and is_last(t)\nto access the index value of t as a Number representing the position in the time array, use t.t.  Users are encouraged to avoid this access, and instead use the options listed above or a separate counter variable. each time the function gets called.  ","category":"page"},{"location":"howto/howto_5/#Parameter-connections-between-different-length-components-1","page":"5 Port to v0.5.0","title":"Parameter connections between different length components","text":"","category":"section"},{"location":"howto/howto_5/#More-on-parameter-indices-1","page":"5 Port to v0.5.0","title":"More on parameter indices","text":"","category":"section"},{"location":"howto/howto_5/#Updating-an-external-parameter-1","page":"5 Port to v0.5.0","title":"Updating an external parameter","text":"","category":"section"},{"location":"howto/howto_5/#","page":"5 Port to v0.5.0","title":"5 Port to v0.5.0","text":"To update an external parameter, use the functions update_param! and udpate_params! (previously known as update_external_parameter and update_external_parameters, respectively.)  Their calling signatures are:","category":"page"},{"location":"howto/howto_5/#","page":"5 Port to v0.5.0","title":"5 Port to v0.5.0","text":"update_params!(md::ModelDef, parameters::Dict; update_timesteps = false)\nupdate_param!(md::ModelDef, name::Symbol, value; update_timesteps = false)","category":"page"},{"location":"howto/howto_5/#","page":"5 Port to v0.5.0","title":"5 Port to v0.5.0","text":"For external parameters with a :time dimension, passing update_timesteps=true indicates that the time keys (i.e., year labels) should also be updated in addition to updating the parameter values.","category":"page"},{"location":"howto/howto_5/#Setting-parameters-with-a-dictionary-1","page":"5 Port to v0.5.0","title":"Setting parameters with a dictionary","text":"","category":"section"},{"location":"howto/howto_5/#","page":"5 Port to v0.5.0","title":"5 Port to v0.5.0","text":"The function set_leftover_params! replaces the function setleftoverparameters.","category":"page"},{"location":"ref/ref_structures/#Reference-Guide:-Structures-1","page":"Structures","title":"Reference Guide: Structures","text":"","category":"section"},{"location":"ref/ref_structures/#","page":"Structures","title":"Structures","text":"This document (along with \"structures2definitions\" and \"structures3instances\") describes the core data structures used to implement in Mimi 1.0.","category":"page"},{"location":"ref/ref_structures/#","page":"Structures","title":"Structures","text":"Prior versions of Mimi supported only \"flat\" models, i.e., with one level of components. The current version supports mulitple layers of components, with some components being \"final\" or leaf components, and others being \"composite\" components which themselves contain other leaf or composite components. This approach allows for a cleaner organization of complex models, and allows the construction of building blocks that can be re-used in multiple models.","category":"page"},{"location":"ref/ref_structures/#","page":"Structures","title":"Structures","text":"To the degree possible, composite components are designed to operate the same as leaf components, though there are necessarily differences:","category":"page"},{"location":"ref/ref_structures/#","page":"Structures","title":"Structures","text":"Leaf components are defined using the macro @defcomp, while composites are defined using @defcomposite. Each macro supports syntax and semantics specific to the type of component. See below for more details on these macros.\nLeaf composites support user-defined run_timestep() functions, whereas composites have a built-in run_timestep() function that iterates over its subcomponents and calls their run_timestep() function. The init() function is handled analogously.","category":"page"},{"location":"ref/ref_structures/#Classes.jl-1","page":"Structures","title":"Classes.jl","text":"","category":"section"},{"location":"ref/ref_structures/#","page":"Structures","title":"Structures","text":"Most of the core data structures are defined using the Classes.jl package, which was developed for Mimi, but separated out as a generally useful julia package. The main features of Classes are:","category":"page"},{"location":"ref/ref_structures/#","page":"Structures","title":"Structures","text":"Classes can subclass other classes, thereby inheriting the same list of fields as a starting point, which can then be extended with further fields.\nA type hierarchy is defined automatically that allows classes and subclasses to be referenced with a single type. In short, if you define a class Foo, an abstract type called AbstractFoo is defined, along with the concrete class Foo. If you subclass Foo (say with the class Bar), then AbstractBar will be a subtype of AbstractFoo, allowing methods to be defined that operate on both the superclass and subclass. See the Classes.jl documentation for further details.","category":"page"},{"location":"ref/ref_structures/#","page":"Structures","title":"Structures","text":"For example, in Mimi, ModelDef is a subclass of CompositeComponentDef, which in turn is a subclass of ComponentDef. Thus, methods can be written with arguments typed x::ComponentDef to operate on leaf components only, or x::AbstractCompositeComponentDef to operate on composites and ModelDef, or as x::AbstractComponentDef to operate on all three concrete types.","category":"page"},{"location":"ref/ref_structures/#Core-types-1","page":"Structures","title":"Core types","text":"","category":"section"},{"location":"ref/ref_structures/#","page":"Structures","title":"Structures","text":"Several core types are defined in types/core.jl, including the two primary abstract types, MimiStruct and MimiClass. ","category":"page"},{"location":"ref/ref_structures/#","page":"Structures","title":"Structures","text":"All structs and classes in Mimi are derived from these abstract types, which allows us to identify Mimi-defined items when writing show() methods. Important structs and classes include:","category":"page"},{"location":"ref/ref_structures/#","page":"Structures","title":"Structures","text":"ComponentId\nTo identify components, @defcomp creates a variable with the name of  the component whose value is an instance of this type. The definition is:\njulia  struct ComponentId <: MimiStruct      module_obj::Union{Nothing, Module}      comp_name::Symbol  end\nComponentPath\nA ComponentPath identifies the path from one or more composites to any component, using an NTuple of symbols. Since component names are unique at the composite level, the sequence of names through a component hierarchy uniquely identifies a component in that hierarchy.\njulia  struct ComponentPath <: MimiStruct      names::NTuple{N, Symbol} where N  end","category":"page"},{"location":"ref/ref_structures_instances/#Reference-Guide:-Structures-Instances-1","page":"Structures: Instances","title":"Reference Guide: Structures - Instances","text":"","category":"section"},{"location":"ref/ref_structures_instances/#Models-and-Components-1","page":"Structures: Instances","title":"Models and Components","text":"","category":"section"},{"location":"ref/ref_structures_instances/#","page":"Structures: Instances","title":"Structures: Instances","text":"# ComponentInstance\ncomp_name::Symbol\ncomp_id::ComponentID\ncomp_path::ComponentPath (from top (model) down)\nfirst::Int\nlast::Int\n\n# LeafComponentInstance <: ComponentInstance\nvariables::ComponentInstanceVariables\nparameters::ComponentInstanceParameters\ninit::Union{Nothing, Function}\nrun_timestep::Union{Nothing, Function}\n\n# CompositeComponentInstance <: ComponentInstance\ncomps_dict::OrderedDict{Symbol, ComponentInstance}\nparameters::NamedTuple\nvariables::NamedTuple\n\n# ModelInstance <: CompositeComponentInstance\nmd::ModelDef","category":"page"},{"location":"ref/ref_structures_instances/#Datum-1","page":"Structures: Instances","title":"Datum","text":"","category":"section"},{"location":"ref/ref_structures_instances/#","page":"Structures: Instances","title":"Structures: Instances","text":"# ComponentInstanceParameters (only exist in leaf component instances)\nnt::NamedTuple{Tuple{Symbol}, Tuple{Type}}    # Type is either ScalarModelParameter (for scalar parameters) or TimestepArray (for array parameters)\ncomp_paths::Vector{ComponentPath}\n\n# ComponentInstanceVariables (only exist in leaf component instances)\nnt::NamedTuple{Tuple{Symbol}, Tuple{Type}}  # Type is either ScalarModelParameter (for scalar variables) or TimestepArray (for array variables)\ncomp_paths::Vector{ComponentPath}","category":"page"},{"location":"ref/ref_structures_instances/#","page":"Structures: Instances","title":"Structures: Instances","text":"Note: in the ComponentInstanceParameters, the values stored in the named tuple point to the actual variable arrays in the other components for things that are internally connected, or to the actual value stored in the mi.md.external_params dictionary if it's an external parameter. (So I'm not sure what the component paths are there for, because the component path seems to always reference the current component, even if the parameter data tehcnically originates from a different component.)","category":"page"},{"location":"ref/ref_structures_instances/#User-facing-Classes-1","page":"Structures: Instances","title":"User-facing Classes","text":"","category":"section"},{"location":"ref/ref_structures_instances/#","page":"Structures: Instances","title":"Structures: Instances","text":"Model: The Model class contains the ModelDef, and after the build() function is called, a ModelInstance that can be run. The API for Model delegates many calls to either its top-level ModeDef or ModelInstance, while providing additional functionality including running a Monte Carlo simulation.\nComponentReference\nVariableReference","category":"page"},{"location":"howto/howto_main/#How-to-Guides-Introduction-1","page":"How-to Guides Intro","title":"How-to Guides Introduction","text":"","category":"section"},{"location":"howto/howto_main/#","page":"How-to Guides Intro","title":"How-to Guides Intro","text":"The following how-to guides provide steps to work through several common real-world problems that Mimi is targeted at solving. They are a bit less detailed than the tutorials, and are thus targeted at a user with some level of experience with Mimi (likely obtained through moving through some or all of the tutorials). ","category":"page"},{"location":"howto/howto_main/#","page":"How-to Guides Intro","title":"How-to Guides Intro","text":"If you find a bug in these guides, or have a clarifying question or suggestion, please reach out via Github Issues or our Mimi Framework forum.  We welcome your feedback.","category":"page"},{"location":"howto/howto_main/#Available-How-to-Guides-1","page":"How-to Guides Intro","title":"Available How-to Guides","text":"","category":"section"},{"location":"howto/howto_main/#","page":"How-to Guides Intro","title":"How-to Guides Intro","text":"How-to Guide 1: Construct and Run a Model ","category":"page"},{"location":"howto/howto_main/#","page":"How-to Guides Intro","title":"How-to Guides Intro","text":"How-to Guide 2: View and Explore Model Results ","category":"page"},{"location":"howto/howto_main/#","page":"How-to Guides Intro","title":"How-to Guides Intro","text":"How-to Guide 3: Conduct Sensitivity Analysis","category":"page"},{"location":"howto/howto_main/#","page":"How-to Guides Intro","title":"How-to Guides Intro","text":"How-to Guide 4: Work with Timesteps, Parameters, and Variables","category":"page"},{"location":"howto/howto_main/#","page":"How-to Guides Intro","title":"How-to Guides Intro","text":"How-to Guide 5: Port to Mimi v0.5.0","category":"page"},{"location":"howto/howto_main/#","page":"How-to Guides Intro","title":"How-to Guides Intro","text":"How-to Guide 6: Port from (>=) Mimi v0.5.0 to Mimi v1.0.0","category":"page"},{"location":"internals/proposals/#Not-Implemented-(Yet)-1","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"This section describes proposed API and file formats that haven't been developed yet.","category":"page"},{"location":"internals/proposals/#ModelRunner-1","page":"Not Implemented (Yet)","title":"ModelRunner","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"There are several types of analyses that require an ensemble of model runs performed over a set of parameter values. These include traditional Monte Carlo simulation, in which random values are drawn from distributions and applied to model parameters, as well as global sensitivity analyses that use prescribed methods for defining trial data (e.g., Sobol sampling), and Markov Chain Monte Carlo, which computes new trial data based on prior model results.","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"The abstract type ModelRunner will be used to define a generic API for model runners, including support for parallelization of analyses on multiprocessors and cluster computing systems. The specific sampling and analysis methods required for each subtype of ModelRunner will be defined in the concrete subtype, e.g., SimulationRunner.","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"The generic process will look something like this:","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"m = ModelDef(...)\nr = SimRunner(m)\n\n# Optionally redefine random variables, overriding defaults\nsetrv!(r, :rvname1, Normal(10, 3))\n\n# Optionally assign an alternative RV or distribution to a model parameter\nsetparam!(r, :comp1, :param1, :rvname1)\nsetparam!(r, :comp1, :param2, Uniform(0, 3))\n\n# Adjust what should be saved per model run\n@add_results(r, param10, param11[US])\n@drop_results(r, param1, param1)\n\n# Run trials 1-5000. Also can specify as a range (e.g., 5001:10000) \n# or vector of trial numbers.\nrun!(r, 5000)\n\n# Save results to the indicated directory\nwrite(r, dirname)","category":"page"},{"location":"internals/proposals/#Saving-ensemble-results-1","page":"Not Implemented (Yet)","title":"Saving ensemble results","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"Ensemble results will be stored in an object of type EnsembleResult, which is used by all subtypes of ModelRunner. By default, only model outputs tagged for output will be saved in the EnsembleResult instance. Parameters can be identified as \"output\" parameters in @defsim, and/or directly in a concrete subtype of ModelRunner, in which case default values set in @defsim can be overridden.","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"The method write(r::ModelRunner, dirname::String) will save model results to set of CSV files in the named directory. Initially, we will store the data in tidy format in which variables are in columns and each row represents an observation. This format is verbose but flexible and commonly used by consumers of data such as plotting packages. Other formats can be generated if the need arises.","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"In the initial implementation, results will be saved as follows:","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"Scalar model results will be written to \"$dirname/scalars.csv\". The file will have a column holding the trial number, and one column labeled with each parameter name. Each row in the file will contain all scalar parameter values data for a single  model run. \nExample:\ntrialnum foo bar baz ...\n1 1.6 0.4 110 ...\nAlternatively, we could flatten to 3 columns: \ntrialnum paramname value\n1 foo 1.6\n1 bar 0.4\n1 baz 110\nAll model results with a single time dimension will be written to \"$dirname/timeseries.csv\", with columns:\ntrialnum year foo bar baz ...\n1 2010 100.6 41.6 9.1 ...\n1 2015 101.7 44.5 10.2 ...\n1 2020 102.8 50.1 12.4 ...\n... ... ... ... ... ...\n2 2010 101.6 43.7 10.4 ...\n2 2015 102.4 60.1 21.3 ...\n2 2020 105.7 55.3 14.2 ...\n... ... ... ... ... ...\nAs with scalar results, this might be flattened further to:\ntrialnum paramname year value\n1 foo 2010 100.6\n1 foo 2015 101.7\n1 foo 2020 102.8\n... ... ... ...\n2 foo 2010 101.6\n2 foo 2015 102.4\n2 foo 2020 105.7\n... ... ... ...\nAnother alternative would be to store each timeseries result to its own CSV file, in which case the second (flattened) format would be used, minus the \"paramname\" column, which would be implicit from the filename. This would be more consistent with the matrix format below, since a timeseries result is just a matrix result with only one dimension.\nMatrix results will be saved to individual files named \"$dirname/$paramname.csv\". Matrices will be flattened so that each dimension appears as a column. For example, a matrix with dimensions \"time\" and \"region\" will have columns \"trialnum\", \ntrialnum region year value\n1 US 2010 1.1\n1 US 2015 1.9\n...   \n1 CHI 2010 0.2\n1 CHI 2015 0.8\n...   \nAnother option for saving ensemble outputs might include writing to any \"sink\" type that accepts named tuples.","category":"page"},{"location":"internals/proposals/#Model-result-file-format-1","page":"Not Implemented (Yet)","title":"Model result file format","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"To facilitate post-processing, model results will be saved to files in either JSON formats, as detailed below. To save results, the following methods can be used.","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"For individual model runs, results can be saved to a single file, or added to an existing file. For SA simulations, a single JSON file will hold the subset  of results specified by the user, for each trial. This may become unwieldy, but we support gzipped JSON, which helps a bit: if a filename ends in  .gz, it will automatically be zipped on writing and gzipped on reading.","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"saveresults(m::Model, pathname::String)\n\nsaveresults(m::Model, pathname::String, append=true)\n\nsaveresults(sim:Simulation, pathname::String)","category":"page"},{"location":"internals/proposals/#JSON-file-format-1","page":"Not Implemented (Yet)","title":"JSON file format","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"The JSON file format is basically a set of nested dictionaries, with a few lists at the innermost levels. We assign names to these levels for clarity of exposition in this documentation, but these names do not exist in the actual files.","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"We specify dicttype=DataStructures.OrderedDict when reading and writing JSON files to ensure that insertion order is maintained.","category":"page"},{"location":"internals/proposals/#Scenario-dict-1","page":"Not Implemented (Yet)","title":"Scenario dict","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"The top level of the JSON file is a dictionary keyed by scenario name (for non-SA results) or trial number (basically a numeric scenario name) for SA results.","category":"page"},{"location":"internals/proposals/#Index-Variable-Parameter-(IVP)-dict-1","page":"Not Implemented (Yet)","title":"Index-Variable-Parameter (IVP) dict","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"The value of the top-level dictionary is a dictionary whose keys are types of model inputs and results, which is currently one of \"Index\", \"Variable\", or \"Parameter\" of these dictionaries vary by the type of object stored, as shown below.","category":"page"},{"location":"internals/proposals/#Index-dict-1","page":"Not Implemented (Yet)","title":"Index dict","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"An index dict is keyed by index name (e.g., \"time\", \"region\") with values being lists of index values. For example the \"time\" index might look like this:","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"\"time\" : [2010, 2011, 2012, 2013, ..., 2099, 2100]","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"These are converted to Index objects upon reading.","category":"page"},{"location":"internals/proposals/#Variable-dict-1","page":"Not Implemented (Yet)","title":"Variable dict","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"Variable dicts are keyed by a string of the form \"$component_name:$variable_name\" (tuple keys are not supported in JSON). Values are single numerical values for scalar parameters, or for vector and matrix values, a list of lists of the form [[dimensions...], [values...]] where dimensions. Examples:","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"{\n # Scalar\n \"foo\" : 42,\n\n # one dimension\n \"bar\" : [[\"region\"], [4.1, 7.2, 3.6, 9.4, 5.5, 7.6, ...],\n\n # two dimensions are stored as arrays of arrays\n \"baz\" : [\n   [\"time\", \"region\"], \n   [[4.1, 7.2, 3.6, ...], # values by region for first timestep\n    [3.5, 6.3, 5.6, ...], # values by region for 2nd timestep\n    ...]\n  ]\n}","category":"page"},{"location":"internals/proposals/#Parameter-dict-1","page":"Not Implemented (Yet)","title":"Parameter dict","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"Parameter dicts are keyed by \"external\" names (symbols), with values represented in the same format as shown above for Variable dicts.","category":"page"},{"location":"ref/ref_API/#Reference-Guide:-The-Mimi-API-1","page":"Mimi API","title":"Reference Guide: The Mimi API","text":"","category":"section"},{"location":"ref/ref_API/#","page":"Mimi API","title":"Mimi API","text":"@defcomp\nMarginalModel\nModel\nadd_comp!  \nconnect_param!\ncreate_marginal_model\ndim_count\ndim_keys\ndim_key_dict\ndisconnect_param!\nexplore\ngetdataframe\ngettime\nget_param_value\nget_var_value\nhasvalue\nis_first\nis_last\nmodeldef\nparameter_names\nparameter_dimensions\nreplace!\nset_dimension! \nset_leftover_params! \nset_param! \nTimestepIndex\nTimestepValue\nvariable_dimensions\nvariable_names\nupdate_param!\nupdate_params!","category":"page"},{"location":"ref/ref_API/#Mimi.@defcomp","page":"Mimi API","title":"Mimi.@defcomp","text":"defcomp(comp_name::Symbol, ex::Expr)\n\nDefine a Mimi component comp_name with the expressions in ex.  The following  types of expressions are supported:\n\ndimension_name = Index()   # defines a dimension\nparameter = Parameter(index = [dimension_name], units = \"unit_name\", default = default_value)    # defines a parameter with optional arguments\nvariable = Variable(index = [dimension_name], units = \"unit_name\")    # defines a variable with optional arguments\ninit(p, v, d)              # defines an init function for the component\nrun_timestep(p, v, d, t)   # defines a run_timestep function for the component\n\nParses a @defcomp definition, converting it into a series of function calls that create the corresponding ComponentDef instance. At model build time, the ModelDef (including its ComponentDefs) will be converted to a runnable model.\n\n\n\n\n\n","category":"macro"},{"location":"ref/ref_API/#Mimi.MarginalModel","page":"Mimi API","title":"Mimi.MarginalModel","text":"MarginalModel\n\nA Mimi Model whose results are obtained by subtracting results of one base Model from those of another marginal Model that has a difference of delta.\n\n\n\n\n\n","category":"type"},{"location":"ref/ref_API/#Mimi.Model","page":"Mimi API","title":"Mimi.Model","text":"Model\n\nA user-facing API containing a ModelInstance (mi) and a ModelDef (md). This Model can be created with the optional keyword argument number_type indicating the default type of number used for the ModelDef.  If not specified the Model assumes a number_type of Float64.\n\n\n\n\n\n","category":"type"},{"location":"ref/ref_API/#Mimi.add_comp!","page":"Mimi API","title":"Mimi.add_comp!","text":"add_comp!(\n    obj::AbstractCompositeComponentDef,\n    comp_def::AbstractComponentDef,\n    comp_name::Symbol=comp_def.comp_id.comp_name;\n    before::NothingSymbol=nothing,\n    after::NothingSymbol=nothing,\n    rename::NothingPairList=nothing\n)\n\nAdd the component comp_def to the composite component indicated by obj. The component is added at the end of the list unless one of the keywords before or after is specified. Note that a copy of comp_id is made in the composite and assigned the give name. The optional argument rename can be a list of pairs indicating original_name => imported_name.\n\n\n\n\n\nadd_comp!(\n    obj::AbstractCompositeComponentDef,\n    comp_id::ComponentId,\n    comp_name::Symbol=comp_id.comp_name;\n    before::NothingSymbol=nothing,\n    after::NothingSymbol=nothing,\n    rename::NothingPairList=nothing\n)\n\nAdd the component indicated by comp_id to the composite component indicated by obj. The component is added at the end of the list unless one of the keywords before or after is specified. Note that a copy of comp_id is made in the composite and assigned the give name.\n\n[Not yet implemented:] The optional argument rename can be a list of pairs indicating original_name => imported_name.\n\n\n\n\n\nadd_comp!(obj::AbstractCompositeComponentInstance, ci::AbstractComponentInstance)\n\nAdd the (leaf or composite) component ci to a composite's list of components.\n\n\n\n\n\nadd_comp!(\n    m::Model, comp_id::ComponentId, comp_name::Symbol=comp_id.comp_name;\n    before::NothingSymbol=nothing,\n    after::NothingSymbol=nothing,\n    rename::NothingPairList=nothing\n)\n\nAdd the component indicated by comp_id to the model indicated by m. The component is added at the end of the list unless one of the keywords before or after is specified. Note that a copy of comp_id is made in the composite and assigned the give name. The optional argument rename can be a list of pairs indicating original_name => imported_name.\n\n\n\n\n\nadd_comp!(\n    m::Model, comp_def::AbstractComponentDef, comp_name::Symbol=comp_id.comp_name;\n    before::NothingSymbol=nothing,\n    after::NothingSymbol=nothing,\n    rename::NothingPairList=nothing\n)\n\nAdd the component comp_def to the model indicated by m. The component is added at the end of the list unless one of the keywords, first, last, before, after. Note that a copy of comp_id is made in the composite and assigned the give name. The optional argument rename can be a list of pairs indicating original_name => imported_name.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.connect_param!","page":"Mimi API","title":"Mimi.connect_param!","text":"connect_param!(obj::AbstractCompositeComponentDef, comp_name::Symbol, param_name::Symbol, ext_param_name::Symbol;\n               check_labels::Bool=true)\n\nConnect a parameter param_name in the component comp_name of composite obj to the external parameter ext_param_name.\n\n\n\n\n\nconnect_param!(obj::AbstractCompositeComponentDef,\n    dst::Pair{Symbol, Symbol}, src::Pair{Symbol, Symbol},\n    backup::Union{Nothing, Array}=nothing;\n    ignoreunits::Bool=false, offset::Int=0)\n\nBind the parameter dst[2] of one component dst[1] of composite obj to a variable src[2] in another component src[1] of the same composite using backup to provide default values and the ignoreunits flag to indicate the need to check match units between the two.  The offset argument indicates the offset between the destination and the source ie. the value would be 1 if the destination component parameter should only be calculated for the second timestep and beyond.\n\n\n\n\n\nconnect_param!(dst::ComponentReference, dst_name::Symbol, src::ComponentReference, src_name::Symbol)\n\nConnect two components as connect_param!(dst, dst_name, src, src_name).\n\n\n\n\n\nconnect_param!(dst::ComponentReference, src::ComponentReference, name::Symbol)\n\nConnect two components with the same name as connect_param!(dst, src, name).\n\n\n\n\n\nconnect_param!(m::Model, dst_comp_name::Symbol, dst_par_name::Symbol, src_comp_name::Symbol, src_var_name::Symbol, \nbackup::Union{Nothing, Array}=nothing; ignoreunits::Bool=false, offset::Int=0)\n\nBind the parameter dst_par_name of one component dst_comp_name of model m to a variable src_var_name in another component src_comp_name of the same model using backup to provide default values and the ignoreunits flag to indicate the need to check match units between the two.  The offset argument indicates the offset between the destination and the source ie. the value would be 1 if the destination component parameter should only be calculated for the second timestep and beyond.\n\n\n\n\n\nconnect_param!(m::Model, comp_name::Symbol, param_name::Symbol, ext_param_name::Symbol)\n\nBind the parameter param_name in the component comp_name of model m to the external parameter  ext_param_name already present in the model's list of external parameters.\n\n\n\n\n\nconnect_param!(m::Model, dst::Pair{Symbol, Symbol}, src::Pair{Symbol, Symbol}, backup::Array; ignoreunits::Bool=false)\n\nBind the parameter dst[2] of one component dst[1] of model m to a variable src[2] in another component src[1] of the same model using backup to provide default values and the ignoreunits flag to indicate the need to check match units between the two.  The offset argument indicates the offset between the destination and the source ie. the value would be 1 if the destination component parameter should only be calculated for the second timestep and beyond.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.create_marginal_model","page":"Mimi API","title":"Mimi.create_marginal_model","text":"create_marginal_model(base::Model, delta::Float64=1.0)\n\nCreate a MarginalModel where base is the baseline model and delta is the difference used to create the marginal model.  Return the resulting MarginaModel which shares the internal ModelDef between the base and marginal.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.dim_count","page":"Mimi API","title":"Mimi.dim_count","text":"dim_count(mi::ModelInstance, dim_name::Symbol)\n\nReturn the size of index dim_name in model instance mi.\n\n\n\n\n\ndim_count(m::Model, dim_name::Symbol)\n\nReturn the size of index dim_name in model m.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.dim_keys","page":"Mimi API","title":"Mimi.dim_keys","text":"dim_keys(m::Model, dim_name::Symbol)\n\nReturn keys for dimension dim-name in model m.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.dim_key_dict","page":"Mimi API","title":"Mimi.dim_key_dict","text":"dim_key_dict(m::Model)\n\nReturn a dict of dimension keys for all dimensions in model m.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.disconnect_param!","page":"Mimi API","title":"Mimi.disconnect_param!","text":"disconnect_param!(obj::AbstractCompositeComponentDef, comp_def::AbstractComponentDef, param_name::Symbol)\n\nRemove any parameter connections for a given parameter param_name in a given component comp_def which must be a direct subcomponent of composite obj.\n\n\n\n\n\ndisconnect_param!(obj::AbstractCompositeComponentDef, comp_name::Symbol, param_name::Symbol)\n\nRemove any parameter connections for a given parameter param_name in a given component comp_def which must be a direct subcomponent of composite obj.\n\n\n\n\n\ndisconnect_param!(m::Model, comp_name::Symbol, param_name::Symbol)\n\nRemove any parameter connections for a given parameter param_name in a given component comp_def in model m.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.explore","page":"Mimi API","title":"Mimi.explore","text":"explore(m::Model; title = \"Electron\")\n\nProduce a UI to explore the parameters and variables of Model m in a Window with title title.\n\n\n\n\n\nexplore(sim_inst::SimulationInstance; title=\"Electron\", model_index::Int = 1, scen_name::Union{Nothing, String} = nothing, results_output_dir::Union{Nothing, String} = nothing)\n\nProduce a UI to explore the output distributions of the saved variables in SimulationInstance sim for results of model model_index and scenario with the name scen_name in a Window with title title. The optional arguments default to a model_index of 1, a scen_name of nothing  assuming there is no secenario dimension, and a window with title Electron.   The results_output_dir keyword argument refers to the main output directory as provided to run,  where all subdirectories are held. If provided, results are assumed to be stored there, otherwise it is  assumed that results are held in results.sim and not  in an output folder.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.getdataframe","page":"Mimi API","title":"Mimi.getdataframe","text":"getdataframe(m::AbstractModel, comp_name::Symbol, pairs::Pair{Symbol, Symbol}...)\n\nReturn a DataFrame with values for the given variables or parameters of model m indicated by pairs, where each pair is of the form comp_name => item_name. If more than one pair is provided, all must refer to items with the same dimensions, which are used to join the respective item values.\n\n\n\n\n\ngetdataframe(m::AbstractModel, pair::Pair{Symbol, NTuple{N, Symbol}})\n\nReturn a DataFrame with values for the given variables or parameters  indicated by pairs, where each pair is of the form comp_name => item_name. If more than one pair is provided, all must refer to items with the same dimensions, which are used to join the respective item values.\n\n\n\n\n\ngetdataframe(m::AbstractModel, comp_name::Symbol, item_name::Symbol)\n\nReturn the values for variable or parameter item_name in comp_name of  model m as a DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.gettime","page":"Mimi API","title":"Mimi.gettime","text":"gettime(ts::FixedTimestep)\n\nReturn the time (year) represented by Timestep ts \n\n\n\n\n\ngettime(ts::VariableTimestep)\n\nReturn the time (year) represented by Timestep ts \n\n\n\n\n\ngettime(c::Clock)\n\nReturn the current time of the timestep held by the c clock.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.get_param_value","page":"Mimi API","title":"Mimi.get_param_value","text":"get_param_value(ci::AbstractComponentInstance, name::Symbol)\n\nReturn the value of parameter name in (leaf or composite) component ci.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.get_var_value","page":"Mimi API","title":"Mimi.get_var_value","text":"get_var_value(ci::AbstractComponentInstance, name::Symbol)\n\nReturn the value of variable name in component ci.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.hasvalue","page":"Mimi API","title":"Mimi.hasvalue","text":"hasvalue(arr::TimestepArray, ts::FixedTimestep)\n\nReturn true or false, true if the TimestepArray arr contains the Timestep ts.\n\n\n\n\n\nhasvalue(arr::TimestepArray, ts::VariableTimestep)\n\nReturn true or false, true if the TimestepArray arr contains the Timestep ts.\n\n\n\n\n\nhasvalue(arr::TimestepArray, ts::FixedTimestep, idxs::Int...)\n\nReturn true or false, true if the TimestepArray arr contains the Timestep ts within indices idxs. Used when Array and Timestep have different FIRST, validating all dimensions.\n\n\n\n\n\nhasvalue(arr::TimestepArray, ts::VariableTimestep, idxs::Int...)\n\nReturn true or false, true if the TimestepArray arr contains the Timestep ts within indices idxs. Used when Array and Timestep different TIMES, validating all dimensions.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.is_first","page":"Mimi API","title":"Mimi.is_first","text":"is_first(ts::AbstractTimestep)\n\nReturn true or false, true if ts is the first timestep to be run.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.is_last","page":"Mimi API","title":"Mimi.is_last","text":"is_last(ts::FixedTimestep)\n\nReturn true or false, true if ts is the last timestep to be run.\n\n\n\n\n\nis_last(ts::VariableTimestep)\n\nReturn true or false, true if ts is the last timestep to be run.  Note that you may run next_timestep on ts, as ths final timestep has not been run through yet.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.modeldef","page":"Mimi API","title":"Mimi.modeldef","text":"modeldef(mi)\n\nReturn the ModelDef contained by ModelInstance mi.\n\n\n\n\n\nmodeldef(m)\n\nReturn the ModelDef contained by Model m.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.parameter_names","page":"Mimi API","title":"Mimi.parameter_names","text":"parameter_names(md::ModelDef, comp_name::Symbol)\n\nReturn a list of all parameter names for a given component comp_name in a model def md.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.parameter_dimensions","page":"Mimi API","title":"Mimi.parameter_dimensions","text":"parameter_dimensions(obj::AbstractComponentDef, param_name::Symbol)\n\nReturn the names of the dimensions of parameter param_name exposed in the component definition indicated by obj.\n\n\n\n\n\nparameter_dimensions(obj::AbstractComponentDef, comp_name::Symbol, param_name::Symbol)\n\nReturn the names of the dimensions of parameter param_name in component comp_name, which is exposed in composite component definition indicated byobj.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Base.replace!","page":"Mimi API","title":"Base.replace!","text":"replace!(\n    m::Model,\n    old_new::Pair{Symbol, ComponentDef},\n    before::NothingSymbol=nothing,\n    after::NothingSymbol=nothing,\n    reconnect::Bool=true\n)\n\nFor the pair comp_name => comp_def in old_new, replace the component with name comp_name in  the model m with the new component specified by comp_def. The new component is added  in the same position as the old component, unless one of the keywords before or after is  specified for a different position. The optional boolean argument reconnect with default value  true indicates whether the existing parameter connections should be maintained in the new  component. Returns a ComponentReference for the added component.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.set_dimension!","page":"Mimi API","title":"Mimi.set_dimension!","text":"set_dimension!(ccd::CompositeComponentDef, name::Symbol, keys::Union{Int, Vector, Tuple, AbstractRange})\n\nSet the values of ccd dimension name to integers 1 through count, if keys is an integer; or to the values in the vector or range if keys is either of those types.\n\n\n\n\n\nset_dimension!(m::Model, name::Symbol, keys::Union{Vector, Tuple, AbstractRange})\n\nSet the values of m dimension name to integers 1 through count, if keysis an integer; or to the values in the vector or range ifkeys`` is either of those types.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.set_leftover_params!","page":"Mimi API","title":"Mimi.set_leftover_params!","text":"set_leftover_params!(m::Model, parameters::Dict)\n\nSet all of the parameters in model m that don't have a value and are not connected to some other component to a value from a dictionary parameters. This method assumes the dictionary keys are strings that match the names of unset parameters in the model.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.set_param!","page":"Mimi API","title":"Mimi.set_param!","text":"set_param!(md::ModelDef, comp_name::Symbol,\n           value_dict::Dict{Symbol, Any}, param_names)\n\nCall set_param!() for each name in param_names, retrieving the corresponding value from value_dict[param_name].\n\n\n\n\n\nset_param!(md::ModelDef, param_name::Symbol, value; dims=nothing)\n\nSet the value of a parameter in all components of the model that have a parameter of  the specified name.\n\nThe value can by a scalar, an array, or a NamedAray. Optional keyword argument 'dims' is a list of the dimension names of the provided data, and will be used to check that they match the model's index labels.\n\n\n\n\n\nset_param!(ref::ComponentReference, name::Symbol, value)\n\nSet a component parameter as set_param!(reference, name, value). This creates a unique name :compname_paramname in the model's external parameter list,  and sets the parameter only in the referenced component to that value.\n\n\n\n\n\nset_param!(m::Model, comp_name::Symbol, param_name::Symbol, value; dims=nothing)\n\nSet the parameter of a component comp_name in a model m to a given value. The value can by a scalar, an array, or a NamedAray. Optional keyword argument 'dims' is a list of the dimension names of the provided data, and will be used to check that they match the model's index labels.\n\n\n\n\n\nset_param!(m::Model, comp_name::Symbol, param_name::Symbol, ext_param_name::Symbol, value; dims=nothing)\n\nSet the parameter param_name of a component comp_name in a model m to a given value,  storing the value in the model's external parameter list by the provided name ext_param_name. The value can by a scalar, an array, or a NamedAray. Optional keyword argument 'dims' is a list of the dimension names of the provided data, and will be used to check that they match the model's index labels.\n\n\n\n\n\nset_param!(m::Model, param_name::Symbol, value; dims=nothing)\n\nSet the value of a parameter in all components of the model that have a parameter of  the specified name.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.TimestepIndex","page":"Mimi API","title":"Mimi.TimestepIndex","text":"TimestepIndex\n\nA user-facing type used to index into a TimestepArray in run_timestep functions, containing an Int index that indicates the position in the array in terms of timesteps.\n\n\n\n\n\n","category":"type"},{"location":"ref/ref_API/#Mimi.TimestepValue","page":"Mimi API","title":"Mimi.TimestepValue","text":"TimestepValue\n\nA user-facing type used to index into a TimestepArray in run_timestep functions, containing a value of the same Type as the times in the TimstepArray which is used to index into the array at that position, with an optional Int offset in terms of timesteps.\n\n\n\n\n\n","category":"type"},{"location":"ref/ref_API/#Mimi.variable_dimensions","page":"Mimi API","title":"Mimi.variable_dimensions","text":"variable_dimensions(obj::AbstractCompositeComponentDef, comp_path::ComponentPath, var_name::Symbol)\n\nReturn the names of the dimensions of variable var_name exposed in the composite component definition indicated byobj along the component path comp_path. The comp_path is of type Mimi.ComponentPath with the single field being an NTuple of symbols describing the relative (to a composite) or absolute (relative to ModelDef) path through composite nodes to specific composite or leaf node.\n\n\n\n\n\nvariable_dimensions(obj::AbstractCompositeComponentDef, comp::Symbol, var_name::Symbol)\n\nReturn the names of the dimensions of variable var_name exposed in the composite component definition indicated by obj for the component comp, which exists in a flat model.\n\n\n\n\n\nvariable_dimensions(obj::AbstractCompositeComponentDef, comp::Symbol, var_name::Symbol)\n\nReturn the names of the dimensions of variable var_name exposed in the composite component definition indicated by obj along the component path comp_path. The comp_path is a tuple of symbols describing the relative (to a composite) or absolute (relative to ModelDef) path through composite nodes to specific composite or leaf node.\n\n\n\n\n\nvariable_dimensions(obj::AbstractComponentDef, name::Symbol)\n\nReturn the names of the dimensions of variable name exposed in the component definition indicated by obj.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.variable_names","page":"Mimi API","title":"Mimi.variable_names","text":"variable_names(md::AbstractCompositeComponentDef, comp_name::Symbol)\n\nReturn a list of all variable names for a given component comp_name in a model def md.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.update_param!","page":"Mimi API","title":"Mimi.update_param!","text":"update_param!(obj::AbstractCompositeComponentDef, name::Symbol, value; update_timesteps = false)\n\nUpdate the value of an external model parameter in composite obj, referenced by name. Optional boolean argument update_timesteps with default value false indicates whether to update the time keys associated with the parameter values to match the model's time index.\n\n\n\n\n\nupdate_param!(m::Model, name::Symbol, value; update_timesteps = false)\n\nUpdate the value of an external model parameter in model m, referenced by name. Optional boolean argument update_timesteps with default value false indicates whether to update the time keys associated with the parameter values to match the model's time index.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.update_params!","page":"Mimi API","title":"Mimi.update_params!","text":"update_params!(obj::AbstractCompositeComponentDef, parameters::Dict{T, Any};\n               update_timesteps = false) where T\n\nFor each (k, v) in the provided parameters dictionary, update_param! is called to update the external parameter by name k to value v, with optional Boolean argument update_timesteps. Each key k must be a symbol or convert to a symbol matching the name of an external parameter that already exists in the component definition.\n\n\n\n\n\nupdate_params!(m::Model, parameters::Dict{T, Any}; update_timesteps = false) where T\n\nFor each (k, v) in the provided parameters dictionary, update_param!` is called to update the external parameter by name k to value v, with optional Boolean argument update_timesteps. Each key k must be a symbol or convert to a symbol matching the name of an external parameter that already exists in the model definition.\n\n\n\n\n\n","category":"function"},{"location":"howto/howto_4/#How-to-Guide-4:-Work-with-Timesteps,-Parameters,-and-Variables-1","page":"4 Timesteps, Params, and Vars","title":"How-to Guide 4: Work with Timesteps, Parameters, and Variables","text":"","category":"section"},{"location":"howto/howto_4/#Timesteps-and-available-functions-1","page":"4 Timesteps, Params, and Vars","title":"Timesteps and available functions","text":"","category":"section"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"An AbstractTimestep i.e. a FixedTimestep or a VariableTimestep is a type defined within Mimi in \"src/time.jl\". It is used to represent and keep track of time indices when running a model.","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"In the run_timestep functions which the user defines, it may be useful to use any of the following functions, where t is an AbstractTimestep object:","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"is_first(t) # returns true or false, true if t is the first timestep to be run\nis_last(t) # returns true or false, true if t is the last timestep to be run\ngettime(t) # returns the year represented by timestep t","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"There are also two helper types TimestepValue and TimestepIndex that can be used with comparison operators (==, <, and >) to check whether an AbstractTimestep t during the run_timestep function corresponds with a certain year or index number. For example:","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"if t > TimestepValue(2020)\n  # run this code only for timesteps after the year 2020\nend\n\nif t == TimestepIndex(3)\n  # run this code only during the third timestep\nend","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"See below for further discussion of the TimestepValue and TimestepIndex objects and how they should be used.","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"The API details for AbstractTimestep object t are as follows:","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"you may index into a variable or parameter with [t] or [t +/- x] as usual\nto access the time value of t (currently a year) as a Number, use gettime(t)\nuseful functions for commonly used conditionals are is_first(t) and is_last(t)\nto access the index value of t as a Number representing the position in the time array, use t.t.  Users are encouraged to avoid this access, and instead use comparisons with TimestepIndex objects to check if an AbstractTimestep t corresponds with a specific index number, as described above.","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"Indexing into a variable or parameter's time dimension with an Integer is deprecated and will soon error. Instead, users should take advantage of the TimestepIndex and TimestepValue types. For examples we will refer back to our component definition above, and repeated below.","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"@defcomp MyComponentName begin\n  regions = Index()\n\n  A = Variable(index = [time])\n  B = Variable(index = [time, regions])\n\n  c = Parameter()\n  d = Parameter(index = [time])\n  e = Parameter(index = [time, regions])\n  f = Parameter(index = [regions])\n\n  function run_timestep(p, v, d, t)\n    v.A[t] = p.c + p.d[t]\n    for r in d.regions\n      v.B[t, r] = p.f[r] * p.e[t, r]\n    end\n  end\n\nend","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"TimestepIndex has one field, index, which refers to the absolute index in the parameter or variable array's time dimension. Thus, constructing a TimestepIndex is done by simply writing TimestepIndex(index::Int). Looking back at our original component example one could modify the first line of run_timestep to always refer to the first timestep of p.d with the following. One may index into the time dimension with a single TimestepIndex, or an Array of them.","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"v.A[t] = p.c + p.d[TimestepIndex(1)]","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"TimestepValue has two fields, value and offset, referring to the value within the time dimension and an optional offset from that value. Thus, constructing a TimestepValue is done either by writing TimestepValue(value), with an implied offset of 0, or TimestepValue(value, offset = i::Int), with an explicit offset of i. One may index into the time dimension with a single TimestepValue, or an Array of them. For example, you can use a TimestepValue to keep track of a baseline year.","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"v.A[t] = p.c + p.d[TimestepValue(2000)]","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"You may also use shorthand to create arrays of TimestepIndex using Colon syntax.","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"TimestepIndex(1):TimestepIndex(10) # implicit step size of 1\nTimestepIndex(1):2:TimestepIndex(10) # explicit step of type Int ","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"Both TimestepIndex and TimestepArray have methods to support addition and subtraction of integers.  Note that the addition or subtraction is relative to the definition of the time dimension, so while TimestepIndex(1) + 1 == TimestepIndex(2), TimestepValue(2000) + 1 could be equivalent to TimestepValue(2001) if 2001 is the next year in the time dimension, or TimestepValue(2005) if the array has a step size of 5. Hence adding or subtracting is relative to the definition of the time dimension. ","category":"page"},{"location":"howto/howto_4/#DataType-specification-of-Parameters-and-Variables-1","page":"4 Timesteps, Params, and Vars","title":"DataType specification of Parameters and Variables","text":"","category":"section"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"By default, the Parameters and Variables defined by a user will be allocated storage arrays of type Float64 when a model is constructed. This default \"number_type\" can be overriden when a model is created, with the following syntax:","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"m = Model(Int64)    # creates a model with default number type Int64","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"But you can also specify individual Parameters or Variables to have different data types with the following syntax in a @defcomp macro:","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"@defcomp example begin\n  p1 = Parameter{Bool}()                         # ScalarModelParameter that is a Bool\n  p2 = Parameter{Bool}(index = [regions])        # ArrayModelParameter with one dimension whose eltype is Bool\n  p3 = Parameter{Matrix{Int64}}()                # ScalarModelParameter that is a Matrix of Integers\n  p4 = Parameter{Int64}(index = [time, regions]) # ArrayModelParameter with two dimensions whose eltype is Int64\nend","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"If there are \"index\"s listed in the Parameter definition, then it will be an ArrayModelParameter whose eltype is the type specified in the curly brackets. If there are no \"index\"s listed, then the type specified in the curly brackets is the actual type of the parameter value, and it will be represent by Mimi as a ScalarModelParameter.","category":"page"},{"location":"howto/howto_4/#More-on-parameter-indices-1","page":"4 Timesteps, Params, and Vars","title":"More on parameter indices","text":"","category":"section"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"As mentioned above, a parameter can have no index (a scalar), or one or multiple of the model's indexes. A parameter can also have an index specified in the following ways:","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"@defcomp MyComponent begin\n  p1 = Parameter(index=[4]) # an array of length 4\n  p2 = Parameter{Array{Float64, 2}}() # a two dimensional array of unspecified length\nend","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"In both of these cases, the parameter's values are stored of as an array (p1 is one dimensional, and p2 is two dimensional). But with respect to the model, they are considered \"scalar\" parameters, simply because they do not use any of the model's indices (namely 'time', or 'regions').","category":"page"},{"location":"howto/howto_4/#Updating-an-external-parameter-1","page":"4 Timesteps, Params, and Vars","title":"Updating an external parameter","text":"","category":"section"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"When set_param! is called, it creates an external parameter by the name provided, and stores the provided scalar or array value. It is possible to later change the value associated with that parameter name using the functions described below. If the external parameter has a :time dimension, use the optional argument update_timesteps=true to indicate that the time keys (i.e., year labels) associated with the parameter should be updated in addition to updating the parameter values.","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"update_param!(m, :ParameterName, newvalues) # update values only \nupdate_param!(m, :ParameterName, newvalues, update_timesteps=true) # also update time keys","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"Note: newvalues must be the same size and type (or be able to convert to the type) of the old values stored in that parameter.","category":"page"},{"location":"howto/howto_4/#Setting-parameters-with-a-dictionary-1","page":"4 Timesteps, Params, and Vars","title":"Setting parameters with a dictionary","text":"","category":"section"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"In larger models it can be beneficial to set some of the external parameters using a dictionary of values. To do this, use the following function:","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"set_leftover_params!(m, parameters)","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"Where parameters is a dictionary of type Dict{String, Any} where the keys are strings that match the names of the unset parameters in the model, and the values are the values to use for those parameters.","category":"page"},{"location":"howto/howto_4/#Using-NamedArrays-for-setting-parameters-1","page":"4 Timesteps, Params, and Vars","title":"Using NamedArrays for setting parameters","text":"","category":"section"},{"location":"howto/howto_4/#","page":"4 Timesteps, Params, and Vars","title":"4 Timesteps, Params, and Vars","text":"When a user sets a parameter, Mimi checks that the size and dimensions match what it expects for that component. If the user provides a NamedArray for the values, Mimi will further check that the names of the dimensions match the expected dimensions for that parameter, and that the labels match the model's index values for those dimensions. Examples of this can be found in \"test/testparameterlabels.jl\".","category":"page"},{"location":"howto/howto_2/#How-to-Guide-2:-View-and-Explore-Model-Results-1","page":"2 Explore Results","title":"How-to Guide 2: View and Explore Model Results","text":"","category":"section"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"This guide show show to access the numerical values of your results in a usable format, and also how to plot your results.","category":"page"},{"location":"howto/howto_2/#Accessing-Results-1","page":"2 Explore Results","title":"Accessing Results","text":"","category":"section"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"After a model has been run, you can access the results (the calculated variable values in each component) in a few different ways.","category":"page"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"You can use the getindex syntax as follows:","category":"page"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"m[:ComponentName, :VariableName] # returns the whole array of values\nm[:ComponentName, :VariableName][100] # returns just the 100th value","category":"page"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"Indexing into a model with the name of the component and variable will return an array with values from each timestep. You can index into this array to get one value (as in the second line, which returns just the 100th value). Note that if the requested variable is two-dimensional, then a 2-D array will be returned.","category":"page"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"You can also get data in the form of a dataframe, which will display the corresponding index labels rather than just a raw array. The syntax for this is:","category":"page"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"getdataframe(m, :ComponentName=>:Variable) # request one variable from one component\ngetdataframe(m, :ComponentName=>(:Variable1, :Variable2)) # request multiple variables from the same component\ngetdataframe(m, :Component1=>:Var1, :Component2=>:Var2) # request variables from different components","category":"page"},{"location":"howto/howto_2/#Plotting-and-the-Explorer-UI-1","page":"2 Explore Results","title":"Plotting and the Explorer UI","text":"","category":"section"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"Mimi provides support for plotting using VegaLite and VegaLite.jl.","category":"page"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"Plotting support is provided by the Explorer UI, rooted in VegaLite.  The explore function allows the user to view and explore the variables and parameters of a model run.  The explorer can be used in two primary ways.","category":"page"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"In order to invoke the explorer UI and explore all of the variables and parameters in a model, simply call the function explore with the model run as the required argument, and a window title as an optional keyword argument, as shown below.  This will produce a new browser window containing a selectable list of parameters and variables, organized by component, each of which produces a graphic.  The exception here being that if the parameter or variable is a single scalar value, the value will appear alongside the name in the left-hand list.","category":"page"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"run(m)\nexplore(m, title = \"run1 results\")","category":"page"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"(Image: Explorer Model Example)","category":"page"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"Alternatively, in order to view just one parameter or variable, call the (unexported) function Mimi.plot as below to return a plot object and automatically display the plot in a viewer, assuming Mimi.plot is the last command executed.  Note that plot is not exported in order to avoid namespace conflicts, but a user may import it if desired. This call will return the type VegaLite.VLSpec, which you may interact with using the API described in the VegaLite.jl documentation.  For example, VegaLite.jl plots can be saved as PNG, SVG, PDF and EPS files. You may save a plot using the save function.  ","category":"page"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"Note that saving an interactive plot in a non-interactive file format, such as .pdf or .svg will result in a warning WARN Can not resolve event source: window, but the plot will be saved as a static image. If you wish to preserve interactive capabilities, you may save it using the .vegalite file extension. If you then open this file in Jupyter lab, the interactive aspects will be preserved.","category":"page"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"using VegaLite\nrun(m)\np = Mimi.plot(m, :ComponentName, :ParameterName)\nsave(\"figure.svg\", p)","category":"page"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"(Image: Plot Model Example)","category":"page"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"These two functions, explore and plot also have methods applicable to the sensitivity analysis support described in the next section. Details can be found in the sensitivity analysis how-to guide How-to Guide 3: Conduct Sensitivity Analysis as well as Tutorial 4: Sensitivity Analysis (SA) Support.","category":"page"},{"location":"ref/ref_structures_definitions/#Reference-Guide:-Structures-Definitions-1","page":"Structures: Definitions","title":"Reference Guide: Structures - Definitions","text":"","category":"section"},{"location":"ref/ref_structures_definitions/#Model-Definition-1","page":"Structures: Definitions","title":"Model Definition","text":"","category":"section"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"Models are composed of two separate structures, which we refer to as the \"definition\" side and the \"instance\" or \"instantiated\" side. The definition side is operated on by the user via the @defcomp and @defcomposite macros, and the public API (add_comp!, set_param!, connect_param!, etc.).","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"The instantiated model can be thought of as a \"compiled\" version of the model definition, with its data structures oriented toward run-time efficiency. It is constructed by Mimi in the build() function, which is called by the run() function.","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"The public API sets a flag whenever the user modifies the model definition, and the instance is rebuilt before it is run if the model definition has changed. Otherwise, the model instance is re-run.","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"The model definition is constructed from the following elements.","category":"page"},{"location":"ref/ref_structures_definitions/#Leaf-components-1","page":"Structures: Definitions","title":"Leaf components","text":"","category":"section"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"Leaf components are defined using the @defcomp macro which generates a component definition of the type ComponentDef which has the following fields:","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"# ComponentDef\nparent::Any\nname::Symbol\ncomp_id::Union{Nothing, ComponentId}   \ncomp_path::Union{Nothing, ComponentPath}\ndim_dict::OrderedDict{Symbol, Union{Nothing, Dimension}}\nnamespace::OrderedDict{Symbol, Any}       \nfirst::Union{Nothing, Int}\nlast::Union{Nothing, Int}\nis_uniform::Bool","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"The namespace of a leaf component can hold ParameterDefs and VariableDefs, both which are subclasses of DatumDef (see below for more details on these types).","category":"page"},{"location":"ref/ref_structures_definitions/#Composite-components-1","page":"Structures: Definitions","title":"Composite components","text":"","category":"section"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"Composite components are defined using the @defcomposite macro which generates a composite component definition of the type CompositeComponentDef which has the following fields, in addition to the fields of a ComponentDef:","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"# CompositeComponentDef <: ComponentDef \ninternal_param_conns::Vector{InternalParameterConnection}   \nbackups::Vector{Symbol}\nsorted_comps::Union{Nothing, Vector{Symbol}}","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"The namespace of a composite component can hold CompositeParameterDefs andCompositeVariableDefs, as well as AbstractComponentDefs (which can be other leaf or composite component definitions).","category":"page"},{"location":"ref/ref_structures_definitions/#Datum-definitions-1","page":"Structures: Definitions","title":"Datum definitions","text":"","category":"section"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"Note: we use \"datum\" to refer collectively to parameters and variables. Parameters are values that are fed into a component, and variables are values calculated by a component's run_timestep function.","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"Datum are defined with the @defcomp and @defcomposite macros, and have the following fields:","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"# DatumDef\nname::Symbol\ncomp_path::Union{Nothing, ComponentPath}\ndatatype::DataType\ndim_names::Vector{Symbol}\ndescription::String\nunit::String","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"The only difference between a ParameterDef and a VariableDef is that parameters can have default values.","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"# ParameterDef <: DatumDef\ndefault::Any\n\n# VariableDef <: DatumDef\n# (This class adds no new fields. It exists to differentiate variables from parameters.)","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"CompositeParameterDefs and CompositeVariableDefs are defined in the @defcomposite macro, and point to datum from their subcomponents. (Remember, composite components do not have run_timestep functions, so no values are actually calculated in a composite component.) Thus, CompositeParameterDefs and CompositeVariableDefs inherit all the fields from ParameterDefs and VariableDefs, and have an additional field to record which subcomponent(s)' datum they reference.","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"# CompositeParameterDef <: ParameterDef\nrefs::Vector{UnnamedReference}\n\n# CompositeVariableDef <: VariableDef\nref::UnnamedReference","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"Note: a CompositeParameterDef can reference multiple subcomponents' parameters, but a CompositeVariableDef can only reference a variable from one subcomponent.","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"The reference(s) stored in CompositeParameterDefs and CompositeVariableDefs are of type UnnamedReference, which has the following fields:","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"# UnnamedReference\ncomp_name::Symbol   # name of the referenced subcomponent\ndatum_name::Symbol  # name of the parameter or variable in the subcomponent's namespace","category":"page"},{"location":"ref/ref_structures_definitions/#ModelDef-1","page":"Structures: Definitions","title":"ModelDef","text":"","category":"section"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"A ModelDef is a top-level composite that also stores external parameters and a list of external parameter connections. It contains the following additional fields:","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"# ModelDef <: CompositeComponentDef\nexternal_param_conns::Vector{ExternalParameterConnection}\nexternal_params::Dict{Symbol, ModelParameter}\nnumber_type::DataType\ndirty::Bool","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"Note: a ModelDef's namespace will only hold AbstractComponentDefs. ","category":"page"},{"location":"ref/ref_structures_definitions/#Parameter-Connections-1","page":"Structures: Definitions","title":"Parameter Connections","text":"","category":"section"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"Parameters hold values defined exogneously to the model (\"external\" parameters) or to the component (\"internal\" parameters).","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"InternalParameterConnection Internal parameters are defined by connecting a parameter in one component to a variable in another component. This struct holds the names and ComponentPaths of the parameter and variable, and other information such as the \"backup\" data source. At build time, internal parameter connections result in direct references from the parameter to the storage allocated for the variable.","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"ExternalParameterConnection Values that are exogenous to the model are defined in external parameters whose values are assigned using the public API function set_param!(), or by setting default values in @defcomp or @defcomposite, in which case, the default values are assigned via an internal call to set_param!().","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"External connections are stored in the ModelDef, along with the actual ModelParameters, which may be scalar values or arrays, as described below.","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"# AbstractConnection\n\n# InternalParameterConnection <: AbstractConnection\nsrc_comp_path::ComponentPath      \nsrc_var_name::Symbol\ndst_comp_path::ComponentPath\ndst_par_name::Symbol\nignoreunits::Bool\nbackup::Union{Symbol, Nothing} # a Symbol identifying the external param providing backup data, or nothing\noffset::Int\n\n# ExternalParameterConnection  <: AbstractConnection\ncomp_path::ComponentPath\nparam_name::Symbol      # name of the parameter in the component\nexternal_param::Symbol  # name of the parameter stored in the model's external_params","category":"page"},{"location":"ref/ref_structures_definitions/#Model-parameters-1","page":"Structures: Definitions","title":"Model parameters","text":"","category":"section"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"ModelParameter This is an abstract type that is the supertype of both ScalarModelParameter{T} and ArrayModelParameter{T}. These two parameterized types are used to store values set for external model parameters.","category":"page"},{"location":"tutorials/tutorial_main/#Tutorials-Introduction-1","page":"Tutorials Intro","title":"Tutorials Introduction","text":"","category":"section"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"The following tutorials target Mimi users of different experience levels, starting with first-time users.  Before engaging with these tutorials, we recommend that users read the introductory Welcome to Mimi page. It will also be helpful to be comfortable with the basics of the Julia language, though expertise is not required.","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"If you find a bug in these tutorials, or have a clarifying question or suggestion, please reach out via Github Issues or our Mimi Framework forum.  We welcome your feedback.","category":"page"},{"location":"tutorials/tutorial_main/#Available-Tutorials-1","page":"Tutorials Intro","title":"Available Tutorials","text":"","category":"section"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"Tutorial 1: Install Mimi describes how to set up your system by installing julia, Mimi, and the Mimi registry.","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"Tutorial 2: Run an Existing Model steps through the tasks to download, run, and view the results of a registered model such as FUND.  It should be usable for all users, including first-time users, and is a good place to start when learning to use Mimi.","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"Tutorial 3: Modify an Existing Model builds on Tutorial 2, showing how to modify an existing model such as DICE.","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"Tutorial 4: Create a Model takes a step beyond using registered models, explaining how to create a model from scratch.","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"Tutorial 5: Sensitivity Analysis (SA) Support explores Mimi's Sensitivity Analysis support, using both the simple multi-Region tutorial model and MimiDICE2010 examples.","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"Additional AERE Workshop Tutorials: The Mimi developement team recently participated in the 2019 Association of Environmental and Resource Economists (AERE) summer conference during the pre-conference workshop on Advances in Integrated Assessment Models. This included both a presentation and a hands-on session demonstrating various use cases for Mimi. The Github repository here contains a) all slides from the workshop and b) all the code from the hands on sessions, which may be of interest to Mimi users. Importantly note that the linked code represents as a snapshot of Mimi at the time of the workshop, and will not be updated to reflect new changes.","category":"page"},{"location":"tutorials/tutorial_2/#Tutorial-2:-Run-an-Existing-Model-1","page":"2 Run an Existing Model","title":"Tutorial 2: Run an Existing Model","text":"","category":"section"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"This tutorial walks through the steps to download, run, and view the output of an existing model.  There are several existing models publically available on Github, and for the purposes of this tutorial we will use The Climate Framework for Uncertainty, Negotiation and Distribution (FUND), available on Github here.","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"Working through the following tutorial will require:","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"Julia v1.4.0 or higher\nMimi v0.10.0 or higher\nconnection of your julia installation with the central Mimi registry of Mimi models","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"If you have not yet prepared these, go back to the first tutorial to set up your system.","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"Note that we have recently released Mimi v1.0.0, which is a breaking release and thus we cannot promise backwards compatibility with version lower than v1.0.0 although several of these tutorials may run properly with older versions. For assistance updating your own model to v1.0.0, or if you are curious about the primary changes made, see the How-to Guide on porting to Mimi v1.0.0. Mimi v0.10.0 is functionally dentical to Mimi v1.0.0, but includes deprecation warnings instead of errors to assist users in porting to v1.0.0.","category":"page"},{"location":"tutorials/tutorial_2/#Step-1.-Download-FUND-1","page":"2 Run an Existing Model","title":"Step 1. Download FUND","text":"","category":"section"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"The first step in this process is downloading the FUND model, which is now made easy with the Mimi registry. Assuming you have already done the one-time run of the following command to connect your julia installation with the central Mimi registry of Mimi models, as instructed in the first tutorial,","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"pkg> registry add https://github.com/mimiframework/MimiRegistry.git","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"you simply need to add the FUND model in the Pkg REPL with:","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"pkg> add MimiFUND","category":"page"},{"location":"tutorials/tutorial_2/#Step-2.-Run-FUND-1","page":"2 Run an Existing Model","title":"Step 2. Run FUND","text":"","category":"section"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"The next step is to run FUND. If you wish to first get more acquainted with the model itself, take a look at the provided online documentation.","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"Now open a julia REPL and type the following command to load the MimiFUND package into the current environment:","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"using MimiFUND","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"Now we can access the public API of FUND, including the function MimiFUND.get_model. This function returns a copy of the default FUND model. Here we will first get the model, and then use the run function to run it.","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"m = MimiFUND.get_model()\nrun(m)","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"These steps should be relatively consistent across models, where a repository for ModelX should contain a primary file ModelX.jl which exports, at minimum, a function named something like get_model or construct_model which returns a version of the model, and can allow for model customization within the call.","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"In the MimiFUND package, the function get_model has the signature","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"get_model(; nsteps = default_nsteps, datadir = default_datadir, params = default_params)","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"Thus there are no required arguments, although the user can input nsteps to define the number of timesteps (years in this case) the model runs for, datadir to define the location of the input data, and params, a dictionary definining the parameters of the model.  For example, if you wish to run only the first 200 timesteps, you may use:","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"using MimiFUND\nm = MimiFUND.get_model(nsteps = 200)\nrun(m)","category":"page"},{"location":"tutorials/tutorial_2/#Step-3.-Access-Results:-Values-1","page":"2 Run an Existing Model","title":"Step 3. Access Results: Values","text":"","category":"section"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"After the model has been run, you may access the results (the calculated variable values in each component) in a few different ways.","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"Start off by importing the Mimi package to your space with","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"using Mimi","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"First of all, you may use the getindex syntax as follows:","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"m[:ComponentName, :VariableName] # returns the whole array of values\nm[:ComponentName, :VariableName][100] # returns just the 100th value\n","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"Indexing into a model with the name of the component and variable will return an array with values from each timestep. You may index into this array to get one value (as in the second line, which returns just the 100th value). Note that if the requested variable is two-dimensional, then a 2-D array will be returned. For example, try taking a look at the income variable of the socioeconomic component of FUND using the code below:","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"m[:socioeconomic, :income]\nm[:socioeconomic, :income][100]","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"You may also get data in the form of a dataframe, which will display the corresponding index labels rather than just a raw array. The syntax for this uses getdataframe as follows:","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"getdataframe(m, :ComponentName=>:Variable) # request one variable from one component\ngetdataframe(m, :ComponentName=>(:Variable1, :Variable2)) # request multiple variables from the same component\ngetdataframe(m, :Component1=>:Var1, :Component2=>:Var2) # request variables from different components","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"Try doing this for the income variable of the socioeconomic component using:","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"getdataframe(m, :socioeconomic=>:income) # request one variable from one component\ngetdataframe(m, :socioeconomic=>:income)[1:16,:] # results for all regions in first year (1950)","category":"page"},{"location":"tutorials/tutorial_2/#Step-4.-Access-Results:-Plots-and-Graphs-1","page":"2 Run an Existing Model","title":"Step 4. Access Results: Plots and Graphs","text":"","category":"section"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"After running the FUND model, you may also explore the results using plots and graphs.","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"Mimi provides support for plotting using VegaLite and VegaLite.jl within the Mimi Explorer UI.","category":"page"},{"location":"tutorials/tutorial_2/#Explore-1","page":"2 Run an Existing Model","title":"Explore","text":"","category":"section"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"If you wish to explore the results graphically, use the explorer UI. This functionality is described in more detail in the second how-to guide, How-to Guide 2: View and Explore Model Results. For now, however, you don't need this level of detail and can simply follow the steps below.","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"To explore all variables and parameters of FUND in a dynamic UI app window, use the explore function called with the model as the required first argument, and the optional argument of the title  The menu on the left hand side will list each element in a label formatted as component: variable/parameter.","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"explore(m, title = \"My Window\")","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"Alternatively, in order to view just one parameter or variable, call the function explore as below to return a plot object and automatically display the plot in a viewer, assuming explore is the last command executed.  This call will return the type VegaLite.VLSpec, which you may interact with using the API described in the VegaLite.jl documentation.  For example, VegaLite.jl plots can be saved as PNG, SVG, PDF and EPS files. You may save a plot using the save function. ","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"Note that saving an interactive plot in a non-interactive file format, such as .pdf or .svg will result in a warning WARN Can not resolve event source: window, but the plot will be saved as a static image. If you wish to preserve interactive capabilities, you may save it using the .vegalite file extension. If you then open this file in Jupyter lab, the interactive aspects will be preserved.","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"p = Mimi.plot(m, :mycomponent, :myvariable)\nsave(\"MyFilePath.svg\", p)","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"More specifically for our tutorial use of FUND, try:","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"p = Mimi.plot(m, :socioeconomic, :income)\nsave(\"MyFilePath.svg\", p)","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"You're done!  Now feel free to move on to the next tutorial, which will go into depth on how to modify an existing model such as FUND.","category":"page"},{"location":"howto_advanced/howto_adv_main/#Advanced-How-to-Guides-Introduction-1","page":"Advanced How-to Guides Intro","title":"Advanced How-to Guides Introduction","text":"","category":"section"},{"location":"howto_advanced/howto_adv_main/#","page":"Advanced How-to Guides Intro","title":"Advanced How-to Guides Intro","text":"The following how-to guides provide steps to work through more specified and advanced real-world problems that Mimi can solve. They are less detailed than the tutorials, and are thus targeted at a user with some level of experience with Mimi (likely obtained through moving through some or all of the tutorials). ","category":"page"},{"location":"howto_advanced/howto_adv_main/#","page":"Advanced How-to Guides Intro","title":"Advanced How-to Guides Intro","text":"If you find a bug in these guides, or have a clarifying question or suggestion, please reach out via Github Issues or our Mimi Framework forum.  We welcome your feedback.","category":"page"},{"location":"howto_advanced/howto_adv_main/#Available-Advanced-How-to-Guides-1","page":"Advanced How-to Guides Intro","title":"Available Advanced How-to Guides","text":"","category":"section"},{"location":"howto_advanced/howto_adv_main/#","page":"Advanced How-to Guides Intro","title":"Advanced How-to Guides Intro","text":"Advanced How-to Guide: Build and Init Functions describes the innerworkings of the build and init functions which may be useful in special cases.","category":"page"},{"location":"howto_advanced/howto_adv_main/#","page":"Advanced How-to Guides Intro","title":"Advanced How-to Guides Intro","text":"Advanced How-to Guide: Using Datum References describes how to use references to datum, or more specifically components, for scenarios where such use improves code brevity and understandability.","category":"page"},{"location":"faq/#Frequently-asked-questions-1","page":"FAQ","title":"Frequently asked questions","text":"","category":"section"},{"location":"faq/#What's-up-with-the-name?-1","page":"FAQ","title":"What's up with the name?","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"The name is probably an acronym for \"Modular Integrated Modeling Interface\", but we are not sure. What is certain is that it came up during a dinner that Bob, David and Sol had in 2015. David thinks that Bob invented the name, Bob doesn't remember and Sol thinks the waiter might have come up with it (although we can almost certainly rule that option out). It certainly is better than the previous name \"IAMF\". We now use \"Mimi\" purely as a name of the package, not as an acronym.","category":"page"},{"location":"tutorials/tutorial_4/#Tutorial-4:-Create-a-Model-1","page":"4 Create a Model","title":"Tutorial 4: Create a Model","text":"","category":"section"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"This tutorial walks through the steps to create a new model, first a one-region model and then a more complex multi-region model. ","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"While we will walk through the code step by step below, the full code for implementation is also available in the examples/tutorial folder in the Mimi github repository.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Working through the following tutorial will require:","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Julia v1.4.0 or higher\nMimi v0.10.0 or higher","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"If you have not yet prepared these, go back to the main tutorial page and follow the instructions for their download.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Note that we have recently released Mimi v1.0.0, which is a breaking release and thus we cannot promise backwards compatibility with version lower than v1.0.0 although several of these tutorials may run properly with older versions. For assistance updating your own model to v1.0.0, or if you are curious about the primary changes made, see the How-to Guide on porting to Mimi v1.0.0. Mimi v0.10.0 is functionally dentical to Mimi v1.0.0, but includes deprecation warnings instead of errors to assist users in porting to v1.0.0.","category":"page"},{"location":"tutorials/tutorial_4/#Constructing-A-One-Region-Model-1","page":"4 Create a Model","title":"Constructing A One-Region Model","text":"","category":"section"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"In this example, we construct a stylized model of the global economy and its changing greenhouse gas emission levels through time. The overall strategy involves creating components for the economy and emissions separately, and then defining a model where the two components are coupled together.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"There are two main steps to creating a component, both within the  @defcomp macro which defines a component:","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"List the parameters and variables.\nUse the run_timestep function run_timestep(p, v, d, t) to set the equations of that component.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Starting with the economy component, each variable and parameter is listed. If either variables or parameters have a time-dimension, that must be set with (index=[time]).","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Next, the run_timestep function must be defined along with the various equations of the grosseconomy component. In this step, the variables and parameters are linked to this component and must be identified as either a variable or a parameter in each equation. For this example, v will refer to variables while p refers to parameters.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"It is important to note that t below is an AbstractTimestep, and the specific API for using this argument are described in detail in the how to guide How-to Guide 4: Work with Timesteps, Parameters, and Variables ","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"using Mimi # start by importing the Mimi package to your space\n\n@defcomp grosseconomy begin\n\tYGROSS\t= Variable(index=[time])\t# Gross output\n\tK\t    = Variable(index=[time])\t# Capital\n\tl\t    = Parameter(index=[time])\t# Labor\n\ttfp\t    = Parameter(index=[time])\t# Total factor productivity\n\ts\t    = Parameter(index=[time])\t# Savings rate\n\tdepk\t= Parameter()\t\t\t    # Depreciation rate on capital - Note that it has no time index\n\tk0\t    = Parameter()\t\t\t    # Initial level of capital\n\tshare\t= Parameter()\t\t\t    # Capital share\n\n\tfunction run_timestep(p, v, d, t)\n\t\t# Define an equation for K\n\t\tif is_first(t)\n\t\t\t# Note the use of v. and p. to distinguish between variables and parameters\n\t\t\tv.K[t] \t= p.k0\t\n\t\telse\n\t\t\tv.K[t] \t= (1 - p.depk)^5 * v.K[t-1] + v.YGROSS[t-1] * p.s[t-1] * 5\n\t\tend\n\n\t\t# Define an equation for YGROSS\n\t\tv.YGROSS[t] = p.tfp[t] * v.K[t]^p.share * p.l[t]^(1-p.share)\n\tend\nend","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Next, the component for greenhouse gas emissions must be created.  Although the steps are the same as for the grosseconomy component, there is one minor difference. While YGROSS was a variable in the grosseconomy component, it now enters the emissions component as a parameter. This will be true for any variable that becomes a parameter for another component in the model.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"@defcomp emissions begin\n\tE \t    = Variable(index=[time])\t# Total greenhouse gas emissions\n\tsigma\t= Parameter(index=[time])\t# Emissions output ratio\n\tYGROSS\t= Parameter(index=[time])\t# Gross output - Note that YGROSS is now a parameter\n\n\tfunction run_timestep(p, v, d, t)\n\n\t\t# Define an equation for E\n\t\tv.E[t] = p.YGROSS[t] * p.sigma[t]\t# Note the p. in front of YGROSS\n\tend\nend","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"We can now use Mimi to construct a model that binds the grosseconomy and emissions components together in order to solve for the emissions level of the global economy over time. In this example, we will run the model for twenty periods with a timestep of five years between each period.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Once the model is defined, set_dimension! is used to set the length and interval of the time step.\nWe then use add_comp! to incorporate each component that we previously created into the model.  It is important to note that the order in which the components are listed here matters.  The model will run through each equation of the first component before moving onto the second component.\nNext, set_param! is used to assign values to each parameter in the model, with parameters being uniquely tied to each component. If population was a parameter for two different components, it must be assigned to each one using set_param! two different times. The syntax is set_param!(model_name, :component_name, :parameter_name, value)\nIf any variables of one component are parameters for another, connect_param! is used to couple the two components together. In this example, YGROSS is a variable in the grosseconomy component and a parameter in the emissions component. The syntax is connect_param!(model_name, :component_name_parameter, :parameter_name, :component_name_variable, :variable_name), where :component_name_variable refers to the component where your parameter was initially calculated as a variable.\nFinally, the model can be run using the command run(model_name).\nTo access model results, use model_name[:component, :variable_name].\nTo observe model results in a graphical form , explore as either explore(model_name) to open the UI window, or use Mimi.plot(model_name, :component_name, :variable_name) or Mimi.plot(model_name, :component_name, :parameter_name) to plot a specific parameter or variable.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"\nusing Mimi\n\nfunction construct_model()\n\tm = Model()\n\n\tset_dimension!(m, :time, collect(2015:5:2110))\n\n\t# Order matters here. If the emissions component were defined first, the model would not run.\n\tadd_comp!(m, grosseconomy)  \n\tadd_comp!(m, emissions)\n\n\t# Set parameters for the grosseconomy component\n\tset_param!(m, :grosseconomy, :l, [(1. + 0.015)^t *6404 for t in 1:20])\n\tset_param!(m, :grosseconomy, :tfp, [(1 + 0.065)^t * 3.57 for t in 1:20])\n\tset_param!(m, :grosseconomy, :s, ones(20).* 0.22)\n\tset_param!(m, :grosseconomy, :depk, 0.1)\n\tset_param!(m, :grosseconomy, :k0, 130.)\n\tset_param!(m, :grosseconomy, :share, 0.3)\n\n\t# Set parameters for the emissions component\n\tset_param!(m, :emissions, :sigma, [(1. - 0.05)^t *0.58 for t in 1:20])\n\tconnect_param!(m, :emissions, :YGROSS, :grosseconomy, :YGROSS)  \n\t# Note that connect_param! was used here.\n\n\treturn m\n\nend #end function","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Note that as an alternative to using many of the set_param! calls above, one may use the default keyword argument in @defcomp when first defining a Variable or Parameter, as shown in examples/tutorial/01-one-region-model/one-region-model-defaults.jl.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Now we can run the model and examine the results:","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"# Run model\nm = construct_model()\nrun(m)\n\n# Check model results\ngetdataframe(m, :emissions, :E) # or m[:emissions, :E_Global] to return just the Array","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Finally we can visualize the results via plotting and explorer:","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"# Plot model results\nMimi.plot(m, :emissions, :E);\n\n# Observe all model result graphs in UI\nexplore(m)","category":"page"},{"location":"tutorials/tutorial_4/#Constructing-A-Multi-Region-Model-1","page":"4 Create a Model","title":"Constructing A Multi-Region Model","text":"","category":"section"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"We can now modify our two-component model of the globe to include multiple regional economies.  Global greenhouse gas emissions will now be the sum of regional emissions. The modeling approach is the same, with a few minor adjustments:","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"When using @defcomp, a regions index must be specified. In addition, for variables that have a regional index it is necessary to include (index=[regions]). This can be combined with the time index as well, (index=[time, regions]).\nIn the run_timestep function, unlike the time dimension, regions must be specified and looped through in any equations that contain a regional variable or parameter.\nset_dimension! must be used to specify your regions in the same way that it is used to specify your timestep.\nWhen using set_param! for values with a time and regional dimension, an array is used.  Each row corresponds to a time step, while each column corresponds to a separate region. For regional values with no timestep, a vector can be used. It is often easier to create an array of parameter values before model construction. This way, the parameter name can be entered into set_param! rather than an entire equation.\nWhen constructing regionalized models with multiple components, it is often easier to save each component as a separate file and to then write a function that constructs the model.  When this is done, using Mimi must be speficied for each component. This approach will be used here.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"To create a three-regional model, we will again start by constructing the grosseconomy and emissions components, making adjustments for the regional index as needed.  Each component should be saved as a separate file.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"As this model is also more complex and spread across several files, we will also take this as a chance to introduce the custom of using Modules to package Mimi models, as shown below.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"using Mimi\n\n@defcomp grosseconomy begin\n    regions = Index()                           #Note that a regional index is defined here\n\n    YGROSS  = Variable(index=[time, regions])   #Gross output\n    K       = Variable(index=[time, regions])   #Capital\n    l       = Parameter(index=[time, regions])  #Labor\n    tfp     = Parameter(index=[time, regions])  #Total factor productivity\n    s       = Parameter(index=[time, regions])  #Savings rate\n    depk    = Parameter(index=[regions])        #Depreciation rate on capital - Note that it only has a region index\n    k0      = Parameter(index=[regions])        #Initial level of capital\n    share   = Parameter()                       #Capital share\n\n    function run_timestep(p, v, d, t)\n    # Note that the regional dimension is defined in d and parameters and variables are indexed by 'r'\n\n        # Define an equation for K\n        for r in d.regions\n            if is_first(t)\n                v.K[t,r] = p.k0[r]\n            else\n                v.K[t,r] = (1 - p.depk[r])^5 * v.K[t-1,r] + v.YGROSS[t-1,r] * p.s[t-1,r] * 5\n            end\n        end\n\n        # Define an equation for YGROSS\n        for r in d.regions\n            v.YGROSS[t,r] = p.tfp[t,r] * v.K[t,r]^p.share * p.l[t,r]^(1-p.share)\n        end\n    end\nend","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Save this component as gross_economy.jl","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"using Mimi\t#Make sure to call Mimi again\n\n@defcomp emissions begin\n    regions     = Index()                           # The regions index must be specified for each component\n\n    E           = Variable(index=[time, regions])   # Total greenhouse gas emissions\n    E_Global    = Variable(index=[time])            # Global emissions (sum of regional emissions)\n    sigma       = Parameter(index=[time, regions])  # Emissions output ratio\n    YGROSS      = Parameter(index=[time, regions])  # Gross output - Note that YGROSS is now a parameter\n\n    # function init(p, v, d)\n    # end\n    \n    function run_timestep(p, v, d, t)\n        # Define an equation for E\n        for r in d.regions\n            v.E[t,r] = p.YGROSS[t,r] * p.sigma[t,r]\n        end\n\n        # Define an equation for E_Global\n        for r in d.regions\n            v.E_Global[t] = sum(v.E[t,:])\n        end\n    end\n\nend","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Save this component as emissions.jl","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Let's create a file with all of our parameters that we can call into our model.  This will help keep things organized as the number of components and regions increases. Each column refers to parameter values for a region, reflecting differences in initial parameter values and growth rates between the three regions.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"l = Array{Float64}(undef, 20, 3)\nfor t in 1:20\n    l[t,1] = (1. + 0.015)^t *2000\n    l[t,2] = (1. + 0.02)^t * 1250\n    l[t,3] = (1. + 0.03)^t * 1700\nend\n\ntfp = Array{Float64}(undef, 20, 3)\nfor t in 1:20\n    tfp[t,1] = (1 + 0.06)^t * 3.2\n    tfp[t,2] = (1 + 0.03)^t * 1.8\n    tfp[t,3] = (1 + 0.05)^t * 2.5\nend\n\ns = Array{Float64}(undef, 20, 3)\nfor t in 1:20\n    s[t,1] = 0.21\n    s[t,2] = 0.15\n    s[t,3] = 0.28\nend\n\ndepk = [0.11, 0.135 ,0.15]\nk0   = [50.5, 22., 33.5]\n\nsigma = Array{Float64}(undef, 20, 3)\nfor t in 1:20\n    sigma[t,1] = (1. - 0.05)^t * 0.58\n    sigma[t,2] = (1. - 0.04)^t * 0.5\n    sigma[t,3] = (1. - 0.045)^t * 0.6\nend","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Save this file as region_parameters.jl","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"The final step is to create a module:","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"module MyModel\n\nusing Mimi\n\ninclude(\"region_parameters.jl\")\ninclude(\"gross_economy.jl\")\ninclude(\"emissions.jl\")\n\nexport construct_MyModel","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"function construct_MyModel()\n\n\tm = Model()\n\n\tset_dimension!(m, :time, collect(2015:5:2110))\n\tset_dimension!(m, :regions, [:Region1, :Region2, :Region3])\t # Note that the regions of your model must be specified here\n\n\tadd_comp!(m, grosseconomy)\n\tadd_comp!(m, emissions)\n\n\tset_param!(m, :grosseconomy, :l, l)\n\tset_param!(m, :grosseconomy, :tfp, tfp)\n\tset_param!(m, :grosseconomy, :s, s)\n\tset_param!(m, :grosseconomy, :depk,depk)\n\tset_param!(m, :grosseconomy, :k0, k0)\n\tset_param!(m, :grosseconomy, :share, 0.3)\n\n\t# set parameters for emissions component\n\tset_param!(m, :emissions, :sigma, sigma)\n\tconnect_param!(m, :emissions, :YGROSS, :grosseconomy, :YGROSS)\n\n    return m\nend","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"end #module","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Save this file as MyModel.jl","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"We can now run the model and evaluate the results.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"using Mimi\n\ninclude(\"MyModel.jl\")\nusing .MyModel","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"m = construct_MyModel()\nrun(m)\n\n# Check results\ngetdataframe(m, :emissions, :E_Global) # or m[:emissions, :E_Global] to return just the Array","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"# Observe model result graphs\nexplore(m)","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Next, feel free to move on to the next tutorial, which will go into depth on how to run a sensitvity analysis on a own model.","category":"page"},{"location":"howto_advanced/howto_adv_buildinit/#Advanced-How-to-Guide:-Build-and-Init-Functions-1","page":"Build and Init Functions","title":"Advanced How-to Guide: Build and Init Functions","text":"","category":"section"},{"location":"howto_advanced/howto_adv_buildinit/#","page":"Build and Init Functions","title":"Build and Init Functions","text":"In some cases, it may be useful for a user to better understand the inner-workings of the internal build function, as well as the ModelInstance and ModelDef types. In addition, components with one-time computations irrespective of timesteps may lend themselves to the use of the optional init function, as described below.","category":"page"},{"location":"howto_advanced/howto_adv_buildinit/#The-Internal-'build'-Function-and-Model-Instances-1","page":"Build and Init Functions","title":"The Internal 'build' Function and Model Instances","text":"","category":"section"},{"location":"howto_advanced/howto_adv_buildinit/#","page":"Build and Init Functions","title":"Build and Init Functions","text":"The structural definition of a Model is held in the mutable ModelDef, and then when you call the run function on your model, first the internal build function is called, which produces a ModelInstance, and then the ModelInstance is run. A model instance is an instantiated version of the model you have designed where all of the component constructors have been called and all of the data arrays have been allocated. If you wish to create and run multiple versions of your model, you can use the intermediate build function and store the separate ModelInstances. This may be useful if you want to change some parameter values, while keeping the model's structure mostly the same. For example:","category":"page"},{"location":"howto_advanced/howto_adv_buildinit/#","page":"Build and Init Functions","title":"Build and Init Functions","text":"instance1 = Mimi.build(m)\nrun(instance1)\n\nupdate_param!(m, ParameterName, newvalue)\ninstance2 = Mimi.build(m)\nrun(instance2)\n\nresult1 = instance1[:Comp, :Var]\nresult2 = instance2[:Comp, :Var]","category":"page"},{"location":"howto_advanced/howto_adv_buildinit/#","page":"Build and Init Functions","title":"Build and Init Functions","text":"Note that you can retrieve values from a ModelInstance in the same way you index into a model.","category":"page"},{"location":"howto_advanced/howto_adv_buildinit/#The-init-function-1","page":"Build and Init Functions","title":"The init function","text":"","category":"section"},{"location":"howto_advanced/howto_adv_buildinit/#","page":"Build and Init Functions","title":"Build and Init Functions","text":"The init function can optionally be called within @defcomp and before run_timestep.  Similarly to run_timestep, this function is called with parameters init(p, v, d), where the component state (defined by the first three arguments) has fields for the Parameters, Variables, and Dimensions of the component you defined.   ","category":"page"},{"location":"howto_advanced/howto_adv_buildinit/#","page":"Build and Init Functions","title":"Build and Init Functions","text":"If defined for a specific component, this function will run before the timestep loop, and should only be used for parameters or variables without a time index e.g. to compute the values of scalar variables that only depend on scalar parameters. Note that when using init, it may be necessary to add special handling in the run_timestep function for the first timestep, in particular for difference equations.  A skeleton @defcomp script using both run_timestep and init would appear as follows:","category":"page"},{"location":"howto_advanced/howto_adv_buildinit/#","page":"Build and Init Functions","title":"Build and Init Functions","text":"@defcomp component1 begin\n\n    # First define the state this component will hold\n    savingsrate = Parameter()\n\n    # Second, define the (optional) init function for the component\n    function init(p, v, d)\n    end\n\n    # Third, define the run_timestep function for the component\n    function run_timestep(p, v, d, t)\n    end\n\nend","category":"page"},{"location":"tutorials/tutorial_3/#Tutorial-3:-Modify-an-Existing-Model-1","page":"3 Modify an Existing Model","title":"Tutorial 3: Modify an Existing Model","text":"","category":"section"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"This tutorial walks through the steps to modify an existing model.  There are several existing models publically available on Github, and for the purposes of this tutorial we will use the MimiDICE2010 model.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"Working through the following tutorial will require:","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"Julia v1.4.0 or higher\nMimi v0.10.0 or higher\nconnection of your julia installation with the central Mimi registry of Mimi models","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"If you have not yet prepared these, go back to the first tutorial to set up your system.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"Note that we have recently released Mimi v1.0.0, which is a breaking release and thus we cannot promise backwards compatibility with version lower than v1.0.0 although several of these tutorials may run properly with older versions. For assistance updating your own model to v1.0.0, or if you are curious about the primary changes made, see the How-to Guide on porting to Mimi v1.0.0. Mimi v0.10.0 is functionally dentical to Mimi v1.0.0, but includes deprecation warnings instead of errors to assist users in porting to v1.0.0.","category":"page"},{"location":"tutorials/tutorial_3/#Introduction-1","page":"3 Modify an Existing Model","title":"Introduction","text":"","category":"section"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"There are various ways to modify an existing model, and this tutorial aims to introduce the Mimi API relevant to this broad category of tasks.  It is important to note that regardless of the goals and complexities of your modifications, the API aims to allow for modification without alteration of the original code for the model being modified.  Instead, you will download and run the existing model, and then use API calls to modify it. This means that in practice, you should not need to alter the source code of the model you are modifying. Thus, it is easy to keep up with any external updates or improvements made to that model.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"Possible modifications range in complexity, from simply altering parameter values, to adjusting an existing component, to adding a brand new component.","category":"page"},{"location":"tutorials/tutorial_3/#Parametric-Modifications:-The-API-1","page":"3 Modify an Existing Model","title":"Parametric Modifications: The API","text":"","category":"section"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"Several types of changes to models revolve around the parameters themselves, and may include updating the values of parameters and changing parameter connections without altering the elements of the components themselves or changing the general component structure of the model.  The most useful functions of the common API in these cases are likely update_param!/update_params!, disconnect_param!, and connect_param!.  For detail on these functions see the API reference guide, Reference Guide: The Mimi API.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"When the original model calls set_param!, Mimi creates an external parameter by the name provided, and stores the provided scalar or array value. The functions update_param! and update_params! allow you to change the value associated with this external parameter.  Note that if the external parameter has a :time dimension, use the optional argument update_timesteps=true to indicate that the time keys (i.e., year labels) associated with the parameter should be updated in addition to updating the parameter values.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"update_param!(mymodel, :parametername, newvalues) # update values only \n\nupdate_param!(mymodel, :parametername, newvalues, update_timesteps=true) # also update time keys. Only necessary if the time dimension of the model has been changed.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"In the code above, newvalues must be the same size and type (or be able to convert to the type) of the old values stored in that parameter.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"If you wish to alter connections within an existing model, disconnect_param! and connect_param! can be used in conjunction with each other to update the connections within the model, although this is more likely to be done as part of larger changes involving components themslves, as discussed in the next subsection.","category":"page"},{"location":"tutorials/tutorial_3/#Parametric-Modifications:-DICE-Example-1","page":"3 Modify an Existing Model","title":"Parametric Modifications: DICE Example","text":"","category":"section"},{"location":"tutorials/tutorial_3/#Step-1.-Download-MimiDICE2010-1","page":"3 Modify an Existing Model","title":"Step 1. Download MimiDICE2010","text":"","category":"section"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"The first step in this process is downloading the DICE2010 model, which is now made easy with the Mimi registry. Assuming you have already done the one-time run of the following to connect your julia installation with the central Mimi registry of Mimi models,","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"pkg> registry add https://github.com/mimiframework/MimiRegistry.git","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"you simply need to add the MimiDICE2010 model in the Pkg REPL with:","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"pkg> add MimiDICE2010","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"You have now successfully downloaded MimiDICE2010 to your local machine.","category":"page"},{"location":"tutorials/tutorial_3/#Step-2.-Run-DICE-1","page":"3 Modify an Existing Model","title":"Step 2. Run DICE","text":"","category":"section"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"The next step is to run DICE using the provided API for the package:","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"using MimiDICE2010\nm = MimiDICE2010.get_model()\nrun(m)","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"These steps should be relatively consistent across models, where a repository for ModelX should contain a primary file ModelX.jl which exports, at minimum, a function named something like get_model or construct_model which returns a version of the model, and can allow for model customization within the call.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"In this case, the function MimiDICE2010.get_model() has the signature","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"get_model(params=nothing)","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"Thus there are no required arguments, although the user can input params, a dictionary definining the parameters of the model. If nothing is provided, the model will be built with the default parameters for DICE2010.","category":"page"},{"location":"tutorials/tutorial_3/#Step-3.-Altering-Parameters-1","page":"3 Modify an Existing Model","title":"Step 3. Altering Parameters","text":"","category":"section"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"In the case that you wish to alter an exogenous parameter, you may use the update_param! function.  Per usual, you will start by importing the Mimi package to your space with ","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"using Mimi","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"In DICE the parameter fco22x is the forcings of equilibrium CO2 doubling in watts per square meter, and exists in the components climatedynamics and radiativeforcing.  We can change this value from its default value of 3.200 to 3.000 in both components, using the following code:","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"update_param!(m, :fco22x, 3.000)\nrun(m)","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"A more complex example may be a situation where you want to update several parameters, including some with a :time dimension, in conjunction with altering the time index of the model itself. DICE uses a default time horizon of 2005 to 2595 with 10 year increment timesteps.  If you wish to change this, say, to 2000 to 2500 by 10 year increment timesteps and use parameters that match this time, you could use the following code:","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"First you upate the time dimension of the model as follows:","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"const ts = 10\nconst years = collect(2000:ts:2500)\nnyears = length(years)\nset_dimension!(m, :time, years)","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"Next, create a dictionary params with one entry (k, v) per external parameter by name k to value v. Each key k must be a symbol or convert to a symbol matching the name of an external parameter that already exists in the model definition.  Part of this dictionary may look like:","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"params = Dict{Any, Any}()\nparams[:a1]         = 0.00008162\nparams[:a2]         = 0.00204626\n...\nparams[:S]          = repeat([0.23], nyears)\n...","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"Now you simply update the parameters listen in params and re-run the model with","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"update_params!(m, params, update_timesteps=true)\nrun(m)","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"Note that here we use the update_timesteps flag and set it to true, because since we have changed the time index we want the time labels on the parameters to change, not simply their values.","category":"page"},{"location":"tutorials/tutorial_3/#Component-and-Structural-Modifications:-The-API-1","page":"3 Modify an Existing Model","title":"Component and Structural Modifications: The API","text":"","category":"section"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"Most model modifications will include not only parametric updates, but also structural changes and component modification, addition, replacement, and deletion along with the required re-wiring of parameters etc. The most useful functions of the common API, in these cases are likely replace!, add_comp! along with delete! and the requisite functions for parameter setting and connecting.  For detail on the public API functions look at the API reference. ","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"If you wish to modify the component structure we recommend you also look into the built-in helper components adder, ConnectorCompVector, and ConnectorCompMatrix in the src/components folder, as these can prove quite useful.  ","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"adder.jl  Defines Mimi.adder, which simply adds two parameters, input and add and stores the result in output.\nconnector.jl  Defines a pair of components, Mimi.ConnectorCompVector and Mimi.ConnectorCompMatrix. These copy the value of parameter input1, if available, to the variable output, otherwise the value of parameter input2 is used. It is an error if neither has a value.","category":"page"},{"location":"tutorials/tutorial_3/#Component-and-Structural-Modifications:-DICE-Example-1","page":"3 Modify an Existing Model","title":"Component and Structural Modifications: DICE Example","text":"","category":"section"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"This example is in progress and will be built out soon.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"Next, feel free to move on to the next tutorial, which will go into depth on how to create your own model.","category":"page"},{"location":"internals/structure/#Mimi-Internal-Structure-1","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"","category":"section"},{"location":"internals/structure/#.-Code-organization-1","page":"Mimi Internal Structure","title":"1. Code organization","text":"","category":"section"},{"location":"internals/structure/#Types-1","page":"Mimi Internal Structure","title":"Types","text":"","category":"section"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"All Mimi types are defined in Mimi/src/core/types.jl.","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"The types are broadly divided into two categories reflecting \"structural definitions\" versus \"instantiated model info\". Structural definition types include:","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"ModelDef\nComponentDef\nDatumDef (used for both variable and parameter definitions)","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"Instantiated model info types include:","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"ModelInstance\nComponentInstance\nComponentInstanceVariables\nComponentInstanceParameters","category":"page"},{"location":"internals/structure/#Model-object-1","page":"Mimi Internal Structure","title":"Model object","text":"","category":"section"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"The \"user-facing\" Model no longer directly holds other model information: it now holds a ModelDef and, once the model is built, a ModelInstance, and delegates all function calls to one or the other of these, as appropriate. The \"public\" API to models is provided by functions taking a Model instance, which are defined in the file model.jl.","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"With this change, all previous \"direct\" access of data in the Model instance are replaced by a functional API. That is, all occurrences of m.xxx (where m::Model) have been replaced with function calls on m, which are then delegated to the ModelDef or ModelInstance, as appropriate.","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"To simplify coding the delegated calls, a new macro, @modelegate allows you to write, e.g., ","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"@modelegate external_param_conns(m::Model) => mi","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"which translates to:","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"external_param_conns(m::Model) = external_param_conns.mi)","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"The right-hand side can also be => md to indicate delegation to the ModelDef rather than to the ModelInstance. See model.jl for numerous examples.","category":"page"},{"location":"internals/structure/#Connections-1","page":"Mimi Internal Structure","title":"Connections","text":"","category":"section"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"The types InternalParameterConnection and ExternalParameterConnection are now both subtypes of the abstract type Connection.","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"[We may merge these two connection types since the only functional differences are that the ExternalParameterConnections type has fewer fields and its instances are stored in a separate list in the model.]","category":"page"},{"location":"internals/structure/#ComponentInstanceData-1","page":"Mimi Internal Structure","title":"ComponentInstanceData","text":"","category":"section"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"ComponentInstanceVariables and ComponentInstanceParameters are parametric types that are subtypes of ComponentInstanceData. The names and types of the variables or parameters are encoded into the type information; the struct proper contains only the parameter or variable values. Use of this parametric type allows us to use @generated to produce type-specific getproperty and setproperty! functions that efficiently access model parameters. [See Dot-overloading, below.]","category":"page"},{"location":"internals/structure/#.-Changes-to-@defcomp-1","page":"Mimi Internal Structure","title":"2. Changes to @defcomp","text":"","category":"section"},{"location":"internals/structure/#Macro-simplification-1","page":"Mimi Internal Structure","title":"Macro simplification","text":"","category":"section"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"The @defcomp macro has been substantially simplified by relying on MacroTools.jl package and by avoiding the construction of expressions using Abstract Syntax Tree form. The macro now operates by producing a fairly simple sequence of function calls.","category":"page"},{"location":"internals/structure/#Dot-overloading-1","page":"Mimi Internal Structure","title":"Dot-overloading","text":"","category":"section"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"In a change from the prior iteration of Mimi, the run_timestep function must now be defined within the @defcomp macro. It takes four arguments: parameters, variables, dimensions, and time.","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"    function run_timestep(p, v, d, t)\n       ...\n    end","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"With the run_timestep function inside the @defcomp macro, we are able to modify the code to translate references like p.gdp and assignments like v.foo = 3 to use new @generated functions getproperty and setproperty!, which compile down to direct array access operations on the values field of parameter and variable instances.","category":"page"},{"location":"internals/structure/#Component-naming-1","page":"Mimi Internal Structure","title":"Component naming","text":"","category":"section"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"In the previous version of Mimi, components were named by a pair of symbols indicating the module the component was defined in, and the name of the component. Each component was also reified in a newly generated custom type.","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"In the new version, all component definitions are represented by one type, ComponentDef. The @defcomp macro creates a global variable with the name provided to @defcomp which holds a new type of object, ComponentId, which holds the symbol names of the module and component. The name of the model given in the @defcomp macro invocation becomes a variable holding the ComponentId. Thus, instead of referring to a component as, say, (:Mimi, :grosseconomy), you refer to it by its associated global constant, e.g., Mimi.grosseconomy. Note that models can be defined in their own module to avoid namespace collisions.","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"(Image: Object structure)","category":"page"},{"location":"internals/structure/#.-Pre-compilation-and-built-in-components-1","page":"Mimi Internal Structure","title":"3. Pre-compilation and built-in components","text":"","category":"section"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"To get __precompile__() to work required moving the creation of \"helper\" components to an __init__() method in Mimi.jl, which is run automatically after Mimi loads. It defines the two \"built-in\" components, from adder.jl and connector.jl in the components subdirectory.","category":"page"},{"location":"ref/ref_main/#Reference-Guides-Introduction-1","page":"Reference Guides Intro","title":"Reference Guides Introduction","text":"","category":"section"},{"location":"ref/ref_main/#","page":"Reference Guides Intro","title":"Reference Guides Intro","text":"The following reference guides are technical descriptions of the Mimi machinery, organized around the actual code behind Mimi and intended to be information-oriented for those interested in the internals or needing to more deeply understand those aspects in order to carry out their projects. Given the complexity of this code base, these references are not comprehensive, but intended to target some important and relevant aspects of Mimi.","category":"page"},{"location":"ref/ref_main/#","page":"Reference Guides Intro","title":"Reference Guides Intro","text":"If you find a bug in these reference guides, or have a clarifying question or suggestion, please reach out via Github Issues or our Mimi Framework forum.  We welcome your feedback.","category":"page"},{"location":"ref/ref_main/#Available-Reference-Guides-1","page":"Reference Guides Intro","title":"Available Reference Guides","text":"","category":"section"},{"location":"ref/ref_main/#","page":"Reference Guides Intro","title":"Reference Guides Intro","text":"Reference Guide: The Mimi API provides a guide to the public API for Mimi, including macros, types, and functions along with their signatures and descriptions.","category":"page"},{"location":"ref/ref_main/#","page":"Reference Guides Intro","title":"Reference Guides Intro","text":"Reference Guide: Structures describes the core data structures used to implement in Mimi 1.0.","category":"page"},{"location":"ref/ref_main/#","page":"Reference Guides Intro","title":"Reference Guides Intro","text":"Reference Guide: Structures - Definitions describes the core definition data structures used to implement in Mimi 1.0.","category":"page"},{"location":"ref/ref_main/#","page":"Reference Guides Intro","title":"Reference Guides Intro","text":"Reference Guide: Structures - Instances describes the core instance data structures used to implement in Mimi 1.0.","category":"page"},{"location":"tutorials/tutorial_5/#Tutorial-5:-Sensitivity-Analysis-(SA)-Support-1","page":"5 Sensitivity Analysis","title":"Tutorial 5: Sensitivity Analysis (SA) Support","text":"","category":"section"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"This tutorial walks through the sensitivity analysis (SA) functionality of Mimi, including core routines and examples.  We will start with looking at using the SA routines with the multi-region Mimi model built in the second half of Tutorial 3, which is also available in the Mimi repository at examples/tutorial/02-multi-region-model. Then we will show some more advanced features using a real Integrated Assessment model, MimiDICE2010.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"Working through the following tutorial will require:","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"Julia v1.4.0 or higher\nMimi v0.10.0 or higher","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"If you have not yet prepared these, go back to the main tutorial page and follow the instructions for their download.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"Note that we have recently released Mimi v1.0.0, which is a breaking release and thus we cannot promise backwards compatibility with version lower than v1.0.0 although several of these tutorials may run properly with older versions. For assistance updating your own model to v1.0.0, or if you are curious about the primary changes made, see the How-to Guide on porting to Mimi v1.0.0. Mimi v0.10.0 is functionally dentical to Mimi v1.0.0, but includes deprecation warnings instead of errors to assist users in porting to v1.0.0.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"MimiDICE2010 is required for the second example in this tutorial. If you are not yet comfortable with downloading and running a registered Mimi model, refer to Tutorial 2 for instructions.","category":"page"},{"location":"tutorials/tutorial_5/#The-API-1","page":"5 Sensitivity Analysis","title":"The API","text":"","category":"section"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"The best current documentation on the SA API is the how to guide How-to Guide 3: Conduct Sensitivity Analysis. This file can be used in conjunction with the examples below for details since the documentation covers more advanced options such as non-stochastic scenarios and running multiple models, which are not yet included in this tutorial.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"Below we will refer separately to two types, SimulationDef and SimulationInstance.  They are referred to as sim_def and sim_inst respectively as function arguments, and sd and si respectively as local variables.","category":"page"},{"location":"tutorials/tutorial_5/#Multi-Region-Model-Example-1","page":"5 Sensitivity Analysis","title":"Multi-Region Model Example","text":"","category":"section"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"This section will walk through a simple example of how to define a simulation, run the simulation for a given model, and access the outputs.","category":"page"},{"location":"tutorials/tutorial_5/#Step-1.-Setup-1","page":"5 Sensitivity Analysis","title":"Step 1. Setup","text":"","category":"section"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"You should have Mimi installed by now, and if you do not have the Distributions package, take a moment to add that package by entering ] to enter the Pkg REPL mode and then typing add Distributions.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"As a reminder, the following code is the multi-region model that was constructed in the second half of tutorial 3. You can either load the MyModel module from tutorial 3, or run the following code which defines the same construct_Mymodel function that we will use.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"using Mimi \n\n# Define the grosseconomy component\n@defcomp grosseconomy begin\n    regions = Index()                           #Note that a regional index is defined here\n\n    YGROSS  = Variable(index=[time, regions])   #Gross output\n    K       = Variable(index=[time, regions])   #Capital\n    l       = Parameter(index=[time, regions])  #Labor\n    tfp     = Parameter(index=[time, regions])  #Total factor productivity\n    s       = Parameter(index=[time, regions])  #Savings rate\n    depk    = Parameter(index=[regions])        #Depreciation rate on capital - Note that it only has a region index\n    k0      = Parameter(index=[regions])        #Initial level of capital\n    share   = Parameter()                       #Capital share\n\n    function run_timestep(p, v, d, t)\n    # Note that the regional dimension is defined in d and parameters and variables are indexed by 'r'\n\n        # Define an equation for K\n        for r in d.regions\n            if is_first(t)\n                v.K[t,r] = p.k0[r]\n            else\n                v.K[t,r] = (1 - p.depk[r])^5 * v.K[t-1,r] + v.YGROSS[t-1,r] * p.s[t-1,r] * 5\n            end\n        end\n\n        # Define an equation for YGROSS\n        for r in d.regions\n            v.YGROSS[t,r] = p.tfp[t,r] * v.K[t,r]^p.share * p.l[t,r]^(1-p.share)\n        end\n    end\nend\n\n# define the emissions component\n@defcomp emissions begin\n    regions     = Index()                           # The regions index must be specified for each component\n\n    E           = Variable(index=[time, regions])   # Total greenhouse gas emissions\n    E_Global    = Variable(index=[time])            # Global emissions (sum of regional emissions)\n    sigma       = Parameter(index=[time, regions])  # Emissions output ratio\n    YGROSS      = Parameter(index=[time, regions])  # Gross output - Note that YGROSS is now a parameter\n\n    # function init(p, v, d)\n    # end\n    \n    function run_timestep(p, v, d, t)\n        # Define an equation for E\n        for r in d.regions\n            v.E[t,r] = p.YGROSS[t,r] * p.sigma[t,r]\n        end\n\n        # Define an equation for E_Global\n        for r in d.regions\n            v.E_Global[t] = sum(v.E[t,:])\n        end\n    end\n\nend\n\n# Define values for input parameters to be used when constructing the model\n\nl = Array{Float64}(undef, 20, 3)\nfor t in 1:20\n    l[t,1] = (1. + 0.015)^t *2000\n    l[t,2] = (1. + 0.02)^t * 1250\n    l[t,3] = (1. + 0.03)^t * 1700\nend\n\ntfp = Array{Float64}(undef, 20, 3)\nfor t in 1:20\n    tfp[t,1] = (1 + 0.06)^t * 3.2\n    tfp[t,2] = (1 + 0.03)^t * 1.8\n    tfp[t,3] = (1 + 0.05)^t * 2.5\nend\n\ns = Array{Float64}(undef, 20, 3)\nfor t in 1:20\n    s[t,1] = 0.21\n    s[t,2] = 0.15\n    s[t,3] = 0.28\nend\n\ndepk = [0.11, 0.135 ,0.15]\nk0   = [50.5, 22., 33.5]\n\nsigma = Array{Float64}(undef, 20, 3)\nfor t in 1:20\n    sigma[t,1] = (1. - 0.05)^t * 0.58\n    sigma[t,2] = (1. - 0.04)^t * 0.5\n    sigma[t,3] = (1. - 0.045)^t * 0.6\nend\n\n# Define a function for building the model\n\nfunction construct_MyModel()\n\n\tm = Model()\n\n\tset_dimension!(m, :time, collect(2015:5:2110))\n\tset_dimension!(m, :regions, [:Region1, :Region2, :Region3])\t # Note that the regions of your model must be specified here\n\n\tadd_comp!(m, grosseconomy)\n\tadd_comp!(m, emissions)\n\n\tset_param!(m, :grosseconomy, :l, l)\n\tset_param!(m, :grosseconomy, :tfp, tfp)\n\tset_param!(m, :grosseconomy, :s, s)\n\tset_param!(m, :grosseconomy, :depk,depk)\n\tset_param!(m, :grosseconomy, :k0, k0)\n\tset_param!(m, :grosseconomy, :share, 0.3)\n\n\t# set parameters for emissions component\n\tset_param!(m, :emissions, :sigma, sigma)\n\tconnect_param!(m, :emissions, :YGROSS, :grosseconomy, :YGROSS)\n\n    return m\nend","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"Then, we obtain a copy of the model:","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"m = construct_MyModel()","category":"page"},{"location":"tutorials/tutorial_5/#Step-2.-Define-Random-Variables-1","page":"5 Sensitivity Analysis","title":"Step 2. Define Random Variables","text":"","category":"section"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"The @defsim macro is the first step in the process, and returns a SimulationDef. The following syntax allows users to define random variables (RVs) as distributions,  and associate model parameters with the defined random variables.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"There are two ways of assigning random variables to model parameters in the @defsim macro. Notice that both of the following syntaxes are used in the following example. ","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"The first is the following:","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"rv(rv1) = Normal(0, 0.8)    # create a random variable called \"rv1\" with the specified distribution\nparam1 = rv1                # then assign this random variable \"rv1\" to the parameter \"param1\" in the model","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"The second is a shortcut, in which you can directly assign the distribution on the right-hand side to the name of the model parameter on the left hand side. With this syntax, a random variable is created under the hood and then assigned to param1.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"param1 = Normal(0, 0.8)","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"The @defsim macro also selects the sampling method. Simple random sampling (also called Monte Carlo sampling) is the default.  Other options include Latin Hypercube sampling and Sobol sampling.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"using Mimi\nusing Distributions \n\nsd = @defsim begin\n    # Define random variables. The rv() is only required when defining correlations \n    # or sharing an RV across parameters. Otherwise, you can use the shortcut syntax\n    # to assign a distribution to a parameter name.\n    rv(name1) = Normal(1, 0.2)\n    rv(name2) = Uniform(0.75, 1.25)\n    rv(name3) = LogNormal(20, 4)\n\n    # If using LHS, you can define correlations like this:\n    sampling(LHSData, corrlist=[(:name1, :name2, 0.7), (:name1, :name3, 0.5)])\n\n    # Exclude the sampling() call, or use the following for simple random sampling:\n    # sampling(MCSData)\n\n    # For Sobol sampling, specify N, and calc_second_order, which defaults to false.\n    # sampling(SobolData, N=10000, calc_second_order=true)\n\n    # assign RVs to model Parameters\n    share = Uniform(0.2, 0.8)\n    sigma[:, Region1] *= name2\n    sigma[2020:5:2050, (Region2, Region3)] *= Uniform(0.8, 1.2)\n\n    # For parameters that have a region dimension, you can assign an array of distributions, \n    # keyed by region label, which must match the region labels in the model\n    depk = [Region1 => Uniform(0.7, .9),\n            Region2 => Uniform(0.8, 1.),\n            Region3 => Truncated(Normal(), 0, 1)]\n\n    # Indicate which variables to save for each model run.\n    # The syntax is: component_name.variable_name\n    save(grosseconomy.K, grosseconomy.YGROSS, \n         emissions.E, emissions.E_Global)\nend","category":"page"},{"location":"tutorials/tutorial_5/#Step-3.-Run-Simulation-1","page":"5 Sensitivity Analysis","title":"Step 3. Run Simulation","text":"","category":"section"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"Next, use the run function to run the simulation for the specified simulation definition, model (or list of models), and number of trials. View the internals documentation here for critical and useful details on the full signature of the run function.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"In its simplest use, the run function generates and iterates over a sample of trial data from the distributions of the random variables defined in the SimulationDef, perturbing the subset of Mimi's \"external parameters\" that have been assigned random variables, and then runs the given Mimi model(s) for each set of trial data. The function returns a SimulationInstance, which holds a copy of the original SimulationDef in addition to trials information (trials, current_trial, and current_data), the model list models, and results information in results. Optionally, trial values and/or model results are saved to CSV files. Note that if there is concern about in-memory storage space for the results, use the results_in_memory flag set to false to incrementally clear the results from memory. ","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"# Run 100 trials, and optionally save results to the indicated directories\nsi = run(sd, m, 100; trials_output_filename = \"/tmp/trialdata.csv\", results_output_dir=\"/tmp/tutorial4\")\n\n# Explore the results saved in-memory by using getdataframe with the returned SimulationInstance.\n# Values are saved from each trial for each variable or parameter specified by the call to \"save()\" at the end of the @defsim block.\nK_results = getdataframe(si, :grosseconomy, :K)\nE_results = getdataframe(si, :emissions, :E)","category":"page"},{"location":"tutorials/tutorial_5/#Step-4.-Explore-and-Plot-Results-1","page":"5 Sensitivity Analysis","title":"Step 4. Explore and Plot Results","text":"","category":"section"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"As described in the internals documentation here, Mimi provides both explore and Mimi.plot to explore the results of both a run Model and a run SimulationInstance. ","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"To view your results in an interactive application viewer, simply call:","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"explore(si)","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"If desired, you may also include a title for your application window. If more than one model was run in your Simulation, indicate which model you would like to explore with the model keyword argument, which defaults to 1. Finally, if your model leverages different scenarios, you must indicate the scenario_name.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"explore(si; title = \"MyWindow\", model_index = 1) # we do not indicate scen_name here since we have no scenarios","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"To view the results for one of the saved variables from the save command in @defsim, use the (unexported to avoid namespace collisions) Mimi.plot function.  This function has the same keyword arguments and requirements as explore (except for title), and three required arguments: the SimulationInstance, the component name (as a Symbol), and the variable name (as a Symbol).","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"Mimi.plot(si, :grosseconomy, :K)","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"To save your figure, use the save function to save typical file formats such as PNG, SVG, PDF and EPS files. Note that while explore(sim_inst) returns interactive plots for several graphs, Mimi.plot(si, :foo, :bar) will return only static plots. ","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"p = Mimi.plot(si, :grosseconomy, :K)\nsave(\"MyFigure.png\", p)","category":"page"},{"location":"tutorials/tutorial_5/#Advanced-Features-Social-Cost-of-Carbon-(SCC)-Example-1","page":"5 Sensitivity Analysis","title":"Advanced Features - Social Cost of Carbon (SCC) Example","text":"","category":"section"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"This example will discuss the more advanced SA capabilities of post-trial functions and payload objects.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"Case: We want to do an SCC calculation with MimiDICE2010, which consists of running both a base and modified model (the latter being a model including an additional emissions pulse, see the create_marginal_model function or create your own two models). We then take the difference between the consumption level in these two models and obtain the discounted net present value to get the SCC.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"The beginning steps for this case are identical to those above. We first define the typical variables for a simulation, including the number of trials N and the simulation definition sd.  In this case we only define one random variable, t2xco2, but note there could be any number of random variables defined here.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"using Mimi\nusing MimiDICE2010\nusing Distributions\n\n# define the number of trials\nN = 100\n\n# define your simulation (defaults to Monte Carlo sampling)\nsd = @defsim begin\n    t2xco2 = Truncated(Gamma(6.47815626,0.547629469), 1.0, Inf) # a dummy distribution\nend","category":"page"},{"location":"tutorials/tutorial_5/#Payload-object-1","page":"5 Sensitivity Analysis","title":"Payload object","text":"","category":"section"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"Simulation definitions can hold a user-defined payload object which is not used or modified by Mimi. In this example, we will use the payload to hold an array of pre-computed discount factors that we will use in the SCC calculation, as well as a storage array for saving the SCC values.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"# Choose what year to calculate the SCC for\nscc_year = 2015\nyear_idx = findfirst(isequal(scc_year), MimiDICE2010.model_years)\n\n# Pre-compute the discount factors for each discount rate\ndiscount_rates = [0.03, 0.05, 0.07]\nnyears = length(MimiDICE2010.model_years)\ndiscount_factors = [[zeros(year_idx - 1)... [(1/(1 + r))^((t-year_idx)*10) for t in year_idx:nyears]...] for r in discount_rates] \n\n# Create an array to store the computed SCC in each trial for each discount rate\nscc_results = zeros(N, length(discount_rates))  \n\n# Set the payload object in the simulation definition\nmy_payload_object = (discount_factors, scc_results) # In this case, the payload object is a tuple which holds both both arrays\nMimi.set_payload!(sd, my_payload_object)","category":"page"},{"location":"tutorials/tutorial_5/#Post-trial-function-1","page":"5 Sensitivity Analysis","title":"Post-trial function","text":"","category":"section"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"In the simple multi-region simulation example, the only values that were saved during each trial of the simulation were values of variables calculated internally by the model. Sometimes, a user may need to perform other calculations before or after each trial is run. For example, the SCC is calculated using two models, so this calculation needs to happen in a post-trial function, as shown below.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"Here we define a post_trial_function called my_scc_calculation which will calculate the SCC for each trial of the simulation. Notice that this function retrieves and uses the payload object that was previously stored in the SimulationDef.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"function my_scc_calculation(sim_inst::SimulationInstance, trialnum::Int, ntimesteps::Int, tup::Nothing)\n    mm = sim_inst.models[1] \n    discount_factors, scc_results = Mimi.payload(sim_inst)  # Unpack the payload object\n\n    marginal_damages = mm[:neteconomy, :C] * -1 * 10^12 * 12/44 # convert from trillion $/ton C to $/ton CO2; multiply by -1 to get positive value for damages\n    for (i, df) in enumerate(discount_factors)\n        scc_results[trialnum, i] = sum(df .* marginal_damages .* 10)\n    end\nend","category":"page"},{"location":"tutorials/tutorial_5/#Run-the-simulation-1","page":"5 Sensitivity Analysis","title":"Run the simulation","text":"","category":"section"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"Now that we have our post-trial function, we can proceed to obtain our two models and run the simulation. Note that we are using a Mimi MarginalModel mm from MimiDICE2010, which is a Mimi object that holds both the base model and the model with the additional pulse of emissions.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"# Build the marginal model\nmm = MimiDICE2010.get_marginal_model(year = scc_year)   # The additional emissions pulse will be added in the specified year\n\n# Run\nsi = run(sd, mm, N; trials_output_filename = \"ecs_sample.csv\", post_trial_func = my_scc_calculation)\n\n# View the scc_results by retrieving them from the payload object\nscc_results = Mimi.payload(si)[2]   # Recall that the SCC array was the second of two arrays we stored in the payload tuple\n","category":"page"},{"location":"tutorials/tutorial_5/#Simulation-Modification-Functions-1","page":"5 Sensitivity Analysis","title":"Simulation Modification Functions","text":"","category":"section"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"A small set of unexported functions are available to modify an existing SimulationDef.  The functions include:","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"delete_RV!\nadd_RV!\nreplace_RV!\ndelete_transform!\nadd_transform!\ndelete_save!\nadd_save!\nset_payload!\npayload","category":"page"},{"location":"tutorials/tutorial_5/#Full-list-of-keyword-options-for-running-a-simulation-1","page":"5 Sensitivity Analysis","title":"Full list of keyword options for running a simulation","text":"","category":"section"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"View How-to Guide 3: Conduct Sensitivity Analysis for critical and useful details on the full signature of this function, as well as more details and optionality for more advanced use cases.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Sensitivity Analysis","title":"5 Sensitivity Analysis","text":"function Base.run(sim_def::SimulationDef{T}, models::Union{Vector{Model}, Model}, samplesize::Int;\n                 ntimesteps::Int=typemax(Int), \n                 trials_output_filename::Union{Nothing, AbstractString}=nothing, \n                 results_output_dir::Union{Nothing, AbstractString}=nothing, \n                 pre_trial_func::Union{Nothing, Function}=nothing, \n                 post_trial_func::Union{Nothing, Function}=nothing,\n                 scenario_func::Union{Nothing, Function}=nothing,\n                 scenario_placement::ScenarioLoopPlacement=OUTER,\n                 scenario_args=nothing,\n                 results_in_memory::Bool=true) where T <: AbstractSimulationData","category":"page"},{"location":"howto/howto_6/#How-to-Guide-6:-Port-from-()-Mimi-v0.5.0-to-Mimi-v1.0.0-1","page":"6 Port to v1.0.0","title":"How-to Guide 6: Port from (>=) Mimi v0.5.0 to Mimi v1.0.0","text":"","category":"section"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"The release of Mimi v1.0.0 is a breaking release, necessitating the adaptation of existing models' syntax and structure in order for those models to run on this new version.  We have worked hard to keep these changes clear and as minimal as possible. ","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"This guide provides an overview of the steps required to get most models using the v0.9.5 API working with v1.0.0.  It is not a comprehensive review of all changes and new functionalities, but a guide to the minimum steps required to port old models between versions.  For complete information on the new version and its additional functionalities, see the full documentation.","category":"page"},{"location":"howto/howto_6/#Workflow-Advice-1","page":"6 Port to v1.0.0","title":"Workflow Advice","text":"","category":"section"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"To port your model, we recommend you update to Mimi v0.10.0, which is identical to Mimi v1.0.0 except that it includes deprecation warnings for most breaking changes, instead of errors. This means that models written using Mimi v0.9.5 will, in most cases, run successfully under Mimi v0.10.0 and things that will cause errors in v1.0.0 will throw deprecation warnings. These can guide your changes, and thus a good workflow would be:","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"Update your environment to use Mimi v0.10.0 with   julia  pkg> add Mimi#v0.10.0\nRead through this guide to get a sense for what has changed\nRun your code and incrementally update it, using the deprecation warnings as guides for what to change and the instructions in this guide as explanations, until no warnings are thrown and you have changed anything relevant to your code that is explained in this gude.\nUpdate to Mimi v1.0.0 with the following code, which will update Mimi to it's latest version, v1.0.0  julia  pkg> free Mimi\nRun your model! Things should run smoothly now. If not double check the guide, and feel free to reach out on the forum with any questions. Also, if you are curious about the reasons behind a change, just ask!","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"This guide is organized into a few main sections, each descripting an independent set of changes that can be undertaken in any order desired. ","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"Syntax Within the @defcomp Macro\nThe set_param! Function\nThe replace_comp! Function\nDifferent-length Components\nMarginal Models\nSimulation Syntax\nComposite Components (optional)","category":"page"},{"location":"howto/howto_6/#Syntax-Within-the-@defcomp-Macro-1","page":"6 Port to v1.0.0","title":"Syntax Within the @defcomp Macro","text":"","category":"section"},{"location":"howto/howto_6/#Type-parameterization-for-Parameters-1","page":"6 Port to v1.0.0","title":"Type-parameterization for Parameters","text":"","category":"section"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"The Mimi Change: ","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"To be consistent with julia syntax, Mimi now uses bracketing syntax to type-parameterize Parameters inside the @defcomp macro instead of double-colon syntax. h","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"The User Change: ","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"Where you previously indicated that the parameter a should be an Int with ","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"@defcomp my_comp begin\n    a::Int = Parameter()\n    function run_timestep(p, v, d, t)\n    end\nend","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"you should now use","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"@defcomp my_comp begin\n    a = Parameter{Int}()\n    function run_timestep(p, v, d, t)\n    end\nend","category":"page"},{"location":"howto/howto_6/#Integer-Indexing-1","page":"6 Port to v1.0.0","title":"Integer Indexing","text":"","category":"section"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"The Mimi Change: ","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"For safety, Mimi no longer allows indexing into Parameters or Varaibles with the run_timestep function of the @defcomp macro with integers. Instead, this functionality is supported with two new types: TimestepIndex and TimestepValue. Complete details on indexing options can be found in How-to Guide 4: Work with Timesteps, Parameters, and Variables, but below we will describe the minimum steps to get your models working.","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"The User Change: ","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"Where you previously used integers to index into a Parameter or Variable, you should now use the TimestepIndex type.  For example, the code","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"function run_timestep(p, v, d, t)\n    v.my_var[t] = p.my_param[10]\nend","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"should now read","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"function run_timestep(p, v, d, t)\n    v.my_var[t] = p.my_param[TimestepIndex(10)]\nend","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"Also, if you previously used logic to determine which integer index pertained to a specific year, and then used that integer for indexing, you should now use the TimestepValue type. For example, if you previously knew that the index 2 referred to the year 2012, and added that value to a parameter with","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"function run_timestep(p, v, d, t)\n    v.my_var[t] = p.my_param[t] + p.my_other_param[2]\nend","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"you should now use","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"function run_timestep(p, v, d, t)\n    v.my_var[t] = p.my_param[t] + p.my_other_param[TimestepValue(2012)]\nend","category":"page"},{"location":"howto/howto_6/#is_timestep-and-is_time-1","page":"6 Port to v1.0.0","title":"is_timestep and is_time","text":"","category":"section"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"The Mimi Change: ","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"For simplicity and consistency with the change above, Mimi no longer supports the is_timestep or is_time functions and has replaced this functionality with comparison operators combined with the afformentioned TimestepValue and TimestepIndex types.","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"The User Change: ","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"Any instance of the is_timestep function should be replaced with simple comparison with a TimestepIndex object ie. replace the logic if is_timestep(t, 10) ... with if t == TimestepIndex(10) ....","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"Any instance of the is_time function should be repalced with simple comparison with a TimestepValue object ie. replace the logic if is_time(t, 2010) ... with if t == TimestepValue(2010) ....","category":"page"},{"location":"howto/howto_6/#The-set_param!-Function-1","page":"6 Port to v1.0.0","title":"The set_param! Function","text":"","category":"section"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"The Mimi Change: ","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"The set_param! method for setting a parameter value in a component now has the following signature:","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"set_param!(m::Model, comp_name::Symbol, param_name::Symbol, ext_param_name::Symbol, val::Any)","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"This function creates an external parameter called ext_param_name with value val in the model m's list of external parameters, and connects the parameter param_name in component comp_name to this newly created external parameter. If there is already a parameter called ext_param_name in the model's list of external parameters, it errors.","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"There are two available shortcuts:","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"# Shortcut 1\nset_param!(m::Model, param_name::Symbol, val::Any)","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"This method creates an external parameter in the model called param_name, sets its value to val, looks at all the components in the model m, finds all the unbound parameters named param_name, and creates connections from all the unbound parameters that are named param_name to the newly created external parameter. If there is already a parameter called param_name in the external parameter list, it errors.","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"# Shortcut 2\nset_param!(m::Model, comp_name::Symbol, param_name::Symbol, val::Any)","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"This method creates a new external parameter called param_name in the model m (if that already exists, it errors), sets its value to val, and then connects the parameter param_name in component comp_name to this newly created external parameter.","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"The User Change: ","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"Any old code that uses the set_param! method with only 4 arguments (shortcut #2 shown above) will still work for setting parameters if they are found in only one component ... but if you have multiple components that have parameters with the same name, using the old 4-argument version of set_param! multiple times will cause an error. Instead, you need to determine what behavior you want across multiple components with parameters of the same name:","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"If you want parameters with the same name that are found in multiple components to have the same value, use the 3-argument method:  set_param!(m, :param_name, val). You only have to call this once and it will set the same value for all components with an unconnected parameter called param_name.\nIf you want different components that have parameters with the same name to have different values, then you need to call the 5-argument version of set_param! individually for each parameter value, such as:","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"set_param!(m, :comp1, :foo, :foo1, 25)  # creates an external parameter called :foo1 with value 25, and connects just comp1/foo to that value\nset_param!(m, :comp2, :foo, :foo2, 30)  # creates an external parameter called :foo2 with value 30, and connects just comp2/foo to that value","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"Also, you can no longer call set_param! to change the value of a parameter that has already been set in the model. If the parameter has already been set, you must use the following to change it:","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"update_param!(m, ext_param_name, new_val)","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"This updates the value of the external parameter called ext_param_name in the model m's list of external parameters. Any component that have parameters connected to this external parameter will now be connected to this new value.","category":"page"},{"location":"howto/howto_6/#The-replace_comp!-Function-1","page":"6 Port to v1.0.0","title":"The replace_comp! Function","text":"","category":"section"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"The Mimi Change: ","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"For simplicity, the replace_comp! function has been replaced with a method augmenting the julia Base replace! function.","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"The User Change:","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"Where you previously used","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"replace_comp!(m, new, old)","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"to replace the old component with new, they should now use","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"replace!(m, old => new)","category":"page"},{"location":"howto/howto_6/#Different-length-Components-1","page":"6 Port to v1.0.0","title":"Different-length Components","text":"","category":"section"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"The Mimi Change: ","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"Through Mimi v0.9.4, the optional keyword arguments first and last could be used to specify times for components that do not run for the full length of the model, like this: add_comp!(mymodel, ComponentC; first=2010, last=2100). This functionality is still disabled, as it was starting in v0.9.5, and all components must run for the full length of the model's time dimension. This functionality may be re-implemented in a later version of Mimi.","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"The User Change: ","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"Refactor your model so that all components are the same length. You may use the run_timestep function within each component to dictate it's behavior in different timesteps, including doing no calculations for a portion of the full model runtime.","category":"page"},{"location":"howto/howto_6/#Marginal-Models-1","page":"6 Port to v1.0.0","title":"Marginal Models","text":"","category":"section"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"The Mimi Change: ","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"For clarity, the previously named marginal attribute of a Mimi MarginalModel has been renamed to modified.  Hence a MarginalModel is now described as a Mimi Model whose results are obtained by subtracting results of one base Model from those of another marginal Model that has a difference of delta with the signature:","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"The User Change: ","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"Any previous access to the marginal attribute of a MarginalModel, mm below, should be changed from ","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"model = mm.marginal","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"to","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"model = mm.modified","category":"page"},{"location":"howto/howto_6/#Simulation-Syntax-1","page":"6 Port to v1.0.0","title":"Simulation Syntax","text":"","category":"section"},{"location":"howto/howto_6/#Results-Access-1","page":"6 Port to v1.0.0","title":"Results Access","text":"","category":"section"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"The Mimi Change: ","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"For clarity of return types, Mimi no longer supports use of square brackets (a shortcut for julia Base getindex) to access the results of a Monte Carlo analysis, which are stored in the SimulationInstance.  Instead, access to resulst is supported with the getdataframe function, which will return the results in the same type and format as the square bracket method used to return.","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"The User Change: ","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"Results previously obtained with ","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"results = si[:grosseconomy, :K]","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"should now be obtained with ","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"results = getdataframe(si, :grosseconomy, :K)","category":"page"},{"location":"howto/howto_6/#Simulation-Definition-Modification-Functions-1","page":"6 Port to v1.0.0","title":"Simulation Definition Modification Functions","text":"","category":"section"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"The Mimi Change: ","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"For consistency with julia syntax rules, the small set of unexported functions available to modify an existing SimulationDefinition have been renamed, moving from a camel case format to an underscore-based format as follows.","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"The User Change: ","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"Replace your functions as follows.","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"deleteRV! > delete_RV!\naddRV! > add_RV!\nreplaceRV! > replace_RV!\ndeleteTransform! > delete_transform!\naddTransform! > add_transform!\ndeleteSave! > delete_save!\naddSave! > add_save!","category":"page"},{"location":"howto/howto_6/#Composite-Components-(optional)-1","page":"6 Port to v1.0.0","title":"Composite Components (optional)","text":"","category":"section"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"The Mimi Change: ","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"The biggest functionality addition of Mimi v1.0.0 is the inclusion of composite components.  Prior versions of Mimi supported only \"flat\" models, i.e., with one level of components. This new version supports mulitple layers of components, with some components being \"final\" or leaf components, and others being \"composite\" components which themselves contain other leaf or composite components. This approach allows for a cleaner organization of complex models, and allows the construction of building blocks that can be re-used in multiple models.","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"The User Change: ","category":"page"},{"location":"howto/howto_6/#","page":"6 Port to v1.0.0","title":"6 Port to v1.0.0","text":"All previous models are considered \"flat\" models, i.e. they have only one level of components, and do not need to be converted into multiple layer models to run. Thus this addition does not mean users need to alter their models, but we encourage you to check out the other documentation on composite components to learn how you can enhance your current models and built better onces in the future!","category":"page"},{"location":"howto/howto_1/#How-to-Guide-1:-Construct-and-Run-a-Model-1","page":"1 Construct + Run a Model","title":"How-to Guide 1: Construct and Run a Model","text":"","category":"section"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"This how-to guide pairs nicely with Tutorial 4: Create a Model, serving as an abbreviated, less-detailed version and refresher for those with some experience with Mimi. If this is your first time constructing and running a Mimi model, we recommend you start with Tutorial 4, which will give you more detailed step-by step instructions.","category":"page"},{"location":"howto/howto_1/#Defining-Components-1","page":"1 Construct + Run a Model","title":"Defining Components","text":"","category":"section"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"Any Mimi model is made up of at least one component, so before you construct a model, you need to create your components.","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"A component can have any number of parameters and variables. Parameters are data values that will be provided to the component as input, and variables are values that the component will calculate in the run_timestep function when the model is run. The index of a parameter or variable determines the number of dimensions that parameter or variable has. They can be scalar values and have no index, such as parameter 'c' in the example below. They can be one-dimensional, such as the variable 'A' and the parameters 'd' and 'f' below. They can be two dimensional such as variable 'B' and parameter 'e' below. Note that any index other than 'time' must be declared at the top of the component, as shown by regions = Index() below.","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"The user must define a run_timestep function for each component. ","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"We define a component in the following way:","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"using Mimi\n\n@defcomp MyComponentName begin\n  regions = Index()\n\n  A = Variable(index = [time])\n  B = Variable(index = [time, regions])\n\n  c = Parameter()\n  d = Parameter(index = [time])\n  e = Parameter(index = [time, regions])\n  f = Parameter(index = [regions])\n\n  function run_timestep(p, v, d, t)\n    v.A[t] = p.c + p.d[t]\n    for r in d.regions\n      v.B[t, r] = p.f[r] * p.e[t, r]\n    end\n  end\nend","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"The run_timestep function is responsible for calculating values for each variable in that component.  Note that the component state (defined by the first three arguments) has fields for the Parameters, Variables, and Dimensions of the component you defined. You can access each parameter, variable, or dimension using dot notation as shown above.  The fourth argument is an AbstractTimestep, i.e., either a FixedTimestep or a VariableTimestep, which represents which timestep the model is at.","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"The API for using the fourth argument, represented as t in this explanation, is described in a following how-to guide How-to Guide 4: Work with Timesteps, Parameters, and Variables. ","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"To access the data in a parameter or to assign a value to a variable, you must use the appropriate index or indices (in this example, either the Timestep or region or both).","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"By default, all parameters and variables defined in the @defcomp will be allocated storage as scalars or Arrays of type Float64. For a description of other data type options, see How-to Guide 4: Work with Timesteps, Parameters, and Variables ","category":"page"},{"location":"howto/howto_1/#Constructing-a-Model-1","page":"1 Construct + Run a Model","title":"Constructing a Model","text":"","category":"section"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"The first step in constructing a model is to set the values for each index of the model. Below is an example for setting the 'time' and 'regions' indexes. The time index expects either a numerical range or an array of numbers.  If a single value is provided, say '100', then that index will be set from 1 to 100. Other indexes can have values of any type.","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"using Mimi\n\nm = Model()\nset_dimension!(m, :time, 1850:2200)\nset_dimension!(m, :regions, [\"USA\", \"EU\", \"LATAM\"])","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"A Note on Time Indexes: It is important to note that the values used for the time index are the start times of the timesteps.  If the range or array of time values has a uniform timestep length, the model will run through the last year of the range with a last timestep period length consistent with the other timesteps.  If the time values are provided as an array with non-uniform timestep lengths, the model will run through the last year in the array with a last timestep period length assumed to be one. ","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"The next step is to add components to the model. This is done by the following syntax:","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"add_comp!(m, ComponentA)\nadd_comp!(m, ComponentA, :GDP)","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"The first argument to add_comp! is the model, the second is the name of the ComponentId defined by @defcomp. If an optional third symbol is provided (as in the second line above), this will be used as the name of the component in this model. This allows you to add multiple versions of the same component to a model, with different names.","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"The next step is to set the values for all the parameters in the components. Parameters can either have their values assigned from external data, or they can internally connect to the values from variables in other components of the model.","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"To make an external connection, the syntax is as follows:","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"set_param!(m, :ComponentName, :ParameterName, 0.8) # a scalar parameter\nset_param!(m, :ComponentName, :ParameterName2, rand(351, 3)) # a two-dimensional parameter","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"To make an internal connection, the syntax is as follows.  ","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"connect_param!(m, :TargetComponent=>:ParameterName, :SourceComponent=>:VariableName)\nconnect_param!(m, :TargetComponent=>:ParameterName, :SourceComponent=>:VariableName)","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"If you wish to delete a component that has already been added, do the following:","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"delete!(m, :ComponentName)","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"This will delete the component from the model and remove any existing connections it had. Thus if a different component was previously connected to this component, you will need to connect its parameter(s) to something else.","category":"page"},{"location":"howto/howto_1/#Running-a-Model-1","page":"1 Construct + Run a Model","title":"Running a Model","text":"","category":"section"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"After all components have been added to your model and all parameters have been connected to either external values or internally to another component, then the model is ready to be run. Note: at each timestep, the model will run the components in the order you added them. So if one component is going to rely on the value of another component, then the user must add them to the model in the appropriate order.","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"run(m)","category":"page"},{"location":"howto_advanced/howto_adv_datumrefs/#Advanced-How-to-Guide:-Using-Datum-References-1","page":"Using Datum References","title":"Advanced How-to Guide: Using Datum References","text":"","category":"section"},{"location":"howto_advanced/howto_adv_datumrefs/#","page":"Using Datum References","title":"Using Datum References","text":"While it is not encouraged in the customary use of Mimi, some scenarios may make using references to datum desireable for code brevity and understandability.","category":"page"},{"location":"howto_advanced/howto_adv_datumrefs/#Component-References-1","page":"Using Datum References","title":"Component References","text":"","category":"section"},{"location":"howto_advanced/howto_adv_datumrefs/#","page":"Using Datum References","title":"Using Datum References","text":"Component references allow you to write cleaner model code when connecting components.  The add_comp! function returns a reference to the component that you just added:","category":"page"},{"location":"howto_advanced/howto_adv_datumrefs/#","page":"Using Datum References","title":"Using Datum References","text":"using Mimi\n\n# create a component\n@defcomp MyComp begin\n    # empty\nend\n\n# construct a model and add the component\nm = Model()\nset_dimension!(m, :time, collect(2015:5:2110))\nadd_comp!(m, MyComp)\ntypeof(MyComp) # note the type is a Mimi Component Definition","category":"page"},{"location":"howto_advanced/howto_adv_datumrefs/#","page":"Using Datum References","title":"Using Datum References","text":"If you want to get a reference to a component after the add_comp! call has been made, you can construct the reference as:","category":"page"},{"location":"howto_advanced/howto_adv_datumrefs/#","page":"Using Datum References","title":"Using Datum References","text":"mycomponent = Mimi.ComponentReference(m, :MyComp)\ntypeof(mycomponent) # note the type is a Mimi Component Reference","category":"page"},{"location":"howto_advanced/howto_adv_datumrefs/#","page":"Using Datum References","title":"Using Datum References","text":"You can use this component reference in place of the set_param! and connect_param! calls:","category":"page"},{"location":"howto_advanced/howto_adv_datumrefs/#References-in-place-of-set_param!-1","page":"Using Datum References","title":"References in place of set_param!","text":"","category":"section"},{"location":"howto_advanced/howto_adv_datumrefs/#","page":"Using Datum References","title":"Using Datum References","text":"The line set_param!(model, :MyComponent, :myparameter, myvalue) can be written as mycomponent[:myparameter] = myvalue, where mycomponent is a component reference.","category":"page"},{"location":"howto_advanced/howto_adv_datumrefs/#References-in-place-of-connect_param!-1","page":"Using Datum References","title":"References in place of connect_param!","text":"","category":"section"},{"location":"howto_advanced/howto_adv_datumrefs/#","page":"Using Datum References","title":"Using Datum References","text":"The line connect_param!(model, :MyComponent, :myparameter, :YourComponent, :yourparameter) can be written as mycomponent[:myparameter] = yourcomponent[:yourparameter], where mycomponent and yourcomponent are component references.","category":"page"},{"location":"internals/dimension_mapping/#Cross-model-Connectors-1","page":"Cross-model Connectors","title":"Cross-model Connectors","text":"","category":"section"},{"location":"internals/dimension_mapping/#Thoughts-on-matching-indices-across-models-that-may-have-different-timesteps,-regional-aggregations,-etc.-1","page":"Cross-model Connectors","title":"Thoughts on matching indices across models that may have different timesteps, regional aggregations, etc.","text":"","category":"section"},{"location":"internals/dimension_mapping/#","page":"Cross-model Connectors","title":"Cross-model Connectors","text":"The basic idea is to allow a keyword arg to connect_param!() to identify a connector  component that performs the mapping between disparate dimension definitions.","category":"page"},{"location":"internals/dimension_mapping/#","page":"Cross-model Connectors","title":"Cross-model Connectors","text":"We could provide a couple more \"standard\" connectors","category":"page"},{"location":"internals/dimension_mapping/#","page":"Cross-model Connectors","title":"Cross-model Connectors","text":"Time\nGet most recent value from before the receiving model's current timestep\nGet the sum of values between the receiving model's current and prior timestep\nRegions\nPass in a region map that defines transformations between two regional definitions\nOperators can include\nWeighted Avg:  new region value = avg(parameter[regions] .* weight[regions])\nWeighted sum: new region value = sum(parameter[regions] .* weight[regions])\nWeights can be the value of some parameter, e.g., population, area, GDP\nDisaggregation can be handled similarly\nnew sub-region value = parameter[region] * weight[region]","category":"page"},{"location":"internals/dimension_mapping/#","page":"Cross-model Connectors","title":"Cross-model Connectors","text":"We can create macro to define connector components that perform these dimension adjustments. We would define a new macro that simplifies creation of a @defcomp of a given name  that can be specified in connect_param! to perform the defined mapping.","category":"page"},{"location":"internals/dimension_mapping/#","page":"Cross-model Connectors","title":"Cross-model Connectors","text":"To map across both time and regions, we could implement a pair of connector components that might look like the following, which would be called for each timestep t in  the receiving component:","category":"page"},{"location":"internals/dimension_mapping/#","page":"Cross-model Connectors","title":"Cross-model Connectors","text":"# This component would run first, mapping emissions to the new time boundaries\n@defcomp time_mapper begin\n    src = Variable(index=[m1.time, m1.regions])\n    dst = Parameter(index=[m2.time, m1.regions])   # uses src model's regions\n\n    # Simple time adapter that just sums any values produced since the prior \n    # timestep, without performing any allocation or interpolation.\n    function run_timestep(p, v, d, t)\n        for r in d.regions\n            values = [v.src[tsrc, r] for tsrc in m1.time if t - 1 < tsrc <= t]\n            p.dst[t, r] = sum(values)\n        end\n    end\nend\n\n# This component would run next, mapping emissions to the new regional boundaries\n@defcomp region_mapper begin\n    # Source here would be the emissions_time_mapper component\n    src  = Variable(index=[time, m1.regions])\n    sgdp = Variable(index=[time, m1.regions])\n    dst  = Parameter(index=[time, m2.regions])\n    dgdp = Parameter(index=[time, m2.regions])\n\n    function run_timestep(p, v, d, t)\n        # Aggregate to region :OthNAmer by summing values of src over :Mex and :Can\n        p.dst[t, :OthNAmer] = sum(v.src[t, [:Mex, :Can]])\n\n        # Disaggregate :SAmer into :Bra and :OthSAmer by fraction of GDP\n        p.dst[:Bra, t]      = v.src[t, :SAmer] * p.dgdp[t, :Bra]      / v.sgdp[t, :SAmer]\n        p.dst[:OthSAmer, t] = v.src[t, :SAmer] * p.dgdp[t, :OthSAmer] / v.sgdp[t, :SAmer]\n    end\nend","category":"page"},{"location":"internals/dimension_mapping/#","page":"Cross-model Connectors","title":"Cross-model Connectors","text":"Notes:","category":"page"},{"location":"internals/dimension_mapping/#","page":"Cross-model Connectors","title":"Cross-model Connectors","text":"Specifying index values by symbol as we do currently is inadequate when these can  refer to different models. Probably need to support module specification, e.g.,  dice2010.time.\nWhen combining components with different time dimensions, we should run the model on the union of all time dimension definitions. For example, if model 1 is defined on 10-yr timesteps (2010, 2020, ...) and model 2 is defined on 4-yr timesteps (2010, 2014, 2018, ...), the combined time dimension for the models would be (2010, 2014, 2018, 2020, 2022, ... ).\nThe main run_timestep would iterate over the combined time dimension, calling each component's run_timestep only for timesteps defined for that component.\nIf  src has 5-yr timesteps and dst has 10-yr timesteps, emissions in dst  time tdst would sum emissions from src time tsrc and tsrc - 1.  More generally, accumulating into dst in timestep tdst would sum values from src timesteps tsrc where  tdst - 1 < tsrc <= tdst. For dependencies on the  prior timestep, it would sum values where dst[t-2] < tsrc <= dst[t-1].\nRegional alignment may be combined with timestep alignment. In this case, time should be aligned first, since components are run on time boundaries. Then regional alignment can be handled based on time-aligned values.\nIn some cases, we will want to allocate values from a source model across multiple timesteps in the destination model. For example, if model src is defined on 10-yr timesteps (2010, 2020, 2030, ...) and model dst is defined on 5-yr timesteps, (2010, 2015, 2020, 2025, ...) we might allocate half of the 2010-2010  value from src in 2010-2020 to each of the dst periods 2010-2015 and 2015-2020. This allocation would be appropriate for flow parameters such as emissions. For stock  parameters, e.g., CO<sub>2</sub> concentration, we would want to interpolate between src timestep values.\nThis suggests a need for metadata on parameters indicating whether they are of the stock or flow variety.\nThe problem with this is that is requires knowing a future value to allocate or interpolate between a past value before the dst model's timestep t, and the subsequent value in occurring after t. This would require running the dst model one or more timesteps lagged.","category":"page"},{"location":"#Welcome-to-Mimi-1","page":"Home","title":"Welcome to Mimi","text":"","category":"section"},{"location":"#Overview-1","page":"Home","title":"Overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Mimi is a Julia package that provides a component model for integrated assessment models, as described in detail on the Mimi Framework Homepage.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The documentation is organized into the following four sections, roughly adhering to the Divio documentation system guidelines. For insights into the goals of each of these documentation categories, please refer to the Divio documentation.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Tutorials\nHow-to Guides\nTechnical Reference\nExplanations","category":"page"},{"location":"#Getting-started-1","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"We aim to assist users of all different experience levels, starting with first-time users. If this is your first time using Mimi, we recommend you begin with the Tutorials. In addition, looking through the code at the links below to various existing models based on Mimi can be instructive. ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The first step for any user includes installation of julia and Mimi, as well as optionally adding the Mimi Registry. See the first tutorial for instructions on these tasks.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Finally, when in doubt, ask your question on the Mimi Framework forum or post an Issue to the Github repository, the latter being especially pertintent if you have a specific request for the development team.   Don't be shy about either option, we would much prefer to be inundated with lots of questions and help people out than people give up on Mimi!","category":"page"},{"location":"#Models-using-Mimi-1","page":"Home","title":"Models using Mimi","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"MimiFUND.jl (currently in beta)\nMimiDICE2010.jl\nMimiDICE2013.jl\nMimiRICE2010.jl\nMimi-SNEASY.jl (currently in closed beta)\nMimi-FAIR.jl (currently in closed beta)\nMimiPAGE2009.jl (currently in closed beta)\nMimi-MAGICC.jl (CH4 parts currently in closed beta)\nMimi-HECTOR.jl (CH4 parts currently in closed beta)\nMimi-CIAM.jl (currently in closed beta)\nMimi-BRICK.jl (currently in closed beta)\nAWASH\nPAGE-ICE","category":"page"},{"location":"tutorials/tutorial_1/#Tutorial-1:-Install-Mimi-1","page":"1 Install Mimi","title":"Tutorial 1: Install Mimi","text":"","category":"section"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"This tutorial describes how to set up your system by installing julia, Mimi, and the Mimi registry.","category":"page"},{"location":"tutorials/tutorial_1/#Installing-julia-1","page":"1 Install Mimi","title":"Installing julia","text":"","category":"section"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"Mimi requires the programming language julia to run. You can download the current release from the julia download page. You should download and install the command line version from that page.","category":"page"},{"location":"tutorials/tutorial_1/#Editor-support-1","page":"1 Install Mimi","title":"Editor support","text":"","category":"section"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"There are various editors around that have julia support, including the following:","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"IJulia adds julia support to the jupyter (formerly IPython) notebook system.\nVS Code has an excellent julia extension\nother editors such as Emacs and Sublime have julia extensions that add various levels of support for the julia language.","category":"page"},{"location":"tutorials/tutorial_1/#Installing-Mimi-1","page":"1 Install Mimi","title":"Installing Mimi","text":"","category":"section"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"Once julia is installed, start julia and you should see a julia command prompt. To install the Mimi package, issue the following command from the Pkg REPL mode, which is entered by typing ] and exited with a single backspace:","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"pkg> add Mimi","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"You only have to run this command once on your machine.","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"As we work to enhance and improve Mimi we will release new versions of the package. To make sure you always have the latest version of Mimi installed, we recommend that on occasion you run the following command at the julia Pkg REPL:","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"pkg> update","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"This will update all installed packages to their latest version (not just the Mimi package). To only update the Mimi package you may run the following, although we recommend you do a comprehensive update each time as indicated above.","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"pkg> update Mimi","category":"page"},{"location":"tutorials/tutorial_1/#Using-Mimi-1","page":"1 Install Mimi","title":"Using Mimi","text":"","category":"section"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"When you start a new julia command prompt, Mimi is not yet loaded into that julia session. To load Mimi, issue the following command:","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"julia> using Mimi","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"You will have to run this command every time you want to use Mimi in julia. You would typically also add using Mimi to the top of any julia code file that employs the Mimi API.","category":"page"},{"location":"tutorials/tutorial_1/#Mimi-Registry-1","page":"1 Install Mimi","title":"Mimi Registry","text":"","category":"section"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"To access the models in the MimiRegistry, you first need to connect your julia installation with the central Mimi registry of Mimi models. This central registry is like a catalogue of models that use Mimi that is maintained by the Mimi project. To add this registry, run the following command at the julia package REPL:","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"pkg> registry add https://github.com/mimiframework/MimiRegistry.git","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"You only need to run this command once on a computer. ","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"From there you will be add any of the registered packages, such as MimiDICE2010.jl by running the following command at the julia package REPL:","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"pkg> add MimiDICE2010","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"After taking the steps above you have prepared your system and are ready to run the next tutorials!","category":"page"}]
}
